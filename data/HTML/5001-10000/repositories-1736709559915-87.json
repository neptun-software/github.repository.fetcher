{
  "metadata": {
    "timestamp": 1736709559915,
    "page": 87,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "EsotericSoftware/kryo",
      "stars": 6236,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.23046875,
          "content": "# Temporary Files\n*~\n.*.swp\n.DS_STORE\n*.iml\n\nbenchmarks/charts/results\njmh-result.csv\n.R*\n\nbin/\ntarget/\n\n# Mac specific files\n.DS_Store\n\n# Vim\n.*.sw[0-9a-zA-Z]\n\n# IntelliJ\n.idea/\n*.iml\n*.ipr\n*.iws\n\n# Eclipse\n.apt_generated/\n.Rproj.user\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.10546875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nadmin@esotericsoftware.com.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.4150390625,
          "content": "Project license(s): 3-Clause BSD License\n\n* You will only Submit Contributions where You have authored 100% of the content.\n\n* You will only Submit Contributions to which You have the necessary rights. This means that if You are employed You have received the necessary permissions from Your employer to make the Contributions.\n\n* Whatever content You Contribute will be under the copyright and license listed in LICENSE.md.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.4453125,
          "content": "Copyright (c) 2008-2023, Nathan Sweet\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n* Neither the name of Esoteric Software nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 74.537109375,
          "content": "![KryoNet](https://raw.github.com/wiki/EsotericSoftware/kryo/images/logo.jpg)\n\n[![Build Status](https://github.com/EsotericSoftware/kryo/actions/workflows/ci-workflow.yml/badge.svg)](https://github.com/EsotericSoftware/kryo/actions/workflows/ci-workflow.yml)\n[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.esotericsoftware/kryo/badge.svg)](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.esotericsoftware%22%20AND%20a%3Akryo)\n[![Join the chat at https://gitter.im/EsotericSoftware/kryo](https://badges.gitter.im/EsotericSoftware/kryo.svg)](https://gitter.im/EsotericSoftware/kryo)\n[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/kryo.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:kryo)\n\nKryo is a fast and efficient binary object graph serialization framework for Java. The goals of the project are high speed, low size, and an easy to use API. The project is useful any time objects need to be persisted, whether to a file, database, or over the network.\n\nKryo can also perform automatic deep and shallow copying/cloning. This is direct copying from object to object, not object to bytes to object.\n\nThis documentation is for Kryo version 5.x. See [the Wiki](https://github.com/EsotericSoftware/kryo/wiki/Kryo-v4) for version 4.x.\n\n## Contact / Mailing list\n\nPlease use the [Kryo mailing list](https://groups.google.com/forum/#!forum/kryo-users) for questions, discussions, and support. Please limit use of the Kryo issue tracker to bugs and enhancements, not questions, discussions, or support.\n\n## Table of contents\n\n- [Recent releases](#recent-releases)\n- [Installation](#installation)\n   * [With Maven](#with-maven)\n   * [Without Maven](#without-maven)\n   * [Building from source](#building-from-source)\n- [Quickstart](#quickstart)\n- [IO](#io)\n   * [Output](#output)\n   * [Input](#input)\n   * [ByteBuffers](#bytebuffers)\n   * [Unsafe buffers](#unsafe-buffers)\n   * [Variable length encoding](#variable-length-encoding)\n   * [Chunked encoding](#chunked-encoding)\n   * [Buffer performance](#buffer-performance)\n- [Reading and writing objects](#reading-and-writing-objects)\n   * [Round trip](#round-trip)\n   * [Deep and shallow copies](#deep-and-shallow-copies)\n   * [References](#references)\n      + [ReferenceResolver](#referenceresolver)\n      + [Reference limits](#reference-limits)\n   * [Context](#context)\n   * [Reset](#reset)\n- [Serializer framework](#serializer-framework)\n   * [Registration](#registration)\n      + [ClassResolver](#classresolver)\n      + [Optional registration](#optional-registration)\n   * [Default serializers](#default-serializers)\n      + [Serializer factories](#serializer-factories)\n   * [Object creation](#object-creation)\n      + [InstantiatorStrategy](#instantiatorstrategy)\n      + [Overriding create](#overriding-create)\n   * [Final classes](#final-classes)\n   * [Closures](#closures)\n   * [Compression and encryption](#compression-and-encryption)\n- [Implementing a serializer](#implementing-a-serializer)\n   * [Serializer references](#serializer-references)\n      + [Nested serializers](#nested-serializers)\n      + [KryoException](#kryoexception)\n      + [Stack size](#stack-size)\n   * [Accepting null](#accepting-null)\n   * [Generics](#generics)\n   * [KryoSerializable](#kryoserializable)\n   * [Serializer copying](#serializer-copying)\n      + [KryoCopyable](#kryocopyable)\n      + [Immutable serializers](#immutable-serializers)\n- [Kryo versioning and upgrading](#kryo-versioning-and-upgrading)\n- [Interoperability](#interoperability)\n- [Compatibility](#compatibility)\n   * [Replacing a class](#replacing-a-class)\n- [Serializers](#serializers)\n   * [FieldSerializer](#fieldserializer)\n      + [CachedField settings](#cachedfield-settings)\n      + [FieldSerializer annotations](#fieldserializer-annotations)\n   * [VersionFieldSerializer](#versionfieldserializer)\n   * [TaggedFieldSerializer](#taggedfieldserializer)\n   * [CompatibleFieldSerializer](#compatiblefieldserializer)\n   * [BeanSerializer](#beanserializer)\n   * [CollectionSerializer](#collectionserializer)\n   * [MapSerializer](#mapserializer)\n   * [JavaSerializer and ExternalizableSerializer](#javaserializer-and-externalizableserializer)\n- [Logging](#logging)\n- [Thread safety](#thread-safety)\n   * [Pooling](#pooling)\n- [Benchmarks](#benchmarks)\n- [Links](#links)\n   * [Projects using Kryo](#projects-using-kryo)\n   * [Scala](#scala)\n   * [Clojure](#clojure)\n   * [Objective-C](#objective-c)\n\n## Recent releases\n\n* [4.0.3](https://github.com/EsotericSoftware/kryo/releases/tag/kryo-parent-4.0.3) - brings bug fixes and performance improvements for chunked encoding.\n* [5.6.2](https://github.com/EsotericSoftware/kryo/releases/tag/kryo-parent-5.6.2) - recompiles 5.6.1 to be compatible with Java 8 again\n* [5.6.1](https://github.com/EsotericSoftware/kryo/releases/tag/kryo-parent-5.6.1) - brings a bug fix for the Maven coordinates of the versioned artifact\n* [5.6.0](https://github.com/EsotericSoftware/kryo/releases/tag/kryo-parent-5.6.0) - brings bug fixes and performance improvements.\n* [5.5.0](https://github.com/EsotericSoftware/kryo/releases/tag/kryo-parent-5.5.0) - brings bug fixes and performance improvements.\n\n## Installation\n\nKryo publishes two kinds of artifacts/jars:\n* the default jar (with the usual library dependencies) which is meant for direct usage in applications (not libraries)\n* a dependency-free, \"versioned\" jar which should be used by other libraries. Different libraries shall be able to use different major versions of Kryo.\n\nKryo JARs are available on the [releases page](https://github.com/EsotericSoftware/kryo/releases) and at [Maven Central](https://search.maven.org/#search|gav|1|g%3Acom.esotericsoftware%20a%3Akryo). The latest snapshots of Kryo, including snapshot builds of master, are in the [Sonatype Repository](https://oss.sonatype.org/content/repositories/snapshots/com/esotericsoftware/kryo/).\n\n### With Maven\n\nTo use the latest Kryo release in your application, use this dependency entry in your `pom.xml`:\n\n```xml\n<dependency>\n   <groupId>com.esotericsoftware</groupId>\n   <artifactId>kryo</artifactId>\n   <version>5.6.2</version>\n</dependency>\n```\n\nTo use the latest Kryo release in a library you want to publish, use this dependency entry in your `pom.xml`:\n\n```xml\n<dependency>\n   <groupId>com.esotericsoftware.kryo</groupId>\n   <artifactId>kryo5</artifactId>\n   <version>5.6.2</version>\n</dependency>\n```\n\nTo use the latest Kryo snapshot, use:\n\n```xml\n<repository>\n   <id>sonatype-snapshots</id>\n   <name>sonatype snapshots repo</name>\n   <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n</repository>\n\n<!-- for usage in an application: -->\n<dependency>\n   <groupId>com.esotericsoftware</groupId>\n   <artifactId>kryo</artifactId>\n   <version>5.6.3-SNAPSHOT</version>\n</dependency>\n<!-- for usage in a library that should be published: -->\n<dependency>\n   <groupId>com.esotericsoftware.kryo</groupId>\n   <artifactId>kryo5</artifactId>\n   <version>5.6.3-SNAPSHOT</version>\n</dependency>\n```\n\n### Without Maven\n\nNot everyone is a Maven fan. Using Kryo without Maven requires placing the [Kryo JAR](#installation) on your classpath along with the dependency JARs found in [lib](https://github.com/EsotericSoftware/kryo/tree/master/lib).\n\n### Building from source\n\nBuilding Kryo from source requires JDK11+ and Maven. To build all artifacts, run:\n\n```\nmvn clean && mvn install\n```\n\n## Quickstart\n\nJumping ahead to show how the library can be used:\n\n```java\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport java.io.*;\n\npublic class HelloKryo {\n   static public void main (String[] args) throws Exception {\n      Kryo kryo = new Kryo();\n      kryo.register(SomeClass.class);\n\n      SomeClass object = new SomeClass();\n      object.value = \"Hello Kryo!\";\n\n      Output output = new Output(new FileOutputStream(\"file.bin\"));\n      kryo.writeObject(output, object);\n      output.close();\n\n      Input input = new Input(new FileInputStream(\"file.bin\"));\n      SomeClass object2 = kryo.readObject(input, SomeClass.class);\n      input.close();   \n   }\n   static public class SomeClass {\n      String value;\n   }\n}\n```\n\nThe Kryo class performs the serialization automatically. The Output and Input classes handle buffering bytes and optionally flushing to a stream.\n\nThe rest of this document details how this works and advanced usage of the library.\n\n## IO\n\nGetting data in and out of Kryo is done using the Input and Output classes. These classes are not thread safe.\n\n### Output\n\nThe Output class is an OutputStream that writes data to a byte array buffer. This buffer can be obtained and used directly, if a byte array is desired. If the Output is given an OutputStream, it will flush the bytes to the stream when the buffer becomes full, otherwise Output can grow its buffer automatically. Output has many methods for efficiently writing primitives and strings to bytes. It provides functionality similar to DataOutputStream, BufferedOutputStream, FilterOutputStream, and ByteArrayOutputStream, all in one class.\n\n> Tip: Output and Input provide all the functionality of ByteArrayOutputStream. There is seldom a reason to have Output flush to a ByteArrayOutputStream.\n\nOutput buffers the bytes when writing to an OutputStream, so `flush` or `close` must be called after writing is complete to cause the buffered bytes to be written to the OutputStream. If the Output has not been provided an OutputStream, calling `flush` or `close` is unnecessary. Unlike many streams, an Output instance can be reused by setting the position, or setting a new byte array or stream.\n\n> Tip: Since Output buffers already, there is no reason to have Output flush to a BufferedOutputStream.\n\nThe zero argument Output constructor creates an uninitialized Output. Output `setBuffer` must be called before the Output can be used.\n\n### Input\n\nThe Input class is an InputStream that reads data from a byte array buffer. This buffer can be set directly, if reading from a byte array is desired. If the Input is given an InputStream, it will fill the buffer from the stream when all the data in the buffer has been read. Input has many methods for efficiently reading primitives and strings from bytes. It provides functionality similar to DataInputStream, BufferedInputStream, FilterInputStream, and ByteArrayInputStream, all in one class.\n\n> Tip: Input provides all the functionality of ByteArrayInputStream. There is seldom a reason to have Input read from a ByteArrayInputStream.\n\nIf the Input `close` is called, the Input's InputStream is closed, if any. If not reading from an InputStream then it is not necessary to call `close`. Unlike many streams, an Input instance can be reused by setting the position and limit, or setting a new byte array or InputStream.\n\nThe zero argument Input constructor creates an uninitialized Input. Input `setBuffer` must be called before the Input can be used.\n\n### ByteBuffers\n\nThe ByteBufferOutput and ByteBufferInput classes work exactly like Output and Input, except they use a ByteBuffer rather than a byte array.\n\n### Unsafe buffers\n\nThe UnsafeOutput, UnsafeInput, UnsafeByteBufferOutput, and UnsafeByteBufferInput classes work exactly like their non-unsafe counterparts, except they use sun.misc.Unsafe for higher performance in many cases. To use these classes `Util.unsafe` must be true.\n\nThe downside to using unsafe buffers is that the native endianness and representation of numeric types of the system performing the serialization affects the serialized data. For example, deserialization will fail if the data is written on X86 and read on SPARC. Also, if data is written with an unsafe buffer, it must be read with an unsafe buffer.\n\nThe biggest performance difference with unsafe buffers is with [large primitive arrays](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/array.png) when variable length encoding is not used. Variable length encoding can be disabled for the unsafe buffers or only for specific fields (when using FieldSerializer).\n\n### Variable length encoding\n\nThe IO classes provide methods to read and write variable length int (varint) and long (varlong) values. This is done by using the 8th bit of each byte to indicate if more bytes follow, which means a varint uses 1-5 bytes and a varlong uses 1-9 bytes. Using variable length encoding is [more expensive](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/variableEncoding.png) but makes the serialized data much smaller.\n\nWhen writing a variable length value, the value can be optimized either for positive values or for both negative and positive values. For example, when optimized for positive values, 0 to 127 is written in one byte, 128 to 16383 in two bytes, etc. However, small negative numbers are the worst case at 5 bytes. When not optimized for positive, these ranges are shifted down by half. For example, -64 to 63 is written in one byte, 64 to 8191 and -65 to -8192 in two bytes, etc.\n\nInput and Output buffers provides methods to read and write fixed sized or variable length values. There are also methods to allow the buffer to decide whether a fixed size or variable length value is written. This allows serialization code to ensure variable length encoding is used for very common values that would bloat the output if a fixed size were used, while still allowing the buffer configuration to decide for all other values.\n\nMethod | Description\n--- | ---\nwriteInt(int) | Writes a 4 byte int.\nwriteVarInt(int, boolean) | Writes a 1-5 byte int.\nwriteInt(int, boolean) | Writes either a 4 or 1-5 byte int (the buffer decides).\nwriteLong(long) | Writes an 8 byte long.\nwriteVarLong(long, boolean) | Writes an 1-9 byte long.\nwriteLong(long, boolean) | Writes either an 8 or 1-9 byte long (the buffer decides).\n\nTo disable variable length encoding for all values, the `writeVarInt`, `writeVarLong`, `readVarInt`, and `readVarLong` methods would need to be overridden.\n\n### Chunked encoding\n\nIt can be useful to write the length of some data, then the data. When the length of the data is not known ahead of time, all the data needs to be buffered to determine its length, then the length can be written, then the data. using a single, large buffer for this would prevent streaming and may require an unreasonably large buffer, which is not ideal.\n\nChunked encoding solves this problem by using a small buffer. When the buffer is full, its length is written, then the data. This is one chunk of data. The buffer is cleared and this continues until there is no more data to write. A chunk with a length of zero denotes the end of the chunks.\n\nKryo provides classes to make chunked encoding easy to use. OutputChunked is used to write chunked data. It extends Output, so has all the convenient methods to write data. When the OutputChunked buffer is full, it flushes the chunk to another OutputStream. The `endChunk` method is used to mark the end of a set of chunks.\n\n```java\nOutputStream outputStream = new FileOutputStream(\"file.bin\");\nOutputChunked output = new OutputChunked(outputStream, 1024);\n// Write data to output...\noutput.endChunk();\n// Write more data to output...\noutput.endChunk();\n// Write even more data to output...\noutput.endChunk();\noutput.close();\n```\n\nTo read the chunked data, InputChunked is used. It extends Input, so has all the convenient methods to read data. When reading, InputChunked will appear to hit the end of the data when it reaches the end of a set of chunks. The `nextChunks` method advances to the next set of chunks, even if not all the data has been read from the current set of chunks.\n\n```java\nInputStream outputStream = new FileInputStream(\"file.bin\");\nInputChunked input = new InputChunked(inputStream, 1024);\n// Read data from first set of chunks...\ninput.nextChunks();\n// Read data from second set of chunks...\ninput.nextChunks();\n// Read data from third set of chunks...\ninput.close();\n```\n\n### Buffer performance\n\nGenerally Output and Input provide good performance. Unsafe buffers perform as well or better, especially for primitive arrays, if their crossplatform incompatibilities are acceptable. ByteBufferOutput and ByteBufferInput provide slightly worse performance, but this may be acceptable if the final destination of the bytes must be a ByteBuffer.\n\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/string.png)\n\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/array.png)\n\nVariable length encoding is slower than fixed values, especially when there is a lot of data using it.\n\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/variableEncoding.png)\n\nChunked encoding uses an intermediary buffer so it adds one additional copy of all the bytes. This alone may be acceptable, however when used in a reentrant serializer, the serializer must create an OutputChunked or InputChunked for each object. Allocating and garbage collecting those buffers during serialization can have a negative impact on performance.\n\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/fieldSerializer.png)\n\n## Reading and writing objects\n\nKryo has three sets of methods for reading and writing objects. If the concrete class of the object is not known and the object could be null:\n\n```java\nkryo.writeClassAndObject(output, object);\n\nObject object = kryo.readClassAndObject(input);\nif (object instanceof SomeClass) {\n   // ...\n}\n```\n\nIf the class is known and the object could be null:\n\n```java\nkryo.writeObjectOrNull(output, object);\n\nSomeClass object = kryo.readObjectOrNull(input, SomeClass.class);\n```\n\nIf the class is known and the object cannot be null:\n\n```java\nkryo.writeObject(output, object);\n\nSomeClass object = kryo.readObject(input, SomeClass.class);\n```\n\nAll of these methods first find the appropriate serializer to use, then use that to serialize or deserialize the object. Serializers can call these methods for recursive serialization. Multiple references to the same object and circular references are handled by Kryo automatically.\n\nBesides methods to read and write objects, the Kryo class provides a way to register serializers, reads and writes class identifiers efficiently, handles null objects for serializers that can't accept nulls, and handles reading and writing object references (if enabled). This allows serializers to focus on their serialization tasks.\n\n### Round trip\n\nWhile testing and exploring Kryo APIs, it can be useful to write an object to bytes, then read those bytes back to an object.\n\n```java\nKryo kryo = new Kryo();\n\n// Register all classes to be serialized.\nkryo.register(SomeClass.class);\n\nSomeClass object1 = new SomeClass();\n\nOutput output = new Output(1024, -1);\nkryo.writeObject(output, object1);\n\nInput input = new Input(output.getBuffer(), 0, output.position());\nSomeClass object2 = kryo.readObject(input, SomeClass.class);\n```\n\nIn this example the Output starts with a buffer that has a capacity of 1024 bytes. If more bytes are written to the Output, the buffer will grow in size without limit. The Output does not need to be closed because it has not been given an OutputStream. The Input reads directly from the Output's `byte[]` buffer.\n\n### Deep and shallow copies\n\nKryo supports making deep and shallow copies of objects using direct assignment from one object to another. This is more efficient than serializing to bytes and back to objects.\n\n```java\nKryo kryo = new Kryo();\nSomeClass object = ...\nSomeClass copy1 = kryo.copy(object);\nSomeClass copy2 = kryo.copyShallow(object);\n```\n\nAll the serializers being used need to support [copying](#serializer-copying). All serializers provided with Kryo support copying.\n\nLike with serialization, when copying, multiple references to the same object and circular references are handled by Kryo automatically if references are enabled.\n\nIf using Kryo only for copying, registration can be safely disabled.\n\nKryo `getOriginalToCopyMap` can be used after an object graph is copied to obtain a map of old to new objects. The map is cleared automatically by Kryo `reset`, so is only useful when Kryo `setAutoReset` is false.\n\n### References\n\nBy default references are not enabled. This means if an object appears in an object graph multiple times, it will be written multiple times and will be deserialized as multiple, different objects. When references are disabled, circular references will cause serialization to fail. References are enabled or disabled with Kryo `setReferences` for serialization and `setCopyReferences` for copying.\n\nWhen references are enabled, a varint is written before each object the first time it appears in the object graph. For subsequent appearances of that class within the same object graph, only a varint is written. After deserialization the object references are restored, including any circular references. The serializers in use must [support references](#serializer-references) by calling Kryo `reference` in Serializer `read`.\n\nEnabling references impacts performance because every object that is read or written needs to be tracked.\n\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/fieldSerializer.png)\n\n#### ReferenceResolver\n\nUnder the covers, a ReferenceResolver handles tracking objects that have been read or written and provides int reference IDs. Multiple implementations are provided:\n\n1. MapReferenceResolver is used by default if a reference resolver is not specified. It uses Kryo's IdentityObjectIntMap (a [cuckoo hashmap](https://en.wikipedia.org/wiki/Cuckoo%5Fhashing)) to track written objects. This kind of map has very fast gets and does not allocate for put, but puts for very large numbers of objects can be somewhat slow.\n2. HashMapReferenceResolver uses a HashMap to track written objects. This kind of map allocates for put but may provide better performance for object graphs with a very high number of objects.\n3. ListReferenceResolver uses an ArrayList to track written objects. For object graphs with relatively few objects, this can be faster than using a map (~15% faster in some tests). This should not be used for graphs with many objects because it has a linear look up to find objects that have already been written.\n\nReferenceResolver `useReferences(Class)` can be overridden. It returns a boolean to decide if references are supported for a class. If a class doesn't support references, the varint reference ID is not written before objects of that type. If a class does not need references and objects of that type appear in the object graph many times, the serialized size can be greatly reduced by disabling references for that class. The default reference resolver returns false for all primitive wrappers and enums. It is common to also return false for String and other classes, depending on the object graphs being serialized.\n\n```java\npublic boolean useReferences (Class type) {\n   return !Util.isWrapperClass(type) && !Util.isEnum(type) && type != String.class;\n}\n```\n\n#### Reference limits\n\nThe reference resolver determines the maximum number of references in a single object graph. Java array indices are limited to `Integer.MAX_VALUE`, so reference resolvers that use data structures based on arrays may result in a `java.lang.NegativeArraySizeException` when serializing more than ~2 billion objects. Kryo uses int class IDs, so the maximum number of references in a single object graph is limited to the full range of positive and negative numbers in an int (~4 billion).\n\n### Context\n\nKryo `getContext` returns a map for storing user data. The Kryo instance is available to all serializers, so this data is easily accessible to all serializers.\n\nKryo `getGraphContext` is similar, but is cleared after each object graph is serialized or deserialized. This makes it easy to manage state that is only relevant for the current object graph. For example, this can be used to write some schema data the first time a class is encountered in an object graph. See CompatibleFieldSerializer for an example.\n\n### Reset\n\nBy default, Kryo `reset` is called after each entire object graph is serialized. This resets unregistered class names in the [class resolver](#classresolver), references to previously serialized or deserialized objects in the [reference resolver](#referenceresolver), and clears the graph context. Kryo `setAutoReset(false)` can be used to disable calling `reset` automatically, allowing that state to span multiple object graphs.\n\n## Serializer framework\n\nKryo is a framework to facilitate serialization. The framework itself doesn't enforce a schema or care what or how data is written or read. Serializers are pluggable and make the decisions about what to read and write. Many serializers are provided out of the box to read and write data in various ways. While the provided serializers can read and write most objects, they can easily be replaced partially or completely with your own serializers.\n\n### Registration\n\nWhen Kryo goes to write an instance of an object, first it may need to write something that identifies the object's class. By default, all classes that Kryo will read or write must be registered beforehand. Registration provides an int class ID, the serializer to use for the class, and the [object instantiator](#object-creation) used to create instances of the class.\n\n```java\nKryo kryo = new Kryo();\nkryo.register(SomeClass.class);\nOutput output = ...\nSomeClass object = ...\nkryo.writeObject(output, object);\n```\n\nDuring deserialization, the registered classes must have the exact same IDs they had during serialization. When registered, a class is assigned the next available, lowest integer ID, which means the order classes are registered is important. The class ID can optionally be specified explicitly to make order unimportant:\n\n```java\nKryo kryo = new Kryo();\nkryo.register(SomeClass.class, 9);\nkryo.register(AnotherClass.class, 10);\nkryo.register(YetAnotherClass.class, 11);\n```\n\nClass IDs -1 and -2 are reserved. Class IDs 0-8 are used by default for primitive types and String, though these IDs can be repurposed. The IDs are written as positive optimized varints, so are most efficient when they are small, positive integers. Negative IDs are not serialized efficiently.\n\n#### ClassResolver\n\nUnder the covers, a ClassResolver handles actually reading and writing bytes to represent a class. The default implementation is sufficient in most cases, but it can be replaced to customize what happens when a class is registered, what happens when an unregistered class is encountered during serialization, and what is read and written to represent a class.\n\n#### Optional registration\n\nKryo can be configured to allow serialization without registering classes up front.\n\n```java\nKryo kryo = new Kryo();\nkryo.setRegistrationRequired(false);\nOutput output = ...\nSomeClass object = ...\nkryo.writeObject(output, object);\n```\n\nUse of registered and unregistered classes can be mixed. Unregistered classes have two major drawbacks:\n\n1. There are security implications because it allows deserialization to create instances of any class. Classes with side effects during construction or finalization could be used for malicious purposes.\n2. Instead of writing a varint class ID (often 1-2 bytes), the fully qualified class name is written the first time an unregistered class appears in the object graph. Subsequent appearances of that class within the same object graph are written using a varint. Short package names could be considered to reduce the serialized size.\n\nIf using Kryo only for copying, registration can be safely disabled.\n\nWhen registration is not required, Kryo `setWarnUnregisteredClasses` can be enabled to log a message when an unregistered class is encountered. This can be used to easily obtain a list of all unregistered classes. Kryo `unregisteredClassMessage` can be overridden to customize the log message or take other actions.\n\n### Default serializers\n\nWhen a class is registered, a serializer instance can optionally be specified. During deserialization, the registered classes must have the exact same serializers and serializer configurations they had during serialization.\n\n```java\nKryo kryo = new Kryo();\nkryo.register(SomeClass.class, new SomeSerializer());\nkryo.register(AnotherClass.class, new AnotherSerializer());\n```\n\nIf a serializer is not specified or when an unregistered class is encountered, a serializer is chosen automatically from a list of \"default serializers\" that maps a class to a serializer. Having many default serializers doesn't affect serialization performance, so by default Kryo has [50+ default serializers](https://github.com/EsotericSoftware/kryo/blob/master/src/com/esotericsoftware/kryo/Kryo.java#L179) for various JRE classes. Additional default serializers can be added:\n\n```java\nKryo kryo = new Kryo();\nkryo.setRegistrationRequired(false);\nkryo.addDefaultSerializer(SomeClass.class, SomeSerializer.class);\n\nOutput output = ...\nSomeClass object = ...\nkryo.writeObject(output, object);\n```\n\nThis will cause a SomeSerializer instance to be created when SomeClass or any class which extends or implements SomeClass is registered.\n\nDefault serializers are sorted so more specific classes are matched first, but are otherwise matched in the order they are added. The order they are added can be relevant for interfaces.\n\nIf no default serializers match a class, then the global default serializer is used. The global default serializer is set to [FieldSerializer](#fieldserializer) by default, but can be changed. Usually the global serializer is one that can handle many different types.\n\n```java\nKryo kryo = new Kryo();\nkryo.setDefaultSerializer(TaggedFieldSerializer.class);\nkryo.register(SomeClass.class);\n```\n\nWith this code, assuming no default serializers match SomeClass, TaggedFieldSerializer will be used.\n\nA class can also use the DefaultSerializer annotation, which will be used instead of choosing one of Kryo's default serializers:\n\n```java\n@DefaultSerializer(SomeClassSerializer.class)\npublic class SomeClass {\n   // ...\n}\n```\n\nFor maximum flexibility, Kryo `getDefaultSerializer` can be overridden to implement custom logic for choosing and instantiating a serializer.\n\n#### Serializer factories\n\nThe `addDefaultSerializer(Class, Class)` method does not allow for configuration of the serializer. A serializer factory can be set instead of a serializer class, allowing the factory to create and configure each serializer instance. Factories are provided for common serializers, often with a `getConfig` method to configure the serializers that are created.\n\n```java\nKryo kryo = new Kryo();\n \nTaggedFieldSerializerFactory defaultFactory = new TaggedFieldSerializerFactory();\ndefaultFactory.getConfig().setReadUnknownTagData(true);\nkryo.setDefaultSerializer(defaultFactory);\n\nFieldSerializerFactory someClassFactory = new FieldSerializerFactory();\nsomeClassFactory.getConfig().setFieldsCanBeNull(false);\nkryo.register(SomeClass.class, someClassFactory);\n```\n\nThe serializer factory has an `isSupported(Class)` method which allows it to decline to handle a class, even if it otherwise matches the class. This allows a factory to check for multiple interfaces or implement other logic.\n\n### Object creation\n\nWhile some serializers are for a specific class, others can serialize many different classes. Serializers can use Kryo `newInstance(Class)` to create an instance of any class. This is done by looking up the registration for the class, then using the registration's ObjectInstantiator. The instantiator can be specified on the registration.\n\n```java\nRegistration registration = kryo.register(SomeClass.class);\nregistration.setInstantiator(new ObjectInstantiator<SomeClass>() {\n   public SomeClass newInstance () {\n      return new SomeClass(\"some constructor arguments\", 1234);\n   }\n});\n```\n\nIf the registration doesn't have an instantiator, one is provided by Kryo `newInstantiator`. To customize how objects are created, Kryo `newInstantiator` can be overridden or an InstantiatorStrategy provided.\n\n#### InstantiatorStrategy\n\nKryo provides DefaultInstantiatorStrategy which creates objects using ReflectASM to call a zero argument constructor. If that is not possible, it uses reflection to call a zero argument constructor. If that also fails, then it either throws an exception or tries a fallback InstantiatorStrategy. Reflection uses `setAccessible`, so a private zero argument constructor can be a good way to allow Kryo to create instances of a class without affecting the public API.\n\nDefaultInstantiatorStrategy is the recommended way of creating objects with Kryo. It runs constructors just like would be done with Java code. Alternative, extralinguistic mechanisms can also be used to create objects. The [Objenesis](http://objenesis.org/) StdInstantiatorStrategy uses JVM specific APIs to create an instance of a class without calling any constructor at all. Using this is dangerous because most classes expect their constructors to be called. Creating the object by bypassing its constructors may leave the object in an uninitialized or invalid state. Classes must be designed to be created in this way.\n\nKryo can be configured to try DefaultInstantiatorStrategy first, then fallback to StdInstantiatorStrategy if necessary.\n\n```java\nkryo.setInstantiatorStrategy(new DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));\n```\n\nAnother option is SerializingInstantiatorStrategy, which uses Java's built-in serialization mechanism to create an instance. Using this, the class must implement java.io.Serializable and the first zero argument constructor in a super class is invoked. This also bypasses constructors and so is dangerous for the same reasons as StdInstantiatorStrategy.\n\n```java\nkryo.setInstantiatorStrategy(new DefaultInstantiatorStrategy(new SerializingInstantiatorStrategy()));\n```\n\n#### Overriding create\n\nAlternatively, some generic serializers provide methods that can be overridden to customize object creation for a specific type, instead of calling Kryo `newInstance`.\n\n```java\nkryo.register(SomeClass.class, new FieldSerializer(kryo, SomeClass.class) {\n   protected T create (Kryo kryo, Input input, Class<? extends T> type) {\n      return new SomeClass(\"some constructor arguments\", 1234);\n   }\n});\n```\n\nSome serializers provide a `writeHeader` method that can be overridden to write data that is needed in `create` at the right time.\n\n```java\nstatic public class TreeMapSerializer extends MapSerializer<TreeMap> {\n   protected void writeHeader (Kryo kryo, Output output, TreeMap map) {\n      kryo.writeClassAndObject(output, map.comparator());\n   }\n\n   protected TreeMap create (Kryo kryo, Input input, Class<? extends TreeMap> type, int size) {\n      return new TreeMap((Comparator)kryo.readClassAndObject(input));\n   }\n}\n```\n\nIf a serializer doesn't provide `writeHeader`, writing data for `create` can be done in `write`.\n\n```java\nstatic public class SomeClassSerializer extends FieldSerializer<SomeClass> {\n   public SomeClassSerializer (Kryo kryo) {\n      super(kryo, SomeClass.class);\n   }\n   public void write (Kryo kryo, Output output, SomeClass object) {\n      output.writeInt(object.value);\n   }\n   protected SomeClass create (Kryo kryo, Input input, Class<? extends SomeClass> type) {\n      return new SomeClass(input.readInt());\n   }\n}\n```\n\n### Final classes\n\nEven when a serializer knows the expected class for a value (eg a field's class), if the value's concrete class is not final then the serializer needs to first write the class ID, then the value. Final classes can be serialized more efficiently because they are non-polymorphic.\n\nKryo `isFinal` is used to determine if a class is final. This method can be overridden to return true even for types which are not final. For example, if an application uses ArrayList extensively but never uses an ArrayList subclass, treating ArrayList as final could allow FieldSerializer to save 1-2 bytes per ArrayList field.\n\n### Closures\n\nKryo can serialize Java 8+ closures that implement java.io.Serializable, with some caveats. Closures serialized on one JVM may fail to be deserialized on a different JVM.\n\nKryo `isClosure` is used to determine if a class is a closure. If so, then ClosureSerializer.Closure is used to find the class registration instead of the closure's class. To serialize closures, the following classes must be registered: ClosureSerializer.Closure, Object[], and Class. Additionally, the closure's capturing class must be registered.\n\n```java\nkryo.register(Object[].class);\nkryo.register(Class.class);\nkryo.register(ClosureSerializer.Closure.class, new ClosureSerializer());\nkryo.register(CapturingClass.class);\n\nCallable<Integer> closure1 = (Callable<Integer> & java.io.Serializable)( () -> 72363 );\n\nOutput output = new Output(1024, -1);\nkryo.writeObject(output, closure1);\n\nInput input = new Input(output.getBuffer(), 0, output.position());\nCallable<Integer> closure2 = (Callable<Integer>)kryo.readObject(input, ClosureSerializer.Closure.class);\n```\n\nSerializing closures which do not implement Serializable is possible [with some effort](https://ruediste.github.io/java/kryo/2017/05/07/serializing-non-serializable-lambdas.html).\n\n### Compression and encryption\n\nKryo supports streams, so it is trivial to use compression or encryption on all of the serialized bytes:\n\n```java\nOutputStream outputStream = new DeflaterOutputStream(new FileOutputStream(\"file.bin\"));\nOutput output = new Output(outputStream);\nKryo kryo = new Kryo();\nkryo.writeObject(output, object);\noutput.close();\n```\n\nIf needed, a serializer can be used to compress or encrypt the bytes for only a subset of the bytes for an object graph. For example, see DeflateSerializer or BlowfishSerializer. These serializers wrap another serializer to encode and decode the bytes.\n\n## Implementing a serializer\n\nThe Serializer abstract class defines methods to go from objects to bytes and bytes to objects.\n\n```java\npublic class ColorSerializer extends Serializer<Color> {\n   public void write (Kryo kryo, Output output, Color color) {\n      output.writeInt(color.getRGB());\n   }\n\n   public Color read (Kryo kryo, Input input, Class<? extends Color> type) {\n      return new Color(input.readInt());\n   }\n}\n```\n\nSerializer has only two methods that must be implemented. `write` writes the object as bytes to the Output. `read` creates a new instance of the object and reads from the Input to populate it.\n\n### Serializer references\n\nWhen Kryo is used to read a nested object in Serializer `read` then Kryo `reference` must first be called with the parent object if it is possible for the nested object to reference the parent object. It is unnecessary to call Kryo `reference` if the nested objects can't possibly reference the parent object, if Kryo is not being used for nested objects, or if references are not being used. If nested objects can use the same serializer, the serializer must be reentrant.\n\n```java\npublic SomeClass read (Kryo kryo, Input input, Class<? extends SomeClass> type) {\n   SomeClass object = new SomeClass();\n   kryo.reference(object);\n   // Read objects that may reference the SomeClass instance.\n   object.someField = kryo.readClassAndObject(input);\n   return object;\n}\n```\n\n#### Nested serializers\n\nSerializers should not usually make direct use of other serializers, instead the Kryo read and write methods should be used. This allows Kryo to orchestrate serialization and handle features such as references and null objects. Sometimes a serializer knows which serializer to use for a nested object. In that case, it should use Kryo's read and write methods which accept a serializer.\n\nIf the object could be null:\n\n```java\nSerializer serializer = ...\nkryo.writeObjectOrNull(output, object, serializer);\n\nSomeClass object = kryo.readObjectOrNull(input, SomeClass.class, serializer);\n```\n\nIf the object cannot be null:\n\n```java\nSerializer serializer = ...\nkryo.writeObject(output, object, serializer);\n\nSomeClass object = kryo.readObject(input, SomeClass.class, serializer);\n```\n\nDuring serialization Kryo `getDepth` provides the current depth of the object graph.\n\n#### KryoException\n\nWhen a serialization fails, a KryoException can be thrown with serialization trace information about where in the object graph the exception occurred. When using nested serializers, KryoException can be caught to add serialization trace information.\n\n```java\nObject object = ...\nField[] fields = ...\nfor (Field field : fields) {\n   try {\n      // Use other serializers to serialize each field.\n   } catch (KryoException ex) {\n      ex.addTrace(field.getName() + \" (\" + object.getClass().getName() + \")\");\n      throw ex;\n   } catch (Throwable t) {\n      KryoException ex = new KryoException(t);\n      ex.addTrace(field.getName() + \" (\" + object.getClass().getName() + \")\");\n      throw ex;\n   }\n}\n```\n\n#### Stack size\n\nThe serializers Kryo provides use the call stack when serializing nested objects. Kryo minimizes stack calls, but a stack overflow can occur for extremely deep object graphs. This is a common issue for most serialization libraries, including the built-in Java serialization. The stack size can be increased using `-Xss`, but note that this applies to all threads. Large stack sizes in a JVM with many threads may use a large amount of memory.\n\nKryo `setMaxDepth` can be used to limit the maximum depth of an object graph. This can prevent malicious data from causing a stack overflow.\n\n### Accepting null\n\nBy default, serializers will never receive a null, instead Kryo will write a byte as needed to denote null or not null. If a serializer can be more efficient by handling nulls itself, it can call Serializer `setAcceptsNull(true)`. This can also be used to avoid writing the null denoting byte when it is known that all instances the serializer will handle will never be null.\n\n### Generics\n\nKryo `getGenerics` provides generic type information so serializers can be more efficient. This is most commonly used to avoid writing the class when the type parameter class is final.\n\nGeneric type inference is enabled by default and can be disabled with Kryo `setOptimizedGenerics(false)`. Disabling generics optimization can increase performance at the cost of a larger serialized size.\n\nIf the class has a single type parameter, `nextGenericClass` returns the type parameter class, or null if none. After reading or writing any nested objects, `popGenericType` must be called. See CollectionSerializer for an example.\n\n```java\npublic class SomeClass<T> {\n   public T value;\n}\npublic class SomeClassSerializer extends Serializer<SomeClass> {\n   public void write (Kryo kryo, Output output, SomeClass object) {\n      Class valueClass = kryo.getGenerics().nextGenericClass();\n\n      if (valueClass != null && kryo.isFinal(valueClass)) {\n         Serializer serializer = kryo.getSerializer(valueClass);\n         kryo.writeObjectOrNull(output, object.value, serializer);\n      } else\n         kryo.writeClassAndObject(output, object.value);\n\n      kryo.getGenerics().popGenericType();\n   }\n\n   public SomeClass read (Kryo kryo, Input input, Class<? extends SomeClass> type) {\n      Class valueClass = kryo.getGenerics().nextGenericClass();\n\n      SomeClass object = new SomeClass();\n      kryo.reference(object);\n\n      if (valueClass != null && kryo.isFinal(valueClass)) {\n         Serializer serializer = kryo.getSerializer(valueClass);\n         object.value = kryo.readObjectOrNull(input, valueClass, serializer);\n      } else\n         object.value = kryo.readClassAndObject(input);\n\n      kryo.getGenerics().popGenericType();\n      return object;\n   }\n}\n```\n\nFor a class with multiple type parameters, `nextGenericTypes` returns an array of GenericType instances and `resolve` is used to obtain the class for each GenericType. After reading or writing any nested objects, `popGenericType` must be called. See MapSerializer for an example.\n\n```java\npublic class SomeClass<K, V> {\n   public K key;\n   public V value;\n}\npublic class SomeClassSerializer extends Serializer<SomeClass> {\n   public void write (Kryo kryo, Output output, SomeClass object) {\n      Class keyClass = null, valueClass = null;\n      GenericType[] genericTypes = kryo.getGenerics().nextGenericTypes();\n      if (genericTypes != null) {\n         keyClass = genericTypes[0].resolve(kryo.getGenerics());\n         valueClass = genericTypes[1].resolve(kryo.getGenerics());\n      }\n\n      if (keyClass != null && kryo.isFinal(keyClass)) {\n         Serializer serializer = kryo.getSerializer(keyClass);\n         kryo.writeObjectOrNull(output, object.key, serializer);\n      } else\n         kryo.writeClassAndObject(output, object.key);\n\n      if (valueClass != null && kryo.isFinal(valueClass)) {\n         Serializer serializer = kryo.getSerializer(valueClass);\n         kryo.writeObjectOrNull(output, object.value, serializer);\n      } else\n         kryo.writeClassAndObject(output, object.value);\n\n      kryo.getGenerics().popGenericType();\n   }\n\n   public SomeClass read (Kryo kryo, Input input, Class<? extends SomeClass> type) {\n      Class keyClass = null, valueClass = null;\n      GenericType[] genericTypes = kryo.getGenerics().nextGenericTypes();\n      if (genericTypes != null) {\n         keyClass = genericTypes[0].resolve(kryo.getGenerics());\n         valueClass = genericTypes[1].resolve(kryo.getGenerics());\n      }\n\n      SomeClass object = new SomeClass();\n      kryo.reference(object);\n\n      if (keyClass != null && kryo.isFinal(keyClass)) {\n         Serializer serializer = kryo.getSerializer(keyClass);\n         object.key = kryo.readObjectOrNull(input, keyClass, serializer);\n      } else\n         object.key = kryo.readClassAndObject(input);\n\n      if (valueClass != null && kryo.isFinal(valueClass)) {\n         Serializer serializer = kryo.getSerializer(valueClass);\n         object.value = kryo.readObjectOrNull(input, valueClass, serializer);\n      } else\n         object.value = kryo.readClassAndObject(input);\n\n      kryo.getGenerics().popGenericType();\n      return object;\n   }\n}\n```\n\nFor serializers which pass type parameter information for nested objects in the object graph (somewhat advanced usage), first GenericsHierarchy is used to store the type parameters for a class. During serialization, Generics `pushTypeVariables` is called before generic types are resolved (if any). If >0 is returned, this must be followed by Generics `popTypeVariables`. See FieldSerializer for an example.\n\n```java\npublic class SomeClass<T> {\n   T value;\n   List<T> list;\n}\npublic class SomeClassSerializer extends Serializer<SomeClass> {\n   private final GenericsHierarchy genericsHierarchy;\n\n   public SomeClassSerializer () {\n      genericsHierarchy = new GenericsHierarchy(SomeClass.class);\n   }\n\n   public void write (Kryo kryo, Output output, SomeClass object) {\n      Class valueClass = null;\n      Generics generics = kryo.getGenerics();\n      int pop = 0;\n      GenericType[] genericTypes = generics.nextGenericTypes();\n      if (genericTypes != null) {\n         pop = generics.pushTypeVariables(genericsHierarchy, genericTypes);\n         valueClass = genericTypes[0].resolve(generics);\n      }\n\n      if (valueClass != null && kryo.isFinal(valueClass)) {\n         Serializer serializer = kryo.getSerializer(valueClass);\n         kryo.writeObjectOrNull(output, object.value, serializer);\n      } else\n         kryo.writeClassAndObject(output, object.value);\n\n      kryo.writeClassAndObject(output, object.list);\n\n      if (pop > 0) generics.popTypeVariables(pop);\n      generics.popGenericType();\n   }\n\n   public SomeClass read (Kryo kryo, Input input, Class<? extends SomeClass> type) {\n      Class valueClass = null;\n      Generics generics = kryo.getGenerics();\n      int pop = 0;\n      GenericType[] genericTypes = generics.nextGenericTypes();\n      if (genericTypes != null) {\n         pop = generics.pushTypeVariables(genericsHierarchy, genericTypes);\n         valueClass = genericTypes[0].resolve(generics);\n      }\n\n      SomeClass object = new SomeClass();\n      kryo.reference(object);\n\n      if (valueClass != null && kryo.isFinal(valueClass)) {\n         Serializer serializer = kryo.getSerializer(valueClass);\n         object.value = kryo.readObjectOrNull(input, valueClass, serializer);\n      } else\n         object.value = kryo.readClassAndObject(input);\n\n      object.list = (List)kryo.readClassAndObject(input);\n\n      if (pop > 0) generics.popTypeVariables(pop);\n      generics.popGenericType();\n      return object;\n   }\n}\n```\n\n### KryoSerializable\n\nInstead of using a serializer, a class can choose to do its own serialization by implementing KryoSerializable (similar to java.io.Externalizable).\n\n```java\npublic class SomeClass implements KryoSerializable {\n   private int value;\n   public void write (Kryo kryo, Output output) {\n      output.writeInt(value, false);\n   }\n   public void read (Kryo kryo, Input input) {\n      value = input.readInt(false);\n   }\n}\n```\n\nObviously the instance must already be created before `read` can be called, so the class isn't able to control its own creation. A KryoSerializable class will use the default serializer KryoSerializableSerializer, which uses Kryo `newInstance` to create a new instance. It is trivial to write your own serializer to customize the process, call methods before or after serialiation, etc.\n\n### Serializer copying\n\nSerializers only support copying if `copy` is overridden. Similar to Serializer `read`, this method contains the logic to create and configure the copy. Just like `read`, Kryo `reference` must be called before Kryo is used to copy child objects, if any of the child objects could reference the parent object.\n\n```java\nclass SomeClassSerializer extends Serializer<SomeClass> {\n   public SomeClass copy (Kryo kryo, SomeClass original) {\n      SomeClass copy = new SomeClass();\n      kryo.reference(copy);\n      copy.intValue = original.intValue;\n      copy.object = kryo.copy(original.object);\n      return copy;\n   }\n}\n```\n\n#### KryoCopyable\n\nInstead of using a serializer, classes can implement KryoCopyable to do their own copying:\n\n```java\npublic class SomeClass implements KryoCopyable<SomeClass> {\n   public SomeClass copy (Kryo kryo) {\n      SomeClass copy = new SomeClass();\n      kryo.reference(copy);\n      copy.intValue = intValue;\n      copy.object = kryo.copy(object);\n      return copy;\n   }\n}\n```\n\n#### Immutable serializers\n\nSerializer `setImmutable(true)` can be used when the type is immutable. In that case, Serializer `copy` does not need to be implemented -- the default `copy` implementation will return the original object.\n\n## Kryo versioning and upgrading\n\nThe following rules of thumb are applied to Kryo's version numbering:\n\n1. The major version is increased if serialization compatibility is broken. This means data serialized with a previous version may not be deserialized with the new version.\n2. The minor version is increased if binary or source compatibility of the documented public API is broken. To avoid increasing the version when very few users are affected, some minor breakage is allowed if it occurs in public classes that are seldom used or not intended for general usage.\n\nUpgrading any dependency is a significant event, but a serialization library is more prone to breakage than most dependencies. When upgrading Kryo check the version differences and test the new version thoroughly in your own applications. We try to make it as safe and easy as possible.\n\n* At development time serialization compatibility is tested for the different binary formats and default serializers.\n* At development time binary and source compatibility is tracked with [clirr](http://www.mojohaus.org/clirr-maven-plugin/).\n* For each release a [changelog](https://github.com/EsotericSoftware/kryo/releases) is provided that also contains a section reporting the serialization, binary, and source compatibilities.\n* For reporting binary and source compatibility [japi-compliance-checker](https://github.com/lvc/japi-compliance-checker/) is used.\n\n## Interoperability\n\nThe Kryo serializers provided by default assume that Java will be used for deserialization, so they do not explicitly define the format that is written. Serializers could be written using a standardized format that is more easily read by other languages, but this is not provided by default.\n\n## Compatibility\n\nFor some needs, such as long term storage of serialized bytes, it can be important how serialization handles changes to classes. This is known as forward compatibility (reading bytes serialized by newer classes) and backward compatibility (reading bytes serialized by older classes). Kryo provides a few generic serializers which take different approaches to handling compatibility. Additional serializers can easily be developed for forward and backward compatibility, such as a serializer that uses an external, hand written schema.\n\n### Replacing a class\n\nWhen a class changes more than its serializer can handle, a serializer can be written to transfer the data to a different class. All use of the old class in application code should be replaced by the new class. The old class is kept solely for this serializer.\n\n```java\nkryo.register(OldClass.class, new TaggedFieldSerializer(kryo, OldClass.class) {\n\tpublic Object read (Kryo kryo, Input input, Class type) {\n\t\tOldClass oldObject = (OldClass)super.read(kryo, input, OldClass.class);\n\t\tNewClass newObject = new NewClass();\n\t\t// Use data from the old class to populate the instance of the new class and return it.\n\t\treturn newObject;\n\t}\n});\nkryo.register(NewClass.class);\n```\n\n## Serializers\n\nKryo provides many serializers with various configuration options and levels of compatibility. Additional serializers can be found in the [kryo-serializers](https://github.com/magro/kryo-serializers) sister project, which hosts serializers that access private APIs or are otherwise not perfectly safe on all JVMs. More serializers can be found in the [links section](#links).\n\n### FieldSerializer\n\nFieldSerializer works by serializing each non-transient field. It can serialize POJOs and many other classes without any configuration. All non-public fields are written and read by default, so it is important to evaluate each class that will be serialized. If fields are public, serialization may be faster.\n\nFieldSerializer is efficient by writing only the field data, without any schema information, using the Java class files as the schema. It does not support adding, removing, or changing the type of fields without invalidating previously serialized bytes. Renaming fields is allowed only if it doesn't change the alphabetical order of the fields.\n\nFieldSerializer's compatibility drawbacks can be acceptable in many situations, such as when sending data over a network, but may not be a good choice for long term data storage because the Java classes cannot evolve. In many cases [TaggedFieldSerializer](#taggedfieldserializer) is a better choice.\n\n#### FieldSerializer settings\n\nSetting | Description | Default value\n--- | --- | ---\n`fieldsCanBeNull` | When false it is assumed that no field values are null, which can save 0-1 byte per field. | true\n`setFieldsAsAccessible` | When true, all non-transient fields (including private fields) will be serialized and `setAccessible` if necessary. If false, only fields in the public API will be serialized. | true\n`ignoreSyntheticFields` | If true, synthetic fields (generated by the compiler for scoping) are serialized. | false\n`fixedFieldTypes` | If true, it is assumed every field value's concrete type matches the field's type. This removes the need to write the class ID for field values. | false\n`copyTransient` | If true, all transient fields will be copied. | true\n`serializeTransient` | If true, transient fields will be serialized. | false\n`variableLengthEncoding` | If true, variable length values are used for int and long fields. | true\n`extendedFieldNames` | If true, field names are prefixed by their declaring class. This can avoid conflicts when a subclass has a field with the same name as a super class. | false\n\n#### CachedField settings\n\nFieldSerializer provides the fields that will be serialized. Fields can be removed, so they won't be serialized. Fields can be configured to make serialiation more efficient.\n\n```java\nFieldSerializer fieldSerializer = ...\n\nfieldSerializer.removeField(\"id\"); // Won't be serialized.\n\nCachedField nameField = fieldSerializer.getField(\"name\");\nnameField.setCanBeNull(false);\n\nCachedField someClassField = fieldSerializer.getField(\"someClass\");\nsomeClassField.setClass(SomeClass.class, new SomeClassSerializer());\n```\n\nSetting | Description | Default value\n--- | --- | ---\n`canBeNull` | When false it is assumed the field value is never null, which can save 0-1 byte. | true\n`valueClass` | Sets the concrete class and serializer to use for the field value. This removes the need to write the class ID for the value. If the field value's class is a primitive, primitive wrapper, or final, this setting defaults to the field's class. | null\n`serializer` | Sets the serializer to use for the field value. If the serializer is set, some serializers required the value class to also be set. If null, the serializer registered with Kryo for the field value's class will be used. | null\n`variableLengthEncoding` | If true, variable length values are used. This only applies to int or long fields. | true\n`optimizePositive` | If true, positive values are optimized for variable length values. This only applies to int or long fields when variable length encoding is used. | true\n\n#### FieldSerializer annotations\n\nAnnotations can be used to configure the serializers for each field.\n\nAnnotation | Description\n--- | ---\n`@Bind` | Sets the CachedField settings for any field.\n`@CollectionBind` | Sets the CollectionSerializer settings for Collection fields.\n`@MapBind` | Sets the MapSerializer settings for Map fields.\n`@NotNull` | Marks a field as never being null.\n\n```java\npublic class SomeClass {\n   @NotNull\n   @Bind(serializer = StringSerializer.class, valueClass = String.class, canBeNull = false) \n   Object stringField;\n\n   @Bind(variableLengthEncoding = false)\n   int intField;\n\n   @BindMap(\n      keySerializer = StringSerializer.class, \n      valueSerializer = IntArraySerializer.class, \n      keyClass = String.class, \n      valueClass = int[].class, \n      keysCanBeNull = false)\n   Map map;\n   \n   @BindCollection(\n      elementSerializer = LongArraySerializer.class,\n      elementClass = long[].class, \n      elementsCanBeNull = false) \n   Collection collection;\n}\n```\n\n### VersionFieldSerializer\n\nVersionFieldSerializer extends FieldSerializer and provides backward compatibility. This means fields can be added without invalidating previously serialized bytes. Removing, renaming, or changing the type of a field is not supported.\n\nWhen a field is added, it must have the `@Since(int)` annotation to indicate the version it was added in order to be compatible with previously serialized bytes. The annotation value must never change.\n\nVersionFieldSerializer adds very little overhead to FieldSerializer: a single additional varint.\n\n#### VersionFieldSerializer settings\n\nSetting | Description | Default value\n--- | --- | ---\n`compatible` | When false, an exception is thrown when reading an object with a different version. The version of an object is the maximum version of any field. | true\n\nVersionFieldSerializer also inherits all the settings of FieldSerializer.\n\n### TaggedFieldSerializer\n\nTaggedFieldSerializer extends FieldSerializer to provide backward compatibility and optional forward compatibility. This means fields can be added or renamed and optionally removed without invalidating previously serialized bytes. Changing the type of a field is not supported.\n\nOnly fields that have a <code>@Tag(int)</code> annotation are serialized. Field tag values must be unique, both within a class and all its super classes. An exception is thrown if duplicate tag values are encountered.\n\nThe forward and backward compatibility and serialization [performance](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/fieldSerializer.png) depends on the `readUnknownTagData` and `chunkedEncoding` settings. Additionally, a varint is written before each field for the tag value.\n\nWhen `readUnknownTagData` and `chunkedEncoding` are false, fields must not be removed but the `@Deprecated` annotation can be applied. Deprecated fields are read when reading old bytes but aren't written to new bytes. Classes can evolve by reading the values of deprecated fields and writing them elsewhere. Fields can be renamed and/or made private to reduce clutter in the class (eg, `ignored1`, `ignored2`).\n\nTaggedFieldSerializer (with `readUnknownTagData` and `chunkedEncoding` false) is the suggested serializer for most classes where fields can be annotated. It allows classes to evolve and fields to be removed from the serialized data (via deprecation), meeting the needs of most applications without adding much to the serialized size.\n\n#### TaggedFieldSerializer settings\n\nSetting | Description | Default value\n--- | --- | ---\n`readUnknownTagData` | When false and an unknown tag is encountered, an exception is thrown or, if `chunkedEncoding` is true, the data is skipped.<br><br>When true, the class for each field value is written before the value. When an unknown tag is encountered, an attempt to read the data is made. This is used to skip the data and, if references are enabled, any other values in the object graph referencing that data can still be deserialized. If reading the data fails (eg the class is unknown or has been removed) then an exception is thrown or, if `chunkedEncoding` is true, the data is skipped.<br><br>In either case, if the data is skipped and references are enabled, then any references in the skipped data are not read and further deserialization may receive the wrong references and fail. | false\n`chunkedEncoding` | When true, fields are written with chunked encoding to allow unknown field data to be skipped. This impacts performance. | false\n`chunkSize` | The maximum size of each chunk for chunked encoding. | 1024\n\nTaggedFieldSerializer also inherits all the settings of FieldSerializer.\n\n### CompatibleFieldSerializer\n\nCompatibleFieldSerializer extends FieldSerializer to provided both forward and backward compatibility. This means fields can be added or removed without invalidating previously serialized bytes. Renaming or changing the type of a field is not supported. Like FieldSerializer, it can serialize most classes without needing annotations.\n\nThe forward and backward compatibility and serialization [performance](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/fieldSerializer.png) depends on the `readUnknownFieldData` and `chunkedEncoding` settings. Additionally, the first time the class is encountered in the serialized bytes, a simple schema is written containing the field name strings. Because field data is identified by name, if a super class has a field with the same name as a subclass, `extendedFieldNames` must be true.\n\n#### CompatibleFieldSerializer settings\n\nSetting | Description | Default value\n--- | --- | ---\n`readUnknownFieldData` | When false and an unknown field is encountered, an exception is thrown or, if `chunkedEncoding` is true, the data is skipped.<br><br>When true, the class for each field value is written before the value. When an unknown field is encountered, an attempt to read the data is made. This is used to skip the data and, if references are enabled, any other values in the object graph referencing that data can still be deserialized. If reading the data fails (eg the class is unknown or has been removed) then an exception is thrown or, if `chunkedEncoding` is true, the data is skipped.<br><br>In either case, if the data is skipped and references are enabled, then any references in the skipped data are not read and further deserialization may receive the wrong references and fail. | true\n`chunkedEncoding` | When true, fields are written with chunked encoding to allow unknown field data to be skipped. This impacts performance. | false\n`chunkSize` | The maximum size of each chunk for chunked encoding. | 1024\n\nCompatibleFieldSerializer also inherits all the settings of FieldSerializer.\n\n### BeanSerializer\n\nBeanSerializer is very similar to FieldSerializer, except it uses bean getter and setter methods rather than direct field access. This slightly slower, but may be safer because it uses the public API to configure the object. Like FieldSerializer, it provides no forward or backward compatibility.\n\n### CollectionSerializer\n\nCollectionSerializer serializes objects that implement the java.util.Collection interface.\n\n#### CollectionSerializer settings\n\nSetting | Description | Default value\n--- | --- | ---\n`elementsCanBeNull` | When false it is assumed that no elements in the collection are null, which can save 0-1 byte per element. | true\n`elementClass` | Sets the concrete class to use for each element in the collection. This removes the need to write the class ID for each element. If the element class is known (eg through generics) and a primitive, primitive wrapper, or final, then CollectionSerializer won't write the class ID even when this setting is null. | null\n`elementSerializer` | Sets the serializer to use for every element in the collection. If the serializer is set, some serializers required the value class to also be set. If null, the serializer registered with Kryo for each element's class will be used. | null\n\n### MapSerializer\n\nMapSerializer serializes objects that implement the java.util.Map interface.\n\n#### MapSerializer settings\n\nSetting | Description | Default value\n--- | --- | ---\n`keysCanBeNull` | When false it is assumed that no keys in the map are null, which can save 0-1 byte per entry. | true\n`valuesCanBeNull` | When false it is assumed that no values in the map are null, which can save 0-1 byte per entry. | true\n`keyClass` | Sets the concrete class to use for every key in the map. This removes the need to write the class ID for each key. | null\n`valueClass` | Sets the concrete class to use for every value in the map. This removes the need to write the class ID for each value. | null\n`keySerializer` | Sets the serializer to use for every key in the map. If the value serializer is set, some serializers required the value class to also be set. If null, the serializer registered with Kryo for each key's class will be used. | null\n`valueSerializer` | Sets the serializer to use for every value in the map. If the key serializer is set, some serializers required the value class to also be set. If null, the serializer registered with Kryo for each value's class will be used. | null\n\n### JavaSerializer and ExternalizableSerializer\n\nJavaSerializer and ExternalizableSerializer are Kryo serializers which uses Java's built-in serialization. This is as slow as usual Java serialization, but may be necessary for legacy classes. \n\njava.io.Externalizable and java.io.Serializable do not have default serializers set by default, so the default serializers must be set manually or the serializers set when the class is registered.\n\n```java\nclass SomeClass implements Externalizable { /* ... */ }\nkryo.addDefaultSerializer(Externalizable.class, ExternalizableSerializer.class);\nkryo.register(SomeClass.class);\n```\n\n```java\nkryo.register(SomeClass.class, new JavaSerializer());\n```\n\n```java\nkryo.register(SomeClass.class, new ExternalizableSerializer());\n```\n\n## Logging\n\nKryo makes use of the low overhead, lightweight [MinLog logging library](https://github.com/EsotericSoftware/minlog). The logging level can be set by one of the following methods:\n\n```java\nLog.ERROR();\nLog.WARN();\nLog.INFO();\nLog.DEBUG();\nLog.TRACE();\n```\n\nKryo does no logging at `INFO` (the default) and above levels. `DEBUG` is convenient to use during development. `TRACE` is good to use when debugging a specific problem, but generally outputs too much information to leave on.\n\nMinLog supports a fixed logging level, which causes the Java compiler to remove logging statements below that level at compile time. Kryo must be compiled with a fixed logging level MinLog JAR.\n\n## Thread safety\n\nKryo is not thread safe. Each thread should have its own Kryo, Input, and Output instances.\n\n### Pooling\n\nBecause Kryo is not thread safe and constructing and configuring a Kryo instance is relatively expensive, in a multithreaded environment ThreadLocal or pooling might be considered.\n\n```java\nstatic private final ThreadLocal<Kryo> kryos = new ThreadLocal<Kryo>() {\n   protected Kryo initialValue() {\n      Kryo kryo = new Kryo();\n      // Configure the Kryo instance.\n      return kryo;\n   };\n};\n\nKryo kryo = kryos.get();\n```\n\nFor pooling, Kryo provides the Pool class which can pool Kryo, Input, Output, or instances of any other class.\n\n```java\n// Pool constructor arguments: thread safe, soft references, maximum capacity\nPool<Kryo> kryoPool = new Pool<Kryo>(true, false, 8) {\n   protected Kryo create () {\n      Kryo kryo = new Kryo();\n      // Configure the Kryo instance.\n      return kryo;\n   }\n};\n\nKryo kryo = kryoPool.obtain();\n// Use the Kryo instance here.\nkryoPool.free(kryo);\n```\n\n```java\nPool<Output> outputPool = new Pool<Output>(true, false, 16) {\n   protected Output create () {\n      return new Output(1024, -1);\n   }\n};\n\nOutput output = outputPool.obtain();\n// Use the Output instance here.\noutputPool.free(output);\n```\n\n```java\nPool<Input> inputPool = new Pool<Input>(true, false, 16) {\n   protected Input create () {\n      return new Input(1024);\n   }\n};\n\nInput input = inputPool.obtain();\n// Use the Input instance here.\ninputPool.free(input);\n```\n\nIf `true` is passed as the first argument to the Pool constructor, the Pool uses synchronization internally and can be accessed by multiple threads concurrently.\n\nIf `true` is passed as the second argument to the Pool constructor, the Pool stores objects using java.lang.ref.SoftReference. This allows objects in the pool to be garbage collected when memory pressure on the JVM is high. Pool `clean` removes all soft references whose object has been garbage collected. This can reduce the size of the pool when no maximum capacity has been set. When the pool has a maximum capacity, it is not necessary to call `clean` because Pool `free` will try to remove an empty reference if the maximum capacity has been reached.\n\nThe third Pool parameter is the maximum capacity. If an object is freed and the pool already contains the maximum number of free objects, the specified object is reset but not added to the pool. The maximum capacity may be omitted for no limit.\n\nIf an object implements Pool.Poolable then Poolable `reset` is called when the object is freed. This gives the object a chance to reset its state for reuse in the future. Alternatively, Pool `reset` can be overridden to reset objects. Input and Output implement Poolable to set their `position` and `total` to 0.\nKryo does not implement Poolable because its object graph state is typically reset automatically after each serialization (see [Reset](#reset)). If you disable automatic reset via `setAutoReset(false)`, make sure that you call `Kryo.reset()` before returning the instance to the pool.\n\nPool `getFree` returns the number of objects available to be obtained. If using soft references, this number may include objects that have been garbage collected. `clean` may be used first to remove empty soft references.\n\nPool `getPeak` returns the all-time highest number of free objects. This can help determine if a pool's maximum capacity is set appropriately. It can be reset any time with `resetPeak`.\n\n## Benchmarks\n\nKryo provides a number of [JMH](http://openjdk.java.net/projects/code-tools/jmh/)-based [benchmarks and R/ggplot2 files](https://github.com/EsotericSoftware/kryo/tree/master/benchmarks).\n\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/fieldSerializer.png)\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/string.png)\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/variableEncoding.png)\n![](https://raw.github.com/wiki/EsotericSoftware/kryo/images/benchmarks/array.png)\n\nKryo can be compared to many other serialization libraries in the [JVM Serializers](https://github.com/eishay/jvm-serializers/wiki) project. The benchmarks are small, dated, and homegrown rather than using JMH, so are less trustworthy. Also, it is very difficult to thoroughly compare serialization libraries using a benchmark. Libraries have many different features and often have different goals, so they may excel at solving completely different problems. To understand these benchmarks, the code being run and data being serialized should be analyzed and contrasted with your specific needs. Some serializers are highly optimized and use pages of code, others use only a few lines. This is good to show what is possible, but may not be a relevant comparison for many situations.\n\n## Links\n\n### Projects using Kryo\n\nThere are a number of projects using Kryo. A few are listed below. Please submit a pull request if you'd like your project included here.\n\n- [KryoNet](http://code.google.com/p/kryonet/) (NIO networking)\n- [kryo-serializers](https://github.com/magro/kryo-serializers) (additional serializers)\n- [Twitter's Scalding](https://github.com/twitter/scalding) (Scala API for Cascading)\n- [Twitter's Chill](https://github.com/twitter/chill) (Kryo serializers for Scala)\n- [Apache Fluo](https://fluo.apache.org) (Kryo is default serialization for Fluo Recipes)\n- [Apache Hive](http://hive.apache.org/) (query plan serialization)\n- [Apache Spark](http://spark.apache.org/) (shuffled/cached data serialization)\n- [DataNucleus](https://github.com/datanucleus/type-converter-kryo) (JDO/JPA persistence framework)\n- [CloudPelican](http://www.cloudpelican.com/)\n- [Yahoo's S4](http://www.s4.io/) (distributed stream computing)\n- [Storm](https://github.com/nathanmarz/storm/wiki/Serialization) (distributed realtime computation system, in turn used by [many others](https://github.com/nathanmarz/storm/wiki/Powered-By))\n- [Cascalog](https://github.com/nathanmarz/cascalog) (Clojure/Java data processing and querying [details](https://groups.google.com/d/msg/cascalog-user/qgwO2vbkRa0/UeClnLL5OsgJ))\n- [memcached-session-manager](https://code.google.com/p/memcached-session-manager/) (Tomcat high-availability sessions)\n- [Mobility-RPC](http://code.google.com/p/mobility-rpc/) (RPC enabling distributed applications)\n- [akka-kryo-serialization](https://github.com/altoo-ag/akka-kryo-serialization) (Kryo serializers for Akka)\n- [Groupon](https://code.google.com/p/kryo/issues/detail?id=67)\n- [Jive](http://www.jivesoftware.com/jivespace/blogs/jivespace/2010/07/29/the-jive-sbs-cache-redesign-part-3)\n- [DestroyAllHumans](https://code.google.com/p/destroyallhumans/) (controls a [robot](http://www.youtube.com/watch?v=ZeZ3R38d3Cg)!)\n- [Mybatis Redis-Cache](https://github.com/mybatis/redis-cache) (MyBatis Redis Cache adapter)\n- [Apache Dubbo](https://github.com/apache/incubator-dubbo) (high performance, open source RPC framework)\n- [Spring Statemachine](https://spring.io/projects/spring-statemachine) (State machine concepts with Spring)\n- [session-compatible-fast-serializer](https://github.com/alibaba/session-compatible-fast-serializer) (A compatible field serializer with better performance)\n\n### Scala\n\n- [Twitter's Chill](https://github.com/twitter/chill) (Kryo serializers for Scala)\n- [akka-kryo-serialization](https://github.com/altoo-ag/akka-kryo-serialization) (Kryo serializers for Scala and Akka)\n- [Twitter's Scalding](https://github.com/twitter/scalding) (Scala API for Cascading)\n- [Kryo Serializers](https://github.com/magro/kryo-serializers) (Additional serializers for Java)\n- [Kryo Macros](https://github.com/evolution-gaming/kryo-macros) (Scala macros for compile-time generation of Kryo serializers)\n\n### Clojure\n\n- [Carbonite](https://github.com/sritchie/carbonite) (Kryo serializers for Clojure)\n\n### Objective-C\n\n- [kryococoa](https://github.com/Feuerwerk/kryococoa) (Objective-C port of Kryo)\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "compat_reports",
          "type": "tree",
          "content": null
        },
        {
          "name": "eclipse",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main-versioned",
          "type": "tree",
          "content": null
        },
        {
          "name": "main",
          "type": "tree",
          "content": null
        },
        {
          "name": "pom.xml",
          "type": "blob",
          "size": 15.244140625,
          "content": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\n\t<groupId>com.esotericsoftware</groupId>\n\t<artifactId>kryo-parent</artifactId>\n\t<version>5.6.3-SNAPSHOT</version>\n\t<packaging>pom</packaging>\n\n\t<name>Kryo Parent</name>\n\t<description>Fast, efficient Java serialization. This is the parent POM that defines common settings and lists the modules.</description>\n\t<url>https://github.com/EsotericSoftware/kryo</url>\n\n\t<licenses>\n\t\t<license>\n\t\t\t<name>3-Clause BSD License</name>\n\t\t\t<url>https://opensource.org/licenses/BSD-3-Clause</url>\n\t\t\t<distribution>repo</distribution>\n\t\t</license>\n\t</licenses>\n\n\t<scm>\n\t\t<url>https://github.com/EsotericSoftware/kryo</url>\n\t\t<connection>scm:git:git@github.com:EsotericSoftware/kryo.git</connection>\n\t\t<developerConnection>scm:git:git@github.com:EsotericSoftware/kryo.git</developerConnection>\n\t\t<tag>HEAD</tag>\n\t</scm>\n\n\t<distributionManagement>\n\t\t<snapshotRepository>\n\t\t\t<id>sonatype-nexus-snapshots</id>\n\t\t\t<name>Sonatype Nexus Snapshots</name>\n\t\t\t<url>https://oss.sonatype.org/content/repositories/snapshots/</url>\n\t\t</snapshotRepository>\n\t\t<repository>\n\t\t\t<id>sonatype-nexus-staging</id>\n\t\t\t<name>Sonatype Nexus Releases</name>\n\t\t\t<url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n\t\t</repository>\n\t</distributionManagement>\n\n\t<developers>\n\t\t<developer>\n\t\t\t<id>nathan.sweet</id>\n\t\t\t<name>Nathan Sweet</name>\n\t\t\t<email>admin@esotericsoftware.com</email>\n\t\t</developer>\n\t</developers>\n\n\t<properties>\n\t\t<kryo.root>${basedir}</kryo.root>\n\t\t<kryo.major.version>5</kryo.major.version>\n\t\t<javac.target>1.8</javac.target>\n\t\t<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n\t\t<junit.version>5.11.4</junit.version>\n\t\t<kotlin.version>1.9.24</kotlin.version>\n\t\t<kotlin.compiler.incremental>true</kotlin.compiler.incremental>\n\t</properties>\n\n\t<modules>\n\t\t<module>main</module>\n\t\t<module>main-versioned</module>\n\t\t<module>benchmarks</module>\n\t</modules>\n\n\t<dependencies>\n\t\t<!-- Tests. -->\n\t\t<dependency>\n\t\t\t<groupId>org.junit.jupiter</groupId>\n\t\t\t<artifactId>junit-jupiter-api</artifactId>\n\t\t\t<version>${junit.version}</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.junit.jupiter</groupId>\n\t\t\t<artifactId>junit-jupiter-engine</artifactId>\n\t\t\t<version>${junit.version}</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.junit.jupiter</groupId>\n\t\t\t<artifactId>junit-jupiter-params</artifactId>\n\t\t\t<version>${junit.version}</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-lang3</artifactId>\n\t\t\t<version>3.17.0</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<sourceDirectory>src</sourceDirectory>\n\t\t<testSourceDirectory>test</testSourceDirectory>\n\n\t\t<pluginManagement>\n\t\t\t<plugins>\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t\t\t\t<artifactId>build-helper-maven-plugin</artifactId>\n\t\t\t\t\t<version>3.6.0</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-clean-plugin</artifactId>\n\t\t\t\t\t<version>3.4.0</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t\t\t<version>3.13.0</version>\n\t\t\t\t\t<configuration>\n\t\t\t\t\t\t<source>${javac.target}</source>\n\t\t\t\t\t\t<target>${javac.target}</target>\n\t\t\t\t\t\t<encoding>utf-8</encoding>\n\t\t\t\t\t</configuration>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-install-plugin</artifactId>\n\t\t\t\t\t<version>3.1.3</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-deploy-plugin</artifactId>\n\t\t\t\t\t<version>3.1.3</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-jar-plugin</artifactId>\n\t\t\t\t\t<version>3.4.2</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-site-plugin</artifactId>\n\t\t\t\t\t<version>3.21.0</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n\t\t\t\t\t<version>3.5.2</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<artifactId>maven-resources-plugin</artifactId>\n\t\t\t\t\t<version>3.3.1</version>\n\t\t\t\t\t<executions>\n\t\t\t\t\t\t<!-- Disable resources (project has none). -->\n\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t<id>default-resources</id>\n\t\t\t\t\t\t\t<phase>none</phase>\n\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t<id>default-testResources</id>\n\t\t\t\t\t\t\t<phase>none</phase>\n\t\t\t\t\t\t</execution>\n\t\t\t\t\t</executions>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-javadoc-plugin</artifactId>\n\t\t\t\t\t<version>3.11.2</version>\n\t\t\t\t\t<configuration>\n\t\t\t\t\t\t<!-- Required for java8, so that javadoc errors don't fail the build. -->\n\t\t\t\t\t\t<doclint>none</doclint>\n\t\t\t\t\t\t<!-- Required for build with java11, to prevent \"error: package sun.nio.ch is not visible\" failing javadoc -->\n\t\t\t\t\t\t<source>8</source>\n\t\t\t\t\t</configuration>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t\t\t\t<artifactId>findbugs-maven-plugin</artifactId>\n\t\t\t\t\t<version>3.0.5</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-release-plugin</artifactId>\n\t\t\t\t\t<version>3.1.1</version>\n\t\t\t\t\t<configuration>\n\t\t\t\t\t\t<autoVersionSubmodules>true</autoVersionSubmodules>\n\t\t\t\t\t\t<useReleaseProfile>false</useReleaseProfile>\n\t\t\t\t\t\t<releaseProfiles>release</releaseProfiles>\n\t\t\t\t\t\t<arguments>-Prelease</arguments>\n\t\t\t\t\t\t<goals>deploy</goals>\n\t\t\t\t\t\t<!-- Don't run clean, because this would delete the kryo artifact, which would fail the shade plugin\n\t\t\t\t\t\t\tbecause the kryo jar would no longer exist.\n\t\t\t\t\t\t\thttps://maven.apache.org/maven-release/maven-release-plugin/prepare-mojo.html#preparationGoals\n\t\t\t\t\t\t-->\n\t\t\t\t\t\t<preparationGoals>verify</preparationGoals>\n\t\t\t\t\t</configuration>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.felix</groupId>\n\t\t\t\t\t<artifactId>maven-bundle-plugin</artifactId>\n\t\t\t\t\t<version>5.1.9</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-shade-plugin</artifactId>\n\t\t\t\t\t<version>3.6.0</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t<artifactId>maven-enforcer-plugin</artifactId>\n\t\t\t\t\t<version>3.5.0</version>\n\t\t\t\t</plugin>\n\n\t\t\t\t<plugin>\n\t\t\t\t\t<groupId>net.revelc.code.formatter</groupId>\n\t\t\t\t\t<artifactId>formatter-maven-plugin</artifactId>\n\t\t\t\t\t<version>2.24.1</version>\n\t\t\t\t\t<configuration>\n\t\t\t\t\t\t<configFile>${kryo.root}/eclipse/code-format.xml</configFile>\n\t\t\t\t\t\t<lineEnding>KEEP</lineEnding>\n\t\t\t\t\t\t<compilerSource>${javac.target}</compilerSource>\n\t\t\t\t\t\t<compilerCompliance>${javac.target}</compilerCompliance>\n\t\t\t\t\t\t<compilerTargetPlatform>${javac.target}</compilerTargetPlatform>\n\t\t\t\t\t\t<directories>\n\t\t\t\t\t\t\t<directory>${project.build.sourceDirectory}</directory>\n\t\t\t\t\t\t</directories>\n\t\t\t\t\t\t<excludes>\n\t\t\t\t\t\t\t<exclude>**/benchmarks/**/*.java</exclude>\n\t\t\t\t\t\t</excludes>\n\t\t\t\t\t</configuration>\n\t\t\t\t</plugin>\n\t\t\t</plugins>\n\t\t</pluginManagement>\n\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t<artifactId>maven-enforcer-plugin</artifactId>\n\t\t\t\t<executions>\n\t\t\t\t\t<execution>\n\t\t\t\t\t\t<id>enforce-maven</id>\n\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t<goal>enforce</goal>\n\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t<rules>\n\t\t\t\t\t\t\t\t<requireMavenVersion>\n\t\t\t\t\t\t\t\t\t<version>3.5.0</version>\n\t\t\t\t\t\t\t\t</requireMavenVersion>\n\t\t\t\t\t\t\t</rules>\n\t\t\t\t\t\t</configuration>\n\t\t\t\t\t</execution>\n\t\t\t\t</executions>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n\t<profiles>\n\t\t<profile>\n\t\t\t<id>release</id>\n\t\t\t<properties>\n\t\t\t\t<maven.test.skip>true</maven.test.skip>\n\t\t\t\t<skipTests>true</skipTests>\n\t\t\t</properties>\n\t\t\t<build>\n\t\t\t\t<plugins>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t<artifactId>maven-source-plugin</artifactId>\n\t\t\t\t\t\t<version>3.3.1</version>\n\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t<id>attach-sources</id>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>jar-no-fork</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t</executions>\n\t\t\t\t\t</plugin>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t<artifactId>maven-javadoc-plugin</artifactId>\n\t\t\t\t\t\t<version>3.11.2</version>\n\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t<id>attach-javadocs</id>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>jar</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t</executions>\n\t\t\t\t\t</plugin>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t<artifactId>maven-gpg-plugin</artifactId>\n\t\t\t\t\t\t<version>3.2.7</version>\n\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t<id>sign-artifacts</id>\n\t\t\t\t\t\t\t\t<phase>verify</phase>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>sign</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t</executions>\n\t\t\t\t\t</plugin>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t<artifactId>maven-enforcer-plugin</artifactId>\n\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t<id>enforce-jdk</id>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>enforce</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t\t<rules>\n\t\t\t\t\t\t\t\t\t\t<requireJavaVersion>\n\t\t\t\t\t\t\t\t\t\t\t<version>[11, 12)</version>\n\t\t\t\t\t\t\t\t\t\t</requireJavaVersion>\n\t\t\t\t\t\t\t\t\t</rules>\n\t\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t</executions>\n\t\t\t\t\t</plugin>\n\t\t\t\t</plugins>\n\t\t\t</build>\n\t\t</profile>\n\t\t<profile>\n\t\t\t<id>requireSnapshot</id>\n\t\t\t<!-- This profile is activated by the \"-P requireSnapshot\" switch to\n\t\t\t\tbe able to deploy SNAPSHOTs only (which is not allowed for releases) -->\n\t\t\t<build>\n\t\t\t\t<plugins>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t<artifactId>maven-enforcer-plugin</artifactId>\n\t\t\t\t\t\t<version>3.5.0</version>\n\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>enforce</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t\t<rules>\n\t\t\t\t\t\t\t\t\t\t<evaluateBeanshell>\n\t\t\t\t\t\t\t\t\t\t\t<condition>\"${project.version}\".endsWith(\"-SNAPSHOT\")</condition>\n\t\t\t\t\t\t\t\t\t\t\t<message>Only build -SNAPSHOT versions.</message>\n\t\t\t\t\t\t\t\t\t\t</evaluateBeanshell>\n\t\t\t\t\t\t\t\t\t</rules>\n\t\t\t\t\t\t\t\t\t<fail>true</fail>\n\t\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t</executions>\n\t\t\t\t\t</plugin>\n\t\t\t\t</plugins>\n\t\t\t</build>\n\t\t</profile>\n\t\t<!-- Include any tests that require kotlin -->\n\t\t<profile>\n\t\t\t<id>kotlin</id>\n\t\t\t<activation>\n\t\t\t\t<property>\n\t\t\t\t\t<name>!skipKotlin</name>\n\t\t\t\t</property>\n\t\t\t</activation>\n\t\t\t<build>\n\t\t\t\t<pluginManagement>\n\t\t\t\t\t<plugins>\n\t\t\t\t\t\t<plugin>\n\t\t\t\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t\t\t\t\t\t<artifactId>build-helper-maven-plugin</artifactId>\n\t\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t\t<id>add-test-source</id>\n\t\t\t\t\t\t\t\t\t<phase>generate-test-sources</phase>\n\t\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t\t<goal>add-test-source</goal>\n\t\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t\t\t<sources>\n\t\t\t\t\t\t\t\t\t\t\t<source>${kryo.root}/test-kotlin</source>\n\t\t\t\t\t\t\t\t\t\t</sources>\n\t\t\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t\t</executions>\n\t\t\t\t\t\t</plugin>\n\t\t\t\t\t</plugins>\n\t\t\t\t</pluginManagement>\n\t\t\t\t<plugins>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.jetbrains.kotlin</groupId>\n\t\t\t\t\t\t<artifactId>kotlin-maven-plugin</artifactId>\n\t\t\t\t\t\t<version>${kotlin.version}</version>\n\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t<id>test-compile</id>\n\t\t\t\t\t\t\t\t<phase>test-compile</phase>\n\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t<goal>test-compile</goal>\n\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t</executions>\n\t\t\t\t\t</plugin>\n\t\t\t\t</plugins>\n\t\t\t</build>\n\t\t\t<dependencies>\n\t\t\t\t<dependency>\n\t\t\t\t\t<groupId>org.jetbrains.kotlin</groupId>\n\t\t\t\t\t<artifactId>kotlin-stdlib</artifactId>\n\t\t\t\t\t<version>${kotlin.version}</version>\n\t\t\t\t\t<scope>test</scope>\n\t\t\t\t</dependency>\n\t\t\t</dependencies>\n\t\t</profile>\n\t\t<!-- Include any tests that require JDK11+ -->\n\t\t<profile>\n\t\t\t<id>jdk11ge</id>\n\t\t\t<activation>\n\t\t\t\t<jdk>[11,)</jdk>\n\t\t\t</activation>\n\t\t\t<build>\n\t\t\t\t<pluginManagement>\n\t\t\t\t\t<plugins>\n\t\t\t\t\t\t<plugin>\n\t\t\t\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t\t\t\t\t\t<artifactId>build-helper-maven-plugin</artifactId>\n\t\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t\t<id>add-test-source</id>\n\t\t\t\t\t\t\t\t\t<phase>generate-test-sources</phase>\n\t\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t\t<goal>add-test-source</goal>\n\t\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t\t\t<sources>\n\t\t\t\t\t\t\t\t\t\t\t<source>${kryo.root}/test-kotlin</source>\n\t\t\t\t\t\t\t\t\t\t\t<source>${kryo.root}/test-jdk11</source>\n\t\t\t\t\t\t\t\t\t\t</sources>\n\t\t\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t\t</executions>\n\t\t\t\t\t\t</plugin>\n\t\t\t\t\t\t<plugin>\n\t\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t\t\t\t</plugin>\n\t\t\t\t\t</plugins>\n\t\t\t\t</pluginManagement>\n\t\t\t</build>\n\t\t</profile>\n\t\t<!-- Include any tests that require JDK17+ -->\n\t\t<profile>\n\t\t\t<id>jdk17ge</id>\n\t\t\t<activation>\n\t\t\t\t<jdk>[17,)</jdk>\n\t\t\t</activation>\n\t\t\t<build>\n\t\t\t\t<plugins>\n\t\t\t\t\t<plugin>\n\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t<excludes>\n\t\t\t\t\t\t\t\t<exclude>**/java11/*Test.java</exclude>\n\t\t\t\t\t\t\t</excludes>\n\t\t\t\t\t\t</configuration>\n\t\t\t\t\t</plugin>\n\t\t\t\t</plugins>\n\t\t\t\t<pluginManagement>\n\t\t\t\t\t<plugins>\n\t\t\t\t\t\t<plugin>\n\t\t\t\t\t\t\t<groupId>org.codehaus.mojo</groupId>\n\t\t\t\t\t\t\t<artifactId>build-helper-maven-plugin</artifactId>\n\t\t\t\t\t\t\t<executions>\n\t\t\t\t\t\t\t\t<execution>\n\t\t\t\t\t\t\t\t\t<id>add-test-source</id>\n\t\t\t\t\t\t\t\t\t<phase>generate-test-sources</phase>\n\t\t\t\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t\t\t\t<goal>add-test-source</goal>\n\t\t\t\t\t\t\t\t\t</goals>\n\t\t\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t\t\t<sources>\n\t\t\t\t\t\t\t\t\t\t\t<source>${kryo.root}/test-kotlin</source>\n\t\t\t\t\t\t\t\t\t\t\t<source>${kryo.root}/test-jdk11</source>\n\t\t\t\t\t\t\t\t\t\t\t<source>${kryo.root}/test-jdk17</source>\n\t\t\t\t\t\t\t\t\t\t</sources>\n\t\t\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t\t\t</execution>\n\t\t\t\t\t\t\t</executions>\n\t\t\t\t\t\t</plugin>\n\t\t\t\t\t\t<plugin>\n\t\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t<!-- Enable Java 17+ for all sources so that Intellij picks the right language level -->\n\t\t\t\t\t\t\t\t<source>${java.vm.specification.version}</source>\n\t\t\t\t\t\t\t\t<target>${java.vm.specification.version}</target>\n\t\t\t\t\t\t\t\t<compilerArgs>\n\t\t\t\t\t\t\t\t\t<arg>-parameters</arg>\n\t\t\t\t\t\t\t\t\t<arg>--add-exports=java.base/jdk.internal.ref=ALL-UNNAMED</arg>\n\t\t\t\t\t\t\t\t\t<arg>--add-exports=java.base/sun.nio.ch=ALL-UNNAMED</arg>\n\t\t\t\t\t\t\t\t</compilerArgs>\n\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t</plugin>\n\t\t\t\t\t\t<plugin>\n\t\t\t\t\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t\t\t\t\t<artifactId>maven-surefire-plugin</artifactId>\n\t\t\t\t\t\t\t<configuration>\n\t\t\t\t\t\t\t\t<argLine>\n\t\t\t\t\t\t\t\t\t--enable-preview\n\t\t\t\t\t\t\t\t\t--add-opens java.base/sun.nio.ch=ALL-UNNAMED\n\t\t\t\t\t\t\t\t\t--add-opens java.base/java.lang.invoke=ALL-UNNAMED\n\t\t\t\t\t\t\t\t\t--add-opens java.base/java.nio=ALL-UNNAMED\n\t\t\t\t\t\t\t\t\t--add-opens java.base/java.util.concurrent.atomic=ALL-UNNAMED\n\t\t\t\t\t\t\t\t</argLine>\n\t\t\t\t\t\t\t</configuration>\n\t\t\t\t\t\t</plugin>\n\t\t\t\t\t</plugins>\n\t\t\t\t</pluginManagement>\n\t\t\t</build>\n\t\t</profile>\n\t</profiles>\n\n\t<repositories>\n\t\t<repository>\n\t\t\t<id>sonatype-releases</id>\n\t\t\t<name>sonatype releases repo</name>\n\t\t\t<url>https://oss.sonatype.org/content/repositories/releases</url>\n\t\t</repository>\n\t\t<repository>\n\t\t\t<id>sonatype-snapshots</id>\n\t\t\t<name>sonatype snapshots repo</name>\n\t\t\t<url>https://oss.sonatype.org/content/repositories/snapshots</url>\n\t\t\t<releases>\n\t\t\t\t<enabled>false</enabled>\n\t\t\t</releases>\n\t\t\t<snapshots>\n\t\t\t\t<enabled>true</enabled>\n\t\t\t</snapshots>\n\t\t</repository>\n\t</repositories>\n</project>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-jdk11",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-jdk17",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-kotlin",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}