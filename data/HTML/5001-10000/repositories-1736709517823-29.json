{
  "metadata": {
    "timestamp": 1736709517823,
    "page": 29,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ericchiang/pup",
      "stars": 8194,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0517578125,
          "content": "dist/\ntestpages/*\ntests/test_results.txt\nrobots.html\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03125,
          "content": "Copyright (c) 2014: Eric Chiang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.3408203125,
          "content": "# pup\n\npup is a command line tool for processing HTML. It reads from stdin,\nprints to stdout, and allows the user to filter parts of the page using\n[CSS selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors).\n\nInspired by [jq](http://stedolan.github.io/jq/), pup aims to be a\nfast and flexible way of exploring HTML from the terminal.\n\n## Install\n\nDirect downloads are available through the [releases page](https://github.com/EricChiang/pup/releases/latest).\n\nIf you have Go installed on your computer just run `go get`.\n\n    go get github.com/ericchiang/pup\n\nIf you're on OS X, use [Homebrew](http://brew.sh/) to install (no Go required).\n\n    brew install https://raw.githubusercontent.com/EricChiang/pup/master/pup.rb\n\n## Quick start\n\n```bash\n$ curl -s https://news.ycombinator.com/\n```\n\nEw, HTML. Let's run that through some pup selectors:\n\n```bash\n$ curl -s https://news.ycombinator.com/ | pup 'table table tr:nth-last-of-type(n+2) td.title a'\n```\n\nOkay, how about only the links?\n\n```bash\n$ curl -s https://news.ycombinator.com/ | pup 'table table tr:nth-last-of-type(n+2) td.title a attr{href}'\n```\n\nEven better, let's grab the titles too:\n\n```bash\n$ curl -s https://news.ycombinator.com/ | pup 'table table tr:nth-last-of-type(n+2) td.title a json{}'\n```\n\n## Basic Usage\n\n```bash\n$ cat index.html | pup [flags] '[selectors] [display function]'\n```\n\n## Examples\n\nDownload a webpage with wget.\n\n```bash\n$ wget http://en.wikipedia.org/wiki/Robots_exclusion_standard -O robots.html\n```\n\n#### Clean and indent\n\nBy default pup will fill in missing tags and properly indent the page.\n\n```bash\n$ cat robots.html\n# nasty looking HTML\n$ cat robots.html | pup --color\n# cleaned, indented, and colorful HTML\n```\n\n#### Filter by tag\n\n```bash\n$ cat robots.html | pup 'title'\n<title>\n Robots exclusion standard - Wikipedia, the free encyclopedia\n</title>\n```\n\n#### Filter by id\n\n```bash\n$ cat robots.html | pup 'span#See_also'\n<span class=\"mw-headline\" id=\"See_also\">\n See also\n</span>\n```\n\n#### Filter by attribute\n\n```bash\n$ cat robots.html | pup 'th[scope=\"row\"]'\n<th scope=\"row\" class=\"navbox-group\">\n Exclusion standards\n</th>\n<th scope=\"row\" class=\"navbox-group\">\n Related marketing topics\n</th>\n<th scope=\"row\" class=\"navbox-group\">\n Search marketing related topics\n</th>\n<th scope=\"row\" class=\"navbox-group\">\n Search engine spam\n</th>\n<th scope=\"row\" class=\"navbox-group\">\n Linking\n</th>\n<th scope=\"row\" class=\"navbox-group\">\n People\n</th>\n<th scope=\"row\" class=\"navbox-group\">\n Other\n</th>\n```\n\n#### Pseudo Classes\n\nCSS selectors have a group of specifiers called [\"pseudo classes\"](\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes)  which are pretty\ncool. pup implements a majority of the relevant ones them.\n\nHere are some examples.\n\n```bash\n$ cat robots.html | pup 'a[rel]:empty'\n<a rel=\"license\" href=\"//creativecommons.org/licenses/by-sa/3.0/\" style=\"display:none;\">\n</a>\n```\n\n```bash\n$ cat robots.html | pup ':contains(\"History\")'\n<span class=\"toctext\">\n History\n</span>\n<span class=\"mw-headline\" id=\"History\">\n History\n</span>\n```\n\n```bash\n$ cat robots.html | pup ':parent-of([action=\"edit\"])'\n<span class=\"wb-langlinks-edit wb-langlinks-link\">\n <a action=\"edit\" href=\"//www.wikidata.org/wiki/Q80776#sitelinks-wikipedia\" text=\"Edit links\" title=\"Edit interlanguage links\" class=\"wbc-editpage\">\n  Edit links\n </a>\n</span>\n```\n\nFor a complete list, view the [implemented selectors](#implemented-selectors)\nsection.\n\n\n#### `+`, `>`, and `,`\n\nThese are intermediate characters that declare special instructions. For\ninstance, a comma `,` allows pup to specify multiple groups of selectors.\n\n```bash\n$ cat robots.html | pup 'title, h1 span[dir=\"auto\"]'\n<title>\n Robots exclusion standard - Wikipedia, the free encyclopedia\n</title>\n<span dir=\"auto\">\n Robots exclusion standard\n</span>\n```\n\n#### Chain selectors together\n\nWhen combining selectors, the HTML nodes selected by the previous selector will\nbe passed to the next ones.\n\n```bash\n$ cat robots.html | pup 'h1#firstHeading'\n<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">\n <span dir=\"auto\">\n  Robots exclusion standard\n </span>\n</h1>\n```\n\n```bash\n$ cat robots.html | pup 'h1#firstHeading span'\n<span dir=\"auto\">\n Robots exclusion standard\n</span>\n```\n\n## Implemented Selectors\n\nFor further examples of these selectors head over to [MDN](\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/Reference).\n\n```bash\npup '.class'\npup '#id'\npup 'element'\npup 'selector + selector'\npup 'selector > selector'\npup '[attribute]'\npup '[attribute=\"value\"]'\npup '[attribute*=\"value\"]'\npup '[attribute~=\"value\"]'\npup '[attribute^=\"value\"]'\npup '[attribute$=\"value\"]'\npup ':empty'\npup ':first-child'\npup ':first-of-type'\npup ':last-child'\npup ':last-of-type'\npup ':only-child'\npup ':only-of-type'\npup ':contains(\"text\")'\npup ':nth-child(n)'\npup ':nth-of-type(n)'\npup ':nth-last-child(n)'\npup ':nth-last-of-type(n)'\npup ':not(selector)'\npup ':parent-of(selector)'\n```\n\nYou can mix and match selectors as you wish.\n\n```bash\ncat index.html | pup 'element#id[attribute=\"value\"]:first-of-type'\n```\n\n## Display Functions\n\nNon-HTML selectors which effect the output type are implemented as functions\nwhich can be provided as a final argument.\n\n#### `text{}`\n\nPrint all text from selected nodes and children in depth first order.\n\n```bash\n$ cat robots.html | pup '.mw-headline text{}'\nHistory\nAbout the standard\nDisadvantages\nAlternatives\nExamples\nNonstandard extensions\nCrawl-delay directive\nAllow directive\nSitemap\nHost\nUniversal \"*\" match\nMeta tags and headers\nSee also\nReferences\nExternal links\n```\n\n#### `attr{attrkey}`\n\nPrint the values of all attributes with a given key from all selected nodes.\n\n```bash\n$ cat robots.html | pup '.catlinks div attr{id}'\nmw-normal-catlinks\nmw-hidden-catlinks\n```\n\n#### `json{}`\n\nPrint HTML as JSON.\n\n```bash\n$ cat robots.html  | pup 'div#p-namespaces a'\n<a href=\"/wiki/Robots_exclusion_standard\" title=\"View the content page [c]\" accesskey=\"c\">\n Article\n</a>\n<a href=\"/wiki/Talk:Robots_exclusion_standard\" title=\"Discussion about the content page [t]\" accesskey=\"t\">\n Talk\n</a>\n```\n\n```bash\n$ cat robots.html | pup 'div#p-namespaces a json{}'\n[\n {\n  \"accesskey\": \"c\",\n  \"href\": \"/wiki/Robots_exclusion_standard\",\n  \"tag\": \"a\",\n  \"text\": \"Article\",\n  \"title\": \"View the content page [c]\"\n },\n {\n  \"accesskey\": \"t\",\n  \"href\": \"/wiki/Talk:Robots_exclusion_standard\",\n  \"tag\": \"a\",\n  \"text\": \"Talk\",\n  \"title\": \"Discussion about the content page [t]\"\n }\n]\n```\n\nUse the `-i` / `--indent` flag to control the intent level.\n\n```bash\n$ cat robots.html | pup -i 4 'div#p-namespaces a json{}'\n[\n    {\n        \"accesskey\": \"c\",\n        \"href\": \"/wiki/Robots_exclusion_standard\",\n        \"tag\": \"a\",\n        \"text\": \"Article\",\n        \"title\": \"View the content page [c]\"\n    },\n    {\n        \"accesskey\": \"t\",\n        \"href\": \"/wiki/Talk:Robots_exclusion_standard\",\n        \"tag\": \"a\",\n        \"text\": \"Talk\",\n        \"title\": \"Discussion about the content page [t]\"\n    }\n]\n```\n\nIf the selectors only return one element the results will be printed as a JSON\nobject, not a list.\n\n```bash\n$ cat robots.html  | pup --indent 4 'title json{}'\n{\n    \"tag\": \"title\",\n    \"text\": \"Robots exclusion standard - Wikipedia, the free encyclopedia\"\n}\n```\n\nBecause there is no universal standard for converting HTML/XML to JSON, a\nmethod has been chosen which hopefully fits. The goal is simply to get the\noutput of pup into a more consumable format.\n\n## Flags\n\nRun `pup --help` for a list of further options\n"
        },
        {
          "name": "display.go",
          "type": "blob",
          "size": 7.4619140625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/fatih/color\"\n\tcolorable \"github.com/mattn/go-colorable\"\n\t\"golang.org/x/net/html\"\n\t\"golang.org/x/net/html/atom\"\n)\n\nfunc init() {\n\tcolor.Output = colorable.NewColorableStdout()\n}\n\ntype Displayer interface {\n\tDisplay([]*html.Node)\n}\n\nfunc ParseDisplayer(cmd string) error {\n\tattrRe := regexp.MustCompile(`attr\\{([a-zA-Z\\-]+)\\}`)\n\tif cmd == \"text{}\" {\n\t\tpupDisplayer = TextDisplayer{}\n\t} else if cmd == \"json{}\" {\n\t\tpupDisplayer = JSONDisplayer{}\n\t} else if match := attrRe.FindAllStringSubmatch(cmd, -1); len(match) == 1 {\n\t\tpupDisplayer = AttrDisplayer{\n\t\t\tAttr: match[0][1],\n\t\t}\n\t} else {\n\t\treturn fmt.Errorf(\"Unknown displayer\")\n\t}\n\treturn nil\n}\n\n// Is this node a tag with no end tag such as <meta> or <br>?\n// http://www.w3.org/TR/html-markup/syntax.html#syntax-elements\nfunc isVoidElement(n *html.Node) bool {\n\tswitch n.DataAtom {\n\tcase atom.Area, atom.Base, atom.Br, atom.Col, atom.Command, atom.Embed,\n\t\tatom.Hr, atom.Img, atom.Input, atom.Keygen, atom.Link,\n\t\tatom.Meta, atom.Param, atom.Source, atom.Track, atom.Wbr:\n\t\treturn true\n\t}\n\treturn false\n}\n\nvar (\n\t// Colors\n\ttagColor     *color.Color = color.New(color.FgCyan)\n\ttokenColor                = color.New(color.FgCyan)\n\tattrKeyColor              = color.New(color.FgMagenta)\n\tquoteColor                = color.New(color.FgBlue)\n\tcommentColor              = color.New(color.FgYellow)\n)\n\ntype TreeDisplayer struct {\n}\n\nfunc (t TreeDisplayer) Display(nodes []*html.Node) {\n\tfor _, node := range nodes {\n\t\tt.printNode(node, 0)\n\t}\n}\n\n// The <pre> tag indicates that the text within it should always be formatted\n// as is. See https://github.com/ericchiang/pup/issues/33\nfunc (t TreeDisplayer) printPre(n *html.Node) {\n\tswitch n.Type {\n\tcase html.TextNode:\n\t\ts := n.Data\n\t\tif pupEscapeHTML {\n\t\t\t// don't escape javascript\n\t\t\tif n.Parent == nil || n.Parent.DataAtom != atom.Script {\n\t\t\t\ts = html.EscapeString(s)\n\t\t\t}\n\t\t}\n\t\tfmt.Print(s)\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tt.printPre(c)\n\t\t}\n\tcase html.ElementNode:\n\t\tfmt.Printf(\"<%s\", n.Data)\n\t\tfor _, a := range n.Attr {\n\t\t\tval := a.Val\n\t\t\tif pupEscapeHTML {\n\t\t\t\tval = html.EscapeString(val)\n\t\t\t}\n\t\t\tfmt.Printf(` %s=\"%s\"`, a.Key, val)\n\t\t}\n\t\tfmt.Print(\">\")\n\t\tif !isVoidElement(n) {\n\t\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\t\tt.printPre(c)\n\t\t\t}\n\t\t\tfmt.Printf(\"</%s>\", n.Data)\n\t\t}\n\tcase html.CommentNode:\n\t\tdata := n.Data\n\t\tif pupEscapeHTML {\n\t\t\tdata = html.EscapeString(data)\n\t\t}\n\t\tfmt.Printf(\"<!--%s-->\\n\", data)\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tt.printPre(c)\n\t\t}\n\tcase html.DoctypeNode, html.DocumentNode:\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tt.printPre(c)\n\t\t}\n\t}\n}\n\n// Print a node and all of it's children to `maxlevel`.\nfunc (t TreeDisplayer) printNode(n *html.Node, level int) {\n\tswitch n.Type {\n\tcase html.TextNode:\n\t\ts := n.Data\n\t\tif pupEscapeHTML {\n\t\t\t// don't escape javascript\n\t\t\tif n.Parent == nil || n.Parent.DataAtom != atom.Script {\n\t\t\t\ts = html.EscapeString(s)\n\t\t\t}\n\t\t}\n\t\ts = strings.TrimSpace(s)\n\t\tif s != \"\" {\n\t\t\tt.printIndent(level)\n\t\t\tfmt.Println(s)\n\t\t}\n\tcase html.ElementNode:\n\t\tt.printIndent(level)\n\t\t// TODO: allow pre with color\n\t\tif n.DataAtom == atom.Pre && !pupPrintColor && pupPreformatted {\n\t\t\tt.printPre(n)\n\t\t\tfmt.Println()\n\t\t\treturn\n\t\t}\n\t\tif pupPrintColor {\n\t\t\ttokenColor.Print(\"<\")\n\t\t\ttagColor.Printf(\"%s\", n.Data)\n\t\t} else {\n\t\t\tfmt.Printf(\"<%s\", n.Data)\n\t\t}\n\t\tfor _, a := range n.Attr {\n\t\t\tval := a.Val\n\t\t\tif pupEscapeHTML {\n\t\t\t\tval = html.EscapeString(val)\n\t\t\t}\n\t\t\tif pupPrintColor {\n\t\t\t\tfmt.Print(\" \")\n\t\t\t\tattrKeyColor.Printf(\"%s\", a.Key)\n\t\t\t\ttokenColor.Print(\"=\")\n\t\t\t\tquoteColor.Printf(`\"%s\"`, val)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(` %s=\"%s\"`, a.Key, val)\n\t\t\t}\n\t\t}\n\t\tif pupPrintColor {\n\t\t\ttokenColor.Println(\">\")\n\t\t} else {\n\t\t\tfmt.Println(\">\")\n\t\t}\n\t\tif !isVoidElement(n) {\n\t\t\tt.printChildren(n, level+1)\n\t\t\tt.printIndent(level)\n\t\t\tif pupPrintColor {\n\t\t\t\ttokenColor.Print(\"</\")\n\t\t\t\ttagColor.Printf(\"%s\", n.Data)\n\t\t\t\ttokenColor.Println(\">\")\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"</%s>\\n\", n.Data)\n\t\t\t}\n\t\t}\n\tcase html.CommentNode:\n\t\tt.printIndent(level)\n\t\tdata := n.Data\n\t\tif pupEscapeHTML {\n\t\t\tdata = html.EscapeString(data)\n\t\t}\n\t\tif pupPrintColor {\n\t\t\tcommentColor.Printf(\"<!--%s-->\\n\", data)\n\t\t} else {\n\t\t\tfmt.Printf(\"<!--%s-->\\n\", data)\n\t\t}\n\t\tt.printChildren(n, level)\n\tcase html.DoctypeNode, html.DocumentNode:\n\t\tt.printChildren(n, level)\n\t}\n}\n\nfunc (t TreeDisplayer) printChildren(n *html.Node, level int) {\n\tif pupMaxPrintLevel > -1 {\n\t\tif level >= pupMaxPrintLevel {\n\t\t\tt.printIndent(level)\n\t\t\tfmt.Println(\"...\")\n\t\t\treturn\n\t\t}\n\t}\n\tchild := n.FirstChild\n\tfor child != nil {\n\t\tt.printNode(child, level)\n\t\tchild = child.NextSibling\n\t}\n}\n\nfunc (t TreeDisplayer) printIndent(level int) {\n\tfor ; level > 0; level-- {\n\t\tfmt.Print(pupIndentString)\n\t}\n}\n\n// Print the text of a node\ntype TextDisplayer struct{}\n\nfunc (t TextDisplayer) Display(nodes []*html.Node) {\n\tfor _, node := range nodes {\n\t\tif node.Type == html.TextNode {\n\t\t\tdata := node.Data\n\t\t\tif pupEscapeHTML {\n\t\t\t\t// don't escape javascript\n\t\t\t\tif node.Parent == nil || node.Parent.DataAtom != atom.Script {\n\t\t\t\t\tdata = html.EscapeString(data)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Println(data)\n\t\t}\n\t\tchildren := []*html.Node{}\n\t\tchild := node.FirstChild\n\t\tfor child != nil {\n\t\t\tchildren = append(children, child)\n\t\t\tchild = child.NextSibling\n\t\t}\n\t\tt.Display(children)\n\t}\n}\n\n// Print the attribute of a node\ntype AttrDisplayer struct {\n\tAttr string\n}\n\nfunc (a AttrDisplayer) Display(nodes []*html.Node) {\n\tfor _, node := range nodes {\n\t\tattributes := node.Attr\n\t\tfor _, attr := range attributes {\n\t\t\tif attr.Key == a.Attr {\n\t\t\t\tval := attr.Val\n\t\t\t\tif pupEscapeHTML {\n\t\t\t\t\tval = html.EscapeString(val)\n\t\t\t\t}\n\t\t\t\tfmt.Printf(\"%s\\n\", val)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Print nodes as a JSON list\ntype JSONDisplayer struct{}\n\n// returns a jsonifiable struct\nfunc jsonify(node *html.Node) map[string]interface{} {\n\tvals := map[string]interface{}{}\n\tif len(node.Attr) > 0 {\n\t\tfor _, attr := range node.Attr {\n\t\t\tif pupEscapeHTML {\n\t\t\t\tvals[attr.Key] = html.EscapeString(attr.Val)\n\t\t\t} else {\n\t\t\t\tvals[attr.Key] = attr.Val\n\t\t\t}\n\t\t}\n\t}\n\tvals[\"tag\"] = node.DataAtom.String()\n\tchildren := []interface{}{}\n\tfor child := node.FirstChild; child != nil; child = child.NextSibling {\n\t\tswitch child.Type {\n\t\tcase html.ElementNode:\n\t\t\tchildren = append(children, jsonify(child))\n\t\tcase html.TextNode:\n\t\t\ttext := strings.TrimSpace(child.Data)\n\t\t\tif text != \"\" {\n\t\t\t\tif pupEscapeHTML {\n\t\t\t\t\t// don't escape javascript\n\t\t\t\t\tif node.DataAtom != atom.Script {\n\t\t\t\t\t\ttext = html.EscapeString(text)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if there is already text we'll append it\n\t\t\t\tcurrText, ok := vals[\"text\"]\n\t\t\t\tif ok {\n\t\t\t\t\ttext = fmt.Sprintf(\"%s %s\", currText, text)\n\t\t\t\t}\n\t\t\t\tvals[\"text\"] = text\n\t\t\t}\n\t\tcase html.CommentNode:\n\t\t\tcomment := strings.TrimSpace(child.Data)\n\t\t\tif pupEscapeHTML {\n\t\t\t\tcomment = html.EscapeString(comment)\n\t\t\t}\n\t\t\tcurrComment, ok := vals[\"comment\"]\n\t\t\tif ok {\n\t\t\t\tcomment = fmt.Sprintf(\"%s %s\", currComment, comment)\n\t\t\t}\n\t\t\tvals[\"comment\"] = comment\n\t\t}\n\t}\n\tif len(children) > 0 {\n\t\tvals[\"children\"] = children\n\t}\n\treturn vals\n}\n\nfunc (j JSONDisplayer) Display(nodes []*html.Node) {\n\tvar data []byte\n\tvar err error\n\tjsonNodes := []map[string]interface{}{}\n\tfor _, node := range nodes {\n\t\tjsonNodes = append(jsonNodes, jsonify(node))\n\t}\n\tdata, err = json.MarshalIndent(&jsonNodes, \"\", pupIndentString)\n\tif err != nil {\n\t\tpanic(\"Could not jsonify nodes\")\n\t}\n\tfmt.Printf(\"%s\\n\", data)\n}\n\n// Print the number of features returned\ntype NumDisplayer struct{}\n\nfunc (d NumDisplayer) Display(nodes []*html.Node) {\n\tfmt.Println(len(nodes))\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3623046875,
          "content": "module github.com/ericchiang/pup\n\ngo 1.13\n\nrequire (\n\tgithub.com/fatih/color v1.0.0\n\tgithub.com/mattn/go-colorable v0.0.5\n\tgithub.com/mattn/go-isatty v0.0.0-20151211000621-56b76bdf51f7 // indirect\n\tgolang.org/x/net v0.0.0-20160720084139-4d38db76854b\n\tgolang.org/x/sys v0.0.0-20160717071931-a646d33e2ee3 // indirect\n\tgolang.org/x/text v0.0.0-20160719205907-0a5a09ee4409\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.162109375,
          "content": "github.com/fatih/color v1.0.0 h1:4zdNjpoprR9fed2QRCPb2VTPU4UFXEtJc9Vc+sgXkaQ=\ngithub.com/fatih/color v1.0.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/mattn/go-colorable v0.0.5 h1:X1IeP+MaFWC+vpbhw3y426rQftzXSj+N7eJFnBEMBfE=\ngithub.com/mattn/go-colorable v0.0.5/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\ngithub.com/mattn/go-isatty v0.0.0-20151211000621-56b76bdf51f7 h1:owMyzMR4QR+jSdlfkX9jPU3rsby4++j99BfbtgVr6ZY=\ngithub.com/mattn/go-isatty v0.0.0-20151211000621-56b76bdf51f7/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngolang.org/x/net v0.0.0-20160720084139-4d38db76854b h1:2lHDZItrxmjk3OXnITVKcHWo6qQYJSm4q2pmvciVkxo=\ngolang.org/x/net v0.0.0-20160720084139-4d38db76854b/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/sys v0.0.0-20160717071931-a646d33e2ee3 h1:ZLExsLvnoqWSw6JB6k6RjWobIHGR3NG9dzVANJ7SVKc=\ngolang.org/x/sys v0.0.0-20160717071931-a646d33e2ee3/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.0.0-20160719205907-0a5a09ee4409 h1:ImTDOALQ1AOSGXgapb9Q1tOcHlxpQXZCPSIMKLce0JU=\ngolang.org/x/text v0.0.0-20160719205907-0a5a09ee4409/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n"
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 4.3203125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n\t\"golang.org/x/net/html/charset\"\n\t\"golang.org/x/text/transform\"\n)\n\nvar (\n\tpupIn            io.ReadCloser = os.Stdin\n\tpupCharset       string        = \"\"\n\tpupMaxPrintLevel int           = -1\n\tpupPreformatted  bool          = false\n\tpupPrintColor    bool          = false\n\tpupEscapeHTML    bool          = true\n\tpupIndentString  string        = \" \"\n\tpupDisplayer     Displayer     = TreeDisplayer{}\n)\n\n// Parse the html while handling the charset\nfunc ParseHTML(r io.Reader, cs string) (*html.Node, error) {\n\tvar err error\n\tif cs == \"\" {\n\t\t// attempt to guess the charset of the HTML document\n\t\tr, err = charset.NewReader(r, \"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// let the user specify the charset\n\t\te, name := charset.Lookup(cs)\n\t\tif name == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"'%s' is not a valid charset\", cs)\n\t\t}\n\t\tr = transform.NewReader(r, e.NewDecoder())\n\t}\n\treturn html.Parse(r)\n}\n\nfunc PrintHelp(w io.Writer, exitCode int) {\n\thelpString := `Usage\n    pup [flags] [selectors] [optional display function]\nVersion\n    %s\nFlags\n    -c --color         print result with color\n    -f --file          file to read from\n    -h --help          display this help\n    -i --indent        number of spaces to use for indent or character\n    -n --number        print number of elements selected\n    -l --limit         restrict number of levels printed\n    -p --plain         don't escape html\n    --pre              preserve preformatted text\n    --charset          specify the charset for pup to use\n    --version          display version\n`\n\tfmt.Fprintf(w, helpString, VERSION)\n\tos.Exit(exitCode)\n}\n\nfunc ParseArgs() ([]string, error) {\n\tcmds, err := ProcessFlags(os.Args[1:])\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\treturn ParseCommands(strings.Join(cmds, \" \"))\n}\n\n// Process command arguments and return all non-flags.\nfunc ProcessFlags(cmds []string) (nonFlagCmds []string, err error) {\n\tvar i int\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"Option '%s' requires an argument\", cmds[i])\n\t\t}\n\t}()\n\tnonFlagCmds = make([]string, len(cmds))\n\tn := 0\n\tfor i = 0; i < len(cmds); i++ {\n\t\tcmd := cmds[i]\n\t\tswitch cmd {\n\t\tcase \"-c\", \"--color\":\n\t\t\tpupPrintColor = true\n\t\tcase \"-p\", \"--plain\":\n\t\t\tpupEscapeHTML = false\n\t\tcase \"--pre\":\n\t\t\tpupPreformatted = true\n\t\tcase \"-f\", \"--file\":\n\t\t\tfilename := cmds[i+1]\n\t\t\tpupIn, err = os.Open(filename)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", err.Error())\n\t\t\t\tos.Exit(2)\n\t\t\t}\n\t\t\ti++\n\t\tcase \"-h\", \"--help\":\n\t\t\tPrintHelp(os.Stdout, 0)\n\t\tcase \"-i\", \"--indent\":\n\t\t\tindentLevel, err := strconv.Atoi(cmds[i+1])\n\t\t\tif err == nil {\n\t\t\t\tpupIndentString = strings.Repeat(\" \", indentLevel)\n\t\t\t} else {\n\t\t\t\tpupIndentString = cmds[i+1]\n\t\t\t}\n\t\t\ti++\n\t\tcase \"-l\", \"--limit\":\n\t\t\tpupMaxPrintLevel, err = strconv.Atoi(cmds[i+1])\n\t\t\tif err != nil {\n\t\t\t\treturn []string{}, fmt.Errorf(\"Argument for '%s' must be numeric\", cmd)\n\t\t\t}\n\t\t\ti++\n\t\tcase \"--charset\":\n\t\t\tpupCharset = cmds[i+1]\n\t\t\ti++\n\t\tcase \"--version\":\n\t\t\tfmt.Println(VERSION)\n\t\t\tos.Exit(0)\n\t\tcase \"-n\", \"--number\":\n\t\t\tpupDisplayer = NumDisplayer{}\n\t\tdefault:\n\t\t\tif cmd[0] == '-' {\n\t\t\t\treturn []string{}, fmt.Errorf(\"Unrecognized flag '%s'\", cmd)\n\t\t\t}\n\t\t\tnonFlagCmds[n] = cmds[i]\n\t\t\tn++\n\t\t}\n\t}\n\treturn nonFlagCmds[:n], nil\n}\n\n// Split a string with awareness for quoted text and commas\nfunc ParseCommands(cmdString string) ([]string, error) {\n\tcmds := []string{}\n\tlast, next, max := 0, 0, len(cmdString)\n\tfor {\n\t\t// if we're at the end of the string, return\n\t\tif next == max {\n\t\t\tif next > last {\n\t\t\t\tcmds = append(cmds, cmdString[last:next])\n\t\t\t}\n\t\t\treturn cmds, nil\n\t\t}\n\t\t// evaluate a rune\n\t\tc := cmdString[next]\n\t\tswitch c {\n\t\tcase ' ':\n\t\t\tif next > last {\n\t\t\t\tcmds = append(cmds, cmdString[last:next])\n\t\t\t}\n\t\t\tlast = next + 1\n\t\tcase ',':\n\t\t\tif next > last {\n\t\t\t\tcmds = append(cmds, cmdString[last:next])\n\t\t\t}\n\t\t\tcmds = append(cmds, \",\")\n\t\t\tlast = next + 1\n\t\tcase '\\'', '\"':\n\t\t\t// for quotes, consume runes until the quote has ended\n\t\t\tquoteChar := c\n\t\t\tfor {\n\t\t\t\tnext++\n\t\t\t\tif next == max {\n\t\t\t\t\treturn []string{}, fmt.Errorf(\"Unmatched open quote (%c)\", quoteChar)\n\t\t\t\t}\n\t\t\t\tif cmdString[next] == '\\\\' {\n\t\t\t\t\tnext++\n\t\t\t\t\tif next == max {\n\t\t\t\t\t\treturn []string{}, fmt.Errorf(\"Unmatched open quote (%c)\", quoteChar)\n\t\t\t\t\t}\n\t\t\t\t} else if cmdString[next] == quoteChar {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext++\n\t}\n}\n"
        },
        {
          "name": "parse_test.go",
          "type": "blob",
          "size": 3.3154296875,
          "content": "package main\n\nimport (\n\t\"testing\"\n)\n\ntype parseCmdTest struct {\n\tinput string\n\tsplit []string\n\tok    bool\n}\n\nvar parseCmdTests = []parseCmdTest{\n\tparseCmdTest{`w1 w2`, []string{`w1`, `w2`}, true},\n\tparseCmdTest{`w1 w2 w3`, []string{`w1`, `w2`, `w3`}, true},\n\tparseCmdTest{`w1 'w2 w3'`, []string{`w1`, `'w2 w3'`}, true},\n\tparseCmdTest{`w1 \"w2 w3\"`, []string{`w1`, `\"w2 w3\"`}, true},\n\tparseCmdTest{`w1   \"w2 w3\"`, []string{`w1`, `\"w2 w3\"`}, true},\n\tparseCmdTest{`w1   'w2 w3'`, []string{`w1`, `'w2 w3'`}, true},\n\tparseCmdTest{`w1\"w2 w3\"`, []string{`w1\"w2 w3\"`}, true},\n\tparseCmdTest{`w1'w2 w3'`, []string{`w1'w2 w3'`}, true},\n\tparseCmdTest{`w1\"w2 'w3\"`, []string{`w1\"w2 'w3\"`}, true},\n\tparseCmdTest{`w1'w2 \"w3'`, []string{`w1'w2 \"w3'`}, true},\n\tparseCmdTest{`\"w1 w2\" \"w3\"`, []string{`\"w1 w2\"`, `\"w3\"`}, true},\n\tparseCmdTest{`'w1 w2' \"w3\"`, []string{`'w1 w2'`, `\"w3\"`}, true},\n\tparseCmdTest{`'w1 \\'w2' \"w3\"`, []string{`'w1 \\'w2'`, `\"w3\"`}, true},\n\tparseCmdTest{`'w1 \\'w2 \"w3\"`, []string{}, false},\n\tparseCmdTest{`w1 'w2 w3'\"`, []string{}, false},\n\tparseCmdTest{`w1 \"w2 w3\"'`, []string{}, false},\n\tparseCmdTest{`w1 '  \"w2 w3\"`, []string{}, false},\n\tparseCmdTest{`w1 \"  'w2 w3'`, []string{}, false},\n\tparseCmdTest{`w1\"w2 w3\"\"`, []string{}, false},\n\tparseCmdTest{`w1'w2 w3''`, []string{}, false},\n\tparseCmdTest{`w1\"w2 'w3\"\"`, []string{}, false},\n\tparseCmdTest{`w1'w2 \"w3''`, []string{}, false},\n\tparseCmdTest{`\"w1 w2\" \"w3\"'`, []string{}, false},\n\tparseCmdTest{`'w1 w2' \"w3\"'`, []string{}, false},\n\tparseCmdTest{`w1,\"w2 w3\"`, []string{`w1`, `,`, `\"w2 w3\"`}, true},\n\tparseCmdTest{`w1,'w2 w3'`, []string{`w1`, `,`, `'w2 w3'`}, true},\n\tparseCmdTest{`w1  ,  \"w2 w3\"`, []string{`w1`, `,`, `\"w2 w3\"`}, true},\n\tparseCmdTest{`w1  ,  'w2 w3'`, []string{`w1`, `,`, `'w2 w3'`}, true},\n\tparseCmdTest{`w1,  \"w2 w3\"`, []string{`w1`, `,`, `\"w2 w3\"`}, true},\n\tparseCmdTest{`w1,  'w2 w3'`, []string{`w1`, `,`, `'w2 w3'`}, true},\n\tparseCmdTest{`w1  ,\"w2 w3\"`, []string{`w1`, `,`, `\"w2 w3\"`}, true},\n\tparseCmdTest{`w1  ,'w2 w3'`, []string{`w1`, `,`, `'w2 w3'`}, true},\n\tparseCmdTest{`w1\"w2, w3\"`, []string{`w1\"w2, w3\"`}, true},\n\tparseCmdTest{`w1'w2, w3'`, []string{`w1'w2, w3'`}, true},\n\tparseCmdTest{`w1\"w2, 'w3\"`, []string{`w1\"w2, 'w3\"`}, true},\n\tparseCmdTest{`w1'w2, \"w3'`, []string{`w1'w2, \"w3'`}, true},\n\tparseCmdTest{`\"w1, w2\" \"w3\"`, []string{`\"w1, w2\"`, `\"w3\"`}, true},\n\tparseCmdTest{`'w1, w2' \"w3\"`, []string{`'w1, w2'`, `\"w3\"`}, true},\n\tparseCmdTest{`'w1, \\'w2' \"w3\"`, []string{`'w1, \\'w2'`, `\"w3\"`}, true},\n\tparseCmdTest{`h1, .article-teaser, .article-content`, []string{\n\t\t`h1`, `,`, `.article-teaser`, `,`, `.article-content`,\n\t}, true},\n\tparseCmdTest{`h1 ,.article-teaser ,.article-content`, []string{\n\t\t`h1`, `,`, `.article-teaser`, `,`, `.article-content`,\n\t}, true},\n\tparseCmdTest{`h1 , .article-teaser , .article-content`, []string{\n\t\t`h1`, `,`, `.article-teaser`, `,`, `.article-content`,\n\t}, true},\n}\n\nfunc sliceEq(s1, s2 []string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestParseCommands(t *testing.T) {\n\tfor _, test := range parseCmdTests {\n\t\tparsed, err := ParseCommands(test.input)\n\t\tif test.ok != (err == nil) {\n\t\t\tt.Errorf(\"`%s`: should have cause error? %v\", test.input, !test.ok)\n\t\t} else if !sliceEq(test.split, parsed) {\n\t\t\tt.Errorf(\"`%s`: `%s`: `%s`\", test.input, test.split, parsed)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pup.go",
          "type": "blob",
          "size": 1.65625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"golang.org/x/net/html\"\n)\n\n//      _=,_\n//   o_/6 /#\\\n//   \\__ |##/\n//    ='|--\\\n//      /   #'-.\n//      \\#|_   _'-. /\n//       |/ \\_( # |\"\n//      C/ ,--___/\n\nvar VERSION string = \"0.4.0\"\n\nfunc main() {\n\t// process flags and arguments\n\tcmds, err := ParseArgs()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", err.Error())\n\t\tos.Exit(2)\n\t}\n\n\t// Parse the input and get the root node\n\troot, err := ParseHTML(pupIn, pupCharset)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", err.Error())\n\t\tos.Exit(2)\n\t}\n\tpupIn.Close()\n\n\t// Parse the selectors\n\tselectorFuncs := []SelectorFunc{}\n\tfuncGenerator := Select\n\tvar cmd string\n\tfor len(cmds) > 0 {\n\t\tcmd, cmds = cmds[0], cmds[1:]\n\t\tif len(cmds) == 0 {\n\t\t\tif err := ParseDisplayer(cmd); err == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tswitch cmd {\n\t\tcase \"*\": // select all\n\t\t\tcontinue\n\t\tcase \">\":\n\t\t\tfuncGenerator = SelectFromChildren\n\t\tcase \"+\":\n\t\t\tfuncGenerator = SelectNextSibling\n\t\tcase \",\": // nil will signify a comma\n\t\t\tselectorFuncs = append(selectorFuncs, nil)\n\t\tdefault:\n\t\t\tselector, err := ParseSelector(cmd)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Selector parsing error: %s\\n\", err.Error())\n\t\t\t\tos.Exit(2)\n\t\t\t}\n\t\t\tselectorFuncs = append(selectorFuncs, funcGenerator(selector))\n\t\t\tfuncGenerator = Select\n\t\t}\n\t}\n\n\tselectedNodes := []*html.Node{}\n\tcurrNodes := []*html.Node{root}\n\tfor _, selectorFunc := range selectorFuncs {\n\t\tif selectorFunc == nil { // hit a comma\n\t\t\tselectedNodes = append(selectedNodes, currNodes...)\n\t\t\tcurrNodes = []*html.Node{root}\n\t\t} else {\n\t\t\tcurrNodes = selectorFunc(currNodes)\n\t\t}\n\t}\n\tselectedNodes = append(selectedNodes, currNodes...)\n\tpupDisplayer.Display(selectedNodes)\n}\n"
        },
        {
          "name": "pup.rb",
          "type": "blob",
          "size": 0.568359375,
          "content": "# This file was generated by release.sh\nrequire 'formula'\nclass Pup < Formula\n  homepage 'https://github.com/ericchiang/pup'\n  version '0.4.0'\n\n  if Hardware::CPU.is_64_bit?\n    url 'https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_darwin_amd64.zip'\n    sha256 'c539a697efee2f8e56614a54cb3b215338e00de1f6a7c2fa93144ab6e1db8ebe'\n  else\n    url 'https://github.com/ericchiang/pup/releases/download/v0.4.0/pup_v0.4.0_darwin_386.zip'\n    sha256 '75c27caa0008a9cc639beb7506077ad9f32facbffcc4e815e999eaf9588a527e'\n  end\n\n  def install\n    bin.install 'pup'\n  end\nend\n"
        },
        {
          "name": "selector.go",
          "type": "blob",
          "size": 14.884765625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/scanner\"\n\n\t\"golang.org/x/net/html\"\n)\n\ntype Selector interface {\n\tMatch(node *html.Node) bool\n}\n\ntype SelectorFunc func(nodes []*html.Node) []*html.Node\n\nfunc Select(s Selector) SelectorFunc {\n\t// have to define first to be able to do recursion\n\tvar selectChildren func(node *html.Node) []*html.Node\n\tselectChildren = func(node *html.Node) []*html.Node {\n\t\tselected := []*html.Node{}\n\t\tfor child := node.FirstChild; child != nil; child = child.NextSibling {\n\t\t\tif s.Match(child) {\n\t\t\t\tselected = append(selected, child)\n\t\t\t} else {\n\t\t\t\tselected = append(selected, selectChildren(child)...)\n\t\t\t}\n\t\t}\n\t\treturn selected\n\t}\n\treturn func(nodes []*html.Node) []*html.Node {\n\t\tselected := []*html.Node{}\n\t\tfor _, node := range nodes {\n\t\t\tselected = append(selected, selectChildren(node)...)\n\t\t}\n\t\treturn selected\n\t}\n}\n\n// Defined for the '>' selector\nfunc SelectNextSibling(s Selector) SelectorFunc {\n\treturn func(nodes []*html.Node) []*html.Node {\n\t\tselected := []*html.Node{}\n\t\tfor _, node := range nodes {\n\t\t\tfor ns := node.NextSibling; ns != nil; ns = ns.NextSibling {\n\t\t\t\tif ns.Type == html.ElementNode {\n\t\t\t\t\tif s.Match(ns) {\n\t\t\t\t\t\tselected = append(selected, ns)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn selected\n\t}\n}\n\n// Defined for the '+' selector\nfunc SelectFromChildren(s Selector) SelectorFunc {\n\treturn func(nodes []*html.Node) []*html.Node {\n\t\tselected := []*html.Node{}\n\t\tfor _, node := range nodes {\n\t\t\tfor c := node.FirstChild; c != nil; c = c.NextSibling {\n\t\t\t\tif s.Match(c) {\n\t\t\t\t\tselected = append(selected, c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn selected\n\t}\n}\n\ntype PseudoClass func(*html.Node) bool\n\ntype CSSSelector struct {\n\tTag    string\n\tAttrs  map[string]*regexp.Regexp\n\tPseudo PseudoClass\n}\n\nfunc (s CSSSelector) Match(node *html.Node) bool {\n\tif node.Type != html.ElementNode {\n\t\treturn false\n\t}\n\tif s.Tag != \"\" {\n\t\tif s.Tag != node.DataAtom.String() {\n\t\t\treturn false\n\t\t}\n\t}\n\tfor attrKey, matcher := range s.Attrs {\n\t\tmatched := false\n\t\tfor _, attr := range node.Attr {\n\t\t\tif attrKey == attr.Key {\n\t\t\t\tif !matcher.MatchString(attr.Val) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tmatched = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !matched {\n\t\t\treturn false\n\t\t}\n\t}\n\tif s.Pseudo == nil {\n\t\treturn true\n\t}\n\treturn s.Pseudo(node)\n}\n\n// Parse a selector\n// e.g. `div#my-button.btn[href^=\"http\"]`\nfunc ParseSelector(cmd string) (selector CSSSelector, err error) {\n\tselector = CSSSelector{\n\t\tTag:    \"\",\n\t\tAttrs:  map[string]*regexp.Regexp{},\n\t\tPseudo: nil,\n\t}\n\tvar s scanner.Scanner\n\ts.Init(strings.NewReader(cmd))\n\terr = ParseTagMatcher(&selector, s)\n\treturn\n}\n\n// Parse the initial tag\n// e.g. `div`\nfunc ParseTagMatcher(selector *CSSSelector, s scanner.Scanner) error {\n\ttag := bytes.NewBuffer([]byte{})\n\tdefer func() {\n\t\tselector.Tag = tag.String()\n\t}()\n\tfor {\n\t\tc := s.Next()\n\t\tswitch c {\n\t\tcase scanner.EOF:\n\t\t\treturn nil\n\t\tcase '.':\n\t\t\treturn ParseClassMatcher(selector, s)\n\t\tcase '#':\n\t\t\treturn ParseIdMatcher(selector, s)\n\t\tcase '[':\n\t\t\treturn ParseAttrMatcher(selector, s)\n\t\tcase ':':\n\t\t\treturn ParsePseudo(selector, s)\n\t\tdefault:\n\t\t\tif _, err := tag.WriteRune(c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parse a class matcher\n// e.g. `.btn`\nfunc ParseClassMatcher(selector *CSSSelector, s scanner.Scanner) error {\n\tvar class bytes.Buffer\n\tdefer func() {\n\t\tregexpStr := `(\\A|\\s)` + regexp.QuoteMeta(class.String()) + `(\\s|\\z)`\n\t\tselector.Attrs[\"class\"] = regexp.MustCompile(regexpStr)\n\t}()\n\tfor {\n\t\tc := s.Next()\n\t\tswitch c {\n\t\tcase scanner.EOF:\n\t\t\treturn nil\n\t\tcase '.':\n\t\t\treturn ParseClassMatcher(selector, s)\n\t\tcase '#':\n\t\t\treturn ParseIdMatcher(selector, s)\n\t\tcase '[':\n\t\t\treturn ParseAttrMatcher(selector, s)\n\t\tcase ':':\n\t\t\treturn ParsePseudo(selector, s)\n\t\tdefault:\n\t\t\tif _, err := class.WriteRune(c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parse an id matcher\n// e.g. `#my-picture`\nfunc ParseIdMatcher(selector *CSSSelector, s scanner.Scanner) error {\n\tvar id bytes.Buffer\n\tdefer func() {\n\t\tregexpStr := `^` + regexp.QuoteMeta(id.String()) + `$`\n\t\tselector.Attrs[\"id\"] = regexp.MustCompile(regexpStr)\n\t}()\n\tfor {\n\t\tc := s.Next()\n\t\tswitch c {\n\t\tcase scanner.EOF:\n\t\t\treturn nil\n\t\tcase '.':\n\t\t\treturn ParseClassMatcher(selector, s)\n\t\tcase '#':\n\t\t\treturn ParseIdMatcher(selector, s)\n\t\tcase '[':\n\t\t\treturn ParseAttrMatcher(selector, s)\n\t\tcase ':':\n\t\t\treturn ParsePseudo(selector, s)\n\t\tdefault:\n\t\t\tif _, err := id.WriteRune(c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parse an attribute matcher\n// e.g. `[attr^=\"http\"]`\nfunc ParseAttrMatcher(selector *CSSSelector, s scanner.Scanner) error {\n\tvar attrKey bytes.Buffer\n\tvar attrVal bytes.Buffer\n\thasMatchVal := false\n\tmatchType := '='\n\tdefer func() {\n\t\tif hasMatchVal {\n\t\t\tvar regexpStr string\n\t\t\tswitch matchType {\n\t\t\tcase '=':\n\t\t\t\tregexpStr = `^` + regexp.QuoteMeta(attrVal.String()) + `$`\n\t\t\tcase '*':\n\t\t\t\tregexpStr = regexp.QuoteMeta(attrVal.String())\n\t\t\tcase '$':\n\t\t\t\tregexpStr = regexp.QuoteMeta(attrVal.String()) + `$`\n\t\t\tcase '^':\n\t\t\t\tregexpStr = `^` + regexp.QuoteMeta(attrVal.String())\n\t\t\tcase '~':\n\t\t\t\tregexpStr = `(\\A|\\s)` + regexp.QuoteMeta(attrVal.String()) + `(\\s|\\z)`\n\t\t\t}\n\t\t\tselector.Attrs[attrKey.String()] = regexp.MustCompile(regexpStr)\n\t\t} else {\n\t\t\tselector.Attrs[attrKey.String()] = regexp.MustCompile(`^.*$`)\n\t\t}\n\t}()\n\t// After reaching ']' proceed\n\tproceed := func() error {\n\t\tswitch s.Next() {\n\t\tcase scanner.EOF:\n\t\t\treturn nil\n\t\tcase '.':\n\t\t\treturn ParseClassMatcher(selector, s)\n\t\tcase '#':\n\t\t\treturn ParseIdMatcher(selector, s)\n\t\tcase '[':\n\t\t\treturn ParseAttrMatcher(selector, s)\n\t\tcase ':':\n\t\t\treturn ParsePseudo(selector, s)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"Expected selector indicator after ']'\")\n\t\t}\n\t}\n\t// Parse the attribute key matcher\n\tfor !hasMatchVal {\n\t\tc := s.Next()\n\t\tswitch c {\n\t\tcase scanner.EOF:\n\t\t\treturn fmt.Errorf(\"Unmatched open brace '['\")\n\t\tcase ']':\n\t\t\t// No attribute value matcher, proceed!\n\t\t\treturn proceed()\n\t\tcase '$', '^', '~', '*':\n\t\t\tmatchType = c\n\t\t\thasMatchVal = true\n\t\t\tif s.Next() != '=' {\n\t\t\t\treturn fmt.Errorf(\"'%c' must be followed by a '='\", matchType)\n\t\t\t}\n\t\tcase '=':\n\t\t\tmatchType = c\n\t\t\thasMatchVal = true\n\t\tdefault:\n\t\t\tif _, err := attrKey.WriteRune(c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\t// figure out if the value is quoted\n\tc := s.Next()\n\tinQuote := false\n\tswitch c {\n\tcase scanner.EOF:\n\t\treturn fmt.Errorf(\"Unmatched open brace '['\")\n\tcase ']':\n\t\treturn proceed()\n\tcase '\"':\n\t\tinQuote = true\n\tdefault:\n\t\tif _, err := attrVal.WriteRune(c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif inQuote {\n\t\tfor {\n\t\t\tc := s.Next()\n\t\t\tswitch c {\n\t\t\tcase '\\\\':\n\t\t\t\t// consume another character\n\t\t\t\tif c = s.Next(); c == scanner.EOF {\n\t\t\t\t\treturn fmt.Errorf(\"Unmatched open brace '['\")\n\t\t\t\t}\n\t\t\tcase '\"':\n\t\t\t\tswitch s.Next() {\n\t\t\t\tcase ']':\n\t\t\t\t\treturn proceed()\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"Quote must end at ']'\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, err := attrVal.WriteRune(c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor {\n\t\t\tc := s.Next()\n\t\t\tswitch c {\n\t\t\tcase scanner.EOF:\n\t\t\t\treturn fmt.Errorf(\"Unmatched open brace '['\")\n\t\t\tcase ']':\n\t\t\t\t// No attribute value matcher, proceed!\n\t\t\t\treturn proceed()\n\t\t\t}\n\t\t\tif _, err := attrVal.WriteRune(c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parse the selector after ':'\nfunc ParsePseudo(selector *CSSSelector, s scanner.Scanner) error {\n\tif selector.Pseudo != nil {\n\t\treturn fmt.Errorf(\"Combined multiple pseudo classes\")\n\t}\n\tvar b bytes.Buffer\n\tfor s.Peek() != scanner.EOF {\n\t\tif _, err := b.WriteRune(s.Next()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tcmd := b.String()\n\tvar err error\n\tswitch {\n\tcase cmd == \"empty\":\n\t\tselector.Pseudo = func(n *html.Node) bool {\n\t\t\treturn n.FirstChild == nil\n\t\t}\n\tcase cmd == \"first-child\":\n\t\tselector.Pseudo = firstChildPseudo\n\tcase cmd == \"last-child\":\n\t\tselector.Pseudo = lastChildPseudo\n\tcase cmd == \"only-child\":\n\t\tselector.Pseudo = func(n *html.Node) bool {\n\t\t\treturn firstChildPseudo(n) && lastChildPseudo(n)\n\t\t}\n\tcase cmd == \"first-of-type\":\n\t\tselector.Pseudo = firstOfTypePseudo\n\tcase cmd == \"last-of-type\":\n\t\tselector.Pseudo = lastOfTypePseudo\n\tcase cmd == \"only-of-type\":\n\t\tselector.Pseudo = func(n *html.Node) bool {\n\t\t\treturn firstOfTypePseudo(n) && lastOfTypePseudo(n)\n\t\t}\n\tcase strings.HasPrefix(cmd, \"contains(\"):\n\t\tselector.Pseudo, err = parseContainsPseudo(cmd[len(\"contains(\"):])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase strings.HasPrefix(cmd, \"nth-child(\"),\n\t\tstrings.HasPrefix(cmd, \"nth-last-child(\"),\n\t\tstrings.HasPrefix(cmd, \"nth-last-of-type(\"),\n\t\tstrings.HasPrefix(cmd, \"nth-of-type(\"):\n\t\tif selector.Pseudo, err = parseNthPseudo(cmd); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase strings.HasPrefix(cmd, \"not(\"):\n\t\tif selector.Pseudo, err = parseNotPseudo(cmd[len(\"not(\"):]); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase strings.HasPrefix(cmd, \"parent-of(\"):\n\t\tif selector.Pseudo, err = parseParentOfPseudo(cmd[len(\"parent-of(\"):]); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"%s not a valid pseudo class\", cmd)\n\t}\n\treturn nil\n}\n\n// :first-of-child\nfunc firstChildPseudo(n *html.Node) bool {\n\tfor c := n.PrevSibling; c != nil; c = c.PrevSibling {\n\t\tif c.Type == html.ElementNode {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// :last-of-child\nfunc lastChildPseudo(n *html.Node) bool {\n\tfor c := n.NextSibling; c != nil; c = c.NextSibling {\n\t\tif c.Type == html.ElementNode {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// :first-of-type\nfunc firstOfTypePseudo(node *html.Node) bool {\n\tif node.Type != html.ElementNode {\n\t\treturn false\n\t}\n\tfor n := node.PrevSibling; n != nil; n = n.PrevSibling {\n\t\tif n.DataAtom == node.DataAtom {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// :last-of-type\nfunc lastOfTypePseudo(node *html.Node) bool {\n\tif node.Type != html.ElementNode {\n\t\treturn false\n\t}\n\tfor n := node.NextSibling; n != nil; n = n.NextSibling {\n\t\tif n.DataAtom == node.DataAtom {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc parseNthPseudo(cmd string) (PseudoClass, error) {\n\ti := strings.IndexRune(cmd, '(')\n\tif i < 0 {\n\t\t// really, we should never get here\n\t\treturn nil, fmt.Errorf(\"Fatal error, '%s' does not contain a '('\", cmd)\n\t}\n\tpseudoName := cmd[:i]\n\t// Figure out how the counting function works\n\tvar countNth func(*html.Node) int\n\tswitch pseudoName {\n\tcase \"nth-child\":\n\t\tcountNth = func(n *html.Node) int {\n\t\t\tnth := 1\n\t\t\tfor sib := n.PrevSibling; sib != nil; sib = sib.PrevSibling {\n\t\t\t\tif sib.Type == html.ElementNode {\n\t\t\t\t\tnth++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nth\n\t\t}\n\tcase \"nth-of-type\":\n\t\tcountNth = func(n *html.Node) int {\n\t\t\tnth := 1\n\t\t\tfor sib := n.PrevSibling; sib != nil; sib = sib.PrevSibling {\n\t\t\t\tif sib.Type == html.ElementNode && sib.DataAtom == n.DataAtom {\n\t\t\t\t\tnth++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nth\n\t\t}\n\tcase \"nth-last-child\":\n\t\tcountNth = func(n *html.Node) int {\n\t\t\tnth := 1\n\t\t\tfor sib := n.NextSibling; sib != nil; sib = sib.NextSibling {\n\t\t\t\tif sib.Type == html.ElementNode {\n\t\t\t\t\tnth++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nth\n\t\t}\n\tcase \"nth-last-of-type\":\n\t\tcountNth = func(n *html.Node) int {\n\t\t\tnth := 1\n\t\t\tfor sib := n.NextSibling; sib != nil; sib = sib.NextSibling {\n\t\t\t\tif sib.Type == html.ElementNode && sib.DataAtom == n.DataAtom {\n\t\t\t\t\tnth++\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nth\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Unrecognized pseudo '%s'\", pseudoName)\n\t}\n\n\tnthString := cmd[i+1:]\n\ti = strings.IndexRune(nthString, ')')\n\tif i < 0 {\n\t\treturn nil, fmt.Errorf(\"Unmatched '(' for pseudo class %s\", pseudoName)\n\t} else if i != len(nthString)-1 {\n\t\treturn nil, fmt.Errorf(\"%s(n) must end selector\", pseudoName)\n\t}\n\tnumber := nthString[:i]\n\n\t// Check if the number is 'odd' or 'even'\n\toddOrEven := -1\n\tswitch number {\n\tcase \"odd\":\n\t\toddOrEven = 1\n\tcase \"even\":\n\t\toddOrEven = 0\n\t}\n\tif oddOrEven > -1 {\n\t\treturn func(n *html.Node) bool {\n\t\t\treturn n.Type == html.ElementNode && countNth(n)%2 == oddOrEven\n\t\t}, nil\n\t}\n\t// Check against '3n+4' pattern\n\tr := regexp.MustCompile(`([0-9]+)n[ ]?\\+[ ]?([0-9])`)\n\tsubMatch := r.FindAllStringSubmatch(number, -1)\n\tif len(subMatch) == 1 && len(subMatch[0]) == 3 {\n\t\tcycle, _ := strconv.Atoi(subMatch[0][1])\n\t\toffset, _ := strconv.Atoi(subMatch[0][2])\n\t\treturn func(n *html.Node) bool {\n\t\t\treturn n.Type == html.ElementNode && countNth(n)%cycle == offset\n\t\t}, nil\n\t}\n\t// check against 'n+2' pattern\n\tr = regexp.MustCompile(`n[ ]?\\+[ ]?([0-9])`)\n\tsubMatch = r.FindAllStringSubmatch(number, -1)\n\tif len(subMatch) == 1 && len(subMatch[0]) == 2 {\n\t\toffset, _ := strconv.Atoi(subMatch[0][1])\n\t\treturn func(n *html.Node) bool {\n\t\t\treturn n.Type == html.ElementNode && countNth(n) >= offset\n\t\t}, nil\n\t}\n\t// the only other option is a numeric value\n\tnth, err := strconv.Atoi(nthString[:i])\n\tif err != nil {\n\t\treturn nil, err\n\t} else if nth <= 0 {\n\t\treturn nil, fmt.Errorf(\"Argument to '%s' must be greater than 0\", pseudoName)\n\t}\n\treturn func(n *html.Node) bool {\n\t\treturn n.Type == html.ElementNode && countNth(n) == nth\n\t}, nil\n}\n\n// Parse a :contains(\"\") selector\n// expects the input to be everything after the open parenthesis\n// e.g. for `contains(\"Help\")` the argument would be `\"Help\")`\nfunc parseContainsPseudo(cmd string) (PseudoClass, error) {\n\tvar s scanner.Scanner\n\ts.Init(strings.NewReader(cmd))\n\tswitch s.Next() {\n\tcase '\"':\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Malformed 'contains(\\\"\\\")' selector\")\n\t}\n\ttextToContain := bytes.NewBuffer([]byte{})\n\tfor {\n\t\tr := s.Next()\n\t\tswitch r {\n\t\tcase '\"':\n\t\t\t// ')' then EOF must follow '\"'\n\t\t\tif s.Next() != ')' {\n\t\t\t\treturn nil, fmt.Errorf(\"Malformed 'contains(\\\"\\\")' selector\")\n\t\t\t}\n\t\t\tif s.Next() != scanner.EOF {\n\t\t\t\treturn nil, fmt.Errorf(\"'contains(\\\"\\\")' must end selector\")\n\t\t\t}\n\t\t\ttext := textToContain.String()\n\t\t\tcontains := func(node *html.Node) bool {\n\t\t\t\tfor c := node.FirstChild; c != nil; c = c.NextSibling {\n\t\t\t\t\tif c.Type == html.TextNode {\n\t\t\t\t\t\tif strings.Contains(c.Data, text) {\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn contains, nil\n\t\tcase '\\\\':\n\t\t\ts.Next()\n\t\tcase scanner.EOF:\n\t\t\treturn nil, fmt.Errorf(\"Malformed 'contains(\\\"\\\")' selector\")\n\t\tdefault:\n\t\t\tif _, err := textToContain.WriteRune(r); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Parse a :not(selector) selector\n// expects the input to be everything after the open parenthesis\n// e.g. for `not(div#id)` the argument would be `div#id)`\nfunc parseNotPseudo(cmd string) (PseudoClass, error) {\n\tif len(cmd) < 2 {\n\t\treturn nil, fmt.Errorf(\"malformed ':not' selector\")\n\t}\n\tendQuote, cmd := cmd[len(cmd)-1], cmd[:len(cmd)-1]\n\tselector, err := ParseSelector(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif endQuote != ')' {\n\t\treturn nil, fmt.Errorf(\"unmatched '('\")\n\t}\n\treturn func(n *html.Node) bool {\n\t\treturn !selector.Match(n)\n\t}, nil\n}\n\n// Parse a :parent-of(selector) selector\n// expects the input to be everything after the open parenthesis\n// e.g. for `parent-of(div#id)` the argument would be `div#id)`\nfunc parseParentOfPseudo(cmd string) (PseudoClass, error) {\n\tif len(cmd) < 2 {\n\t\treturn nil, fmt.Errorf(\"malformed ':parent-of' selector\")\n\t}\n\tendQuote, cmd := cmd[len(cmd)-1], cmd[:len(cmd)-1]\n\tselector, err := ParseSelector(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif endQuote != ')' {\n\t\treturn nil, fmt.Errorf(\"unmatched '('\")\n\t}\n\treturn func(n *html.Node) bool {\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tif c.Type == html.ElementNode && selector.Match(c) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}, nil\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}