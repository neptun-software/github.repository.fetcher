{
  "metadata": {
    "timestamp": 1736557505535,
    "page": 536,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gofiber/fiber",
      "stars": 34603,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.24,
          "content": "; This file is for unifying the coding style for different editors and IDEs.\n; More information at http://editorconfig.org\n; This style originates from https://github.com/fewagency/best-practices\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.5,
          "content": "# Handle line endings automatically for files detected as text\n# and leave all files detected as binary untouched.\n* text=auto eol=lf\n\n# Force batch scripts to always use CRLF line endings so that if a repo is accessed\n# in Windows via a file share from Linux, the scripts will work.\n*.{cmd,[cC][mM][dD]} text eol=crlf\n*.{bat,[bB][aA][tT]} text eol=crlf\n\n# Force bash scripts to always use LF line endings so that if a repo is accessed\n# in Unix via a file share from Windows, the scripts will work.\n*.sh text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.38,
          "content": "# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n*.tmp\n\n# Output of the go coverage tool\n**/*.out\n\n# IDE files\n.vscode\n.DS_Store\n.idea\n\n# Misc\n*.fiber.gz\n*.fiber.zst\n*.fiber.br\n*.fasthttp.gz\n*.fasthttp.zst\n*.fasthttp.br\n*.test.gz\n*.test.zst\n*.test.br\n*.pprof\n*.workspace\n\n# Dependencies\n/vendor/\nvendor/\nvendor\n/Godeps/"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 8.24,
          "content": "# v1.2.0. Created based on golangci-lint v1.57.1\n\nrun:\n  timeout: 5m\n  modules-download-mode: readonly\n  allow-serial-runners: true\n\noutput:\n  sort-results: true\n  uniq-by-line: false\n\nlinters-settings:\n  depguard:\n    rules:\n      all:\n        list-mode: lax\n        deny:\n          - pkg: \"flag\"\n            desc: '`flag` package is only allowed in main.go'\n          - pkg: \"log\"\n            desc: 'logging is provided by `pkg/log`'\n          - pkg: \"io/ioutil\"\n            desc: '`io/ioutil` package is deprecated, use the `io` and `os` package instead'\n          # TODO: Prevent using these without a reason\n          # - pkg: \"reflect\"\n          #   desc: '`reflect` package is dangerous to use'\n          # - pkg: \"unsafe\"\n          #   desc: '`unsafe` package is dangerous to use'\n\n  errcheck:\n    check-type-assertions: true\n    check-blank: true\n    disable-default-exclusions: true\n    exclude-functions:\n      - '(*bytes.Buffer).Write' # always returns nil error\n      - '(*github.com/valyala/bytebufferpool.ByteBuffer).Write' # always returns nil error\n      - '(*github.com/valyala/bytebufferpool.ByteBuffer).WriteByte' # always returns nil error\n      - '(*github.com/valyala/bytebufferpool.ByteBuffer).WriteString' # always returns nil error\n\n  errchkjson:\n    report-no-exported: true\n\n  exhaustive:\n    check-generated: true\n    default-signifies-exhaustive: true\n\n  forbidigo:\n    forbid:\n      - ^print(ln)?$\n      - ^fmt\\.Print(f|ln)?$\n      - ^http\\.Default(Client|ServeMux|Transport)$\n      # TODO: Eventually enable these patterns\n      # - ^panic$\n      # - ^time\\.Sleep$\n    analyze-types: true\n\n  gci:\n    sections:\n      - standard\n      - prefix(github.com/gofiber/fiber)\n      - default\n      - blank\n      - dot\n      # - alias\n    custom-order: true\n\n  goconst:\n    numbers: true\n\n  gocritic:\n    # TODO: Uncomment the following lines\n    enabled-tags:\n      - diagnostic\n    #   - style\n    #   - performance\n    #   - experimental\n    #   - opinionated\n    settings:\n      captLocal:\n        paramsOnly: false\n      elseif:\n        skipBalanced: false\n      underef:\n        skipRecvDeref: false\n      # NOTE: Set this option to false if other projects rely on this project's code\n      # unnamedResult:\n        # checkExported: false\n\n  gofumpt:\n    module-path: github.com/gofiber/fiber\n    extra-rules: true\n\n  gosec:\n    excludes:\n      - G104 # TODO: Enable this again. Mostly provided by errcheck\n    config:\n      global:\n        # show-ignored: true # TODO: Enable this\n        audit: true\n\n  govet:\n    enable-all: true\n    disable:\n      - shadow\n\n  grouper:\n    # const-require-grouping: true # TODO: Enable this\n    import-require-single-import: true\n    import-require-grouping: true\n    # var-require-grouping: true # TODO: Conflicts with gofumpt\n\n  loggercheck:\n    require-string-key: true\n    no-printf-like: true\n\n  misspell:\n    locale: US\n\n  nolintlint:\n    require-explanation: true\n    require-specific: true\n\n  nonamedreturns:\n    report-error-in-defer: true\n\n  perfsprint:\n    err-error: true\n\n  predeclared:\n    q: true\n\n  promlinter:\n    strict: true\n\n  # TODO: Enable this\n  # reassign:\n    # patterns:\n      # - '.*'\n\n  revive:\n    enable-all-rules: true\n    rules:\n      # Provided by gomnd linter\n      - name: add-constant\n        disabled: true\n      - name: argument-limit\n        disabled: true\n      # Provided by bidichk\n      - name: banned-characters\n        disabled: true\n      - name: cognitive-complexity\n        disabled: true\n      - name: comment-spacings\n        arguments:\n          - nolint\n        disabled: true # TODO: Do not disable\n      - name: cyclomatic\n        disabled: true\n      # TODO: Enable this check. Currently disabled due to upstream bug.\n      # - name: enforce-repeated-arg-type-style\n      #   arguments:\n      #     - short\n      - name: enforce-slice-style\n        arguments:\n          - make\n        disabled: true # TODO: Do not disable\n      - name: exported\n        disabled: true\n      - name: file-header\n        disabled: true\n      - name: function-result-limit\n        arguments: [3]\n      - name: function-length\n        disabled: true\n      - name: line-length-limit\n        disabled: true\n      - name: max-public-structs\n        disabled: true\n      - name: modifies-parameter\n        disabled: true\n      - name: nested-structs\n        disabled: true # TODO: Do not disable\n      - name: package-comments\n        disabled: true\n      - name: optimize-operands-order\n        disabled: true\n      - name: unchecked-type-assertion\n        disabled: true # TODO: Do not disable\n      - name: unhandled-error\n        arguments: ['bytes\\.Buffer\\.Write']\n\n  stylecheck:\n    checks:\n      - all\n      - -ST1000\n      - -ST1020\n      - -ST1021\n      - -ST1022\n\n  tagalign:\n    strict: true\n\n  tagliatelle:\n    case:\n      rules:\n        json: snake\n\n  tenv:\n    all: true\n\n  testifylint:\n    enable-all: true\n\n  testpackage:\n    skip-regexp: \"^$\"\n\n  unparam:\n    # NOTE: Set this option to false if other projects rely on this project's code\n    check-exported: false\n\n  unused:\n    # TODO: Uncomment these two lines\n    # parameters-are-used: false\n    # local-variables-are-used: false\n    # NOTE: Set these options to true if other projects rely on this project's code\n    field-writes-are-uses: true\n    # exported-is-used: true # TODO: Fix issues with this option (upstream)\n    exported-fields-are-used: true\n\n  usestdlibvars:\n    http-method: true\n    http-status-code: true\n    time-weekday: false # TODO: Set to true\n    time-month: false # TODO: Set to true\n    time-layout: false # TODO: Set to true\n    crypto-hash: true\n    default-rpc-path: true\n    sql-isolation-level: true\n    tls-signature-scheme: true\n    constant-kind: true\n\n  wrapcheck:\n    ignorePackageGlobs:\n      - github.com/gofiber/fiber/*\n      - github.com/valyala/fasthttp\n\nissues:\n  exclude-use-default: false\n  exclude-case-sensitive: true\n  max-issues-per-linter: 0\n  max-same-issues: 0\n  exclude-dirs:\n    - internal # TODO: Do not ignore interal packages\n  exclude-rules:\n    - linters:\n        - err113\n      text: 'do not define dynamic errors, use wrapped static errors instead*'\n    - path: log/.*\\.go\n      linters:\n        - depguard\n   # Exclude some linters from running on tests files.\n    - path: _test\\.go\n      linters:\n        - bodyclose\n        - err113\n  # fix: true\n\nlinters:\n  enable:\n    - asasalint\n    - asciicheck\n    - bidichk\n    - bodyclose\n    - containedctx\n    - contextcheck\n    # - cyclop\n    - decorder\n    - depguard\n    - dogsled\n    # - dupl\n    - dupword # TODO: Enable\n    - durationcheck\n    - errcheck\n    - errchkjson\n    - errname\n    - errorlint\n    - exhaustive\n    # - exhaustivestruct\n    # - exhaustruct\n    - copyloopvar\n    - forbidigo\n    - forcetypeassert\n    # - funlen\n    # - gci # TODO: Enable\n    - ginkgolinter\n    # - gocheckcompilerdirectives # TODO: Enable\n    # - gochecknoglobals # TODO: Enable\n    # - gochecknoinits # TODO: Enable\n    - gochecksumtype\n    # - gocognit\n    - goconst # TODO: Enable\n    - gocritic\n    # - gocyclo\n    # - godot\n    # - godox\n    - err113\n    - gofmt\n    - gofumpt\n    # - goheader\n    - goimports\n    # - mnd # TODO: Enable\n    - gomoddirectives\n    # - gomodguard\n    - goprintffuncname\n    - gosec\n    - gosimple\n    # - gosmopolitan # TODO: Enable\n    - govet\n    - grouper\n    # - ifshort # TODO: Enable\n    # - importas\n    # - inamedparam\n    - ineffassign\n    # - interfacebloat\n    # - interfacer\n    # - ireturn\n    # - lll\n    - loggercheck\n    # - maintidx\n    - makezero\n    # - maligned\n    - mirror\n    - misspell\n    - musttag\n    - nakedret\n    # - nestif\n    - nilerr\n    - nilnil\n    # - nlreturn\n    - noctx\n    - nolintlint\n    - nonamedreturns\n    - nosprintfhostport\n    # - paralleltest # TODO: Enable\n    - perfsprint\n    # - prealloc\n    - predeclared\n    - promlinter\n    - protogetter\n    - reassign\n    - revive\n    - rowserrcheck\n    # - scopelint # TODO: Enable\n    - sloglint\n    - spancheck\n    - sqlclosecheck\n    - staticcheck\n    - stylecheck\n    # - tagalign # TODO: Enable\n    - tagliatelle\n    - tenv\n    - testableexamples\n    - testifylint\n    # - testpackage # TODO: Enable\n    - thelper\n    - tparallel\n    - typecheck\n    - unconvert\n    - unparam\n    - unused\n    - usestdlibvars\n    # - varnamelen\n    # - wastedassign # TODO: Enable\n    - whitespace\n    - wrapcheck\n    # - wsl\n    - zerologlint\n"
        },
        {
          "name": ".markdownlint.yml",
          "type": "blob",
          "size": 9.48,
          "content": "# Example markdownlint configuration with all properties set to their default value\n\n# Default state for all rules\ndefault: true\n\n# Path to configuration file to extend\nextends: null\n\n# MD001/heading-increment : Heading levels should only increment by one level at a time : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md001.md\nMD001: true\n\n# MD003/heading-style : Heading style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md003.md\nMD003:\n  # Heading style\n  style: \"consistent\"\n\n# MD004/ul-style : Unordered list style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md004.md\nMD004:\n  # List style\n  style: \"consistent\"\n\n# MD005/list-indent : Inconsistent indentation for list items at the same level : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md005.md\nMD005: true\n\n# MD007/ul-indent : Unordered list indentation : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md007.md\nMD007:\n  # Spaces for indent\n  indent: \n  # Whether to indent the first level of the list\n  start_indented: false\n  # Spaces for first level indent (when start_indented is set)\n  start_indent: 2\n\n# MD009/no-trailing-spaces : Trailing spaces : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md009.md\nMD009:\n  # Spaces for line break\n  br_spaces: 2\n  # Allow spaces for empty lines in list items\n  list_item_empty_lines: false\n  # Include unnecessary breaks\n  strict: true\n\n# MD010/no-hard-tabs : Hard tabs : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md010.md\nMD010:\n  # Include code blocks\n  code_blocks: true\n  # Fenced code languages to ignore\n  ignore_code_languages: []\n  # Number of spaces for each hard tab\n  spaces_per_tab: 4\n\n# MD011/no-reversed-links : Reversed link syntax : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md011.md\nMD011: true\n\n# MD012/no-multiple-blanks : Multiple consecutive blank lines : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md012.md\nMD012:\n  # Consecutive blank lines\n  maximum: 1\n\n# MD013/line-length : Line length : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md013.md\nMD013: false\n\n# MD014/commands-show-output : Dollar signs used before commands without showing output : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md014.md\nMD014: true\n\n# MD018/no-missing-space-atx : No space after hash on atx style heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md018.md\nMD018: true\n\n# MD019/no-multiple-space-atx : Multiple spaces after hash on atx style heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md019.md\nMD019: true\n\n# MD020/no-missing-space-closed-atx : No space inside hashes on closed atx style heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md020.md\nMD020: true\n\n# MD021/no-multiple-space-closed-atx : Multiple spaces inside hashes on closed atx style heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md021.md\nMD021: true\n\n# MD022/blanks-around-headings : Headings should be surrounded by blank lines : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md022.md\nMD022:\n  # Blank lines above heading\n  lines_above: 1\n  # Blank lines below heading\n  lines_below: 1\n\n# MD023/heading-start-left : Headings must start at the beginning of the line : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md023.md\nMD023: true\n\n# MD024/no-duplicate-heading : Multiple headings with the same content : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md024.md\nMD024: false\n\n# MD025/single-title/single-h1 : Multiple top-level headings in the same document : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md025.md\nMD025:\n  # Heading level\n  level: 1\n  # RegExp for matching title in front matter\n  front_matter_title: \"^\\\\s*title\\\\s*[:=]\"\n\n# MD026/no-trailing-punctuation : Trailing punctuation in heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md026.md\nMD026:\n  # Punctuation characters\n  punctuation: \".,;:!。，；：！\"\n\n# MD027/no-multiple-space-blockquote : Multiple spaces after blockquote symbol : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md027.md\nMD027: true\n\n# MD028/no-blanks-blockquote : Blank line inside blockquote : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md028.md\nMD028: true\n\n# MD029/ol-prefix : Ordered list item prefix : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md029.md\nMD029:\n  # List style\n  style: \"one_or_ordered\"\n\n# MD030/list-marker-space : Spaces after list markers : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md030.md\nMD030:\n  # Spaces for single-line unordered list items\n  ul_single: 1\n  # Spaces for single-line ordered list items\n  ol_single: 1\n  # Spaces for multi-line unordered list items\n  ul_multi: 1\n  # Spaces for multi-line ordered list items\n  ol_multi: 1\n\n# MD031/blanks-around-fences : Fenced code blocks should be surrounded by blank lines : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md031.md\nMD031:\n  # Include list items\n  list_items: true\n\n# MD032/blanks-around-lists : Lists should be surrounded by blank lines : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md032.md\nMD032: true\n\n# MD033/no-inline-html : Inline HTML : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md033.md\nMD033: false\n\n# MD034/no-bare-urls : Bare URL used : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md034.md\nMD034: true\n\n# MD035/hr-style : Horizontal rule style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md035.md\nMD035:\n  # Horizontal rule style\n  style: \"consistent\"\n\n# MD036/no-emphasis-as-heading : Emphasis used instead of a heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md036.md\nMD036:\n  # Punctuation characters\n  punctuation: \".,;:!?。，；：！？\"\n\n# MD037/no-space-in-emphasis : Spaces inside emphasis markers : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md037.md\nMD037: true\n\n# MD038/no-space-in-code : Spaces inside code span elements : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md038.md\nMD038: true\n\n# MD039/no-space-in-links : Spaces inside link text : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md039.md\nMD039: true\n\n# MD040/fenced-code-language : Fenced code blocks should have a language specified : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md040.md\nMD040:\n  # List of languages\n  allowed_languages: []\n  # Require language only\n  language_only: false\n\n# MD041/first-line-heading/first-line-h1 : First line in a file should be a top-level heading : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md041.md\nMD041:\n  # Heading level\n  level: 1\n  # RegExp for matching title in front matter\n  front_matter_title: \"^\\\\s*title\\\\s*[:=]\"\n\n# MD042/no-empty-links : No empty links : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md042.md\nMD042: true\n\n# MD043/required-headings : Required heading structure : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md043.md\nMD043: false\n\n# MD044/proper-names : Proper names should have the correct capitalization : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md044.md\nMD044:\n  # List of proper names\n  names: []\n  # Include code blocks\n  code_blocks: true\n  # Include HTML elements\n  html_elements: true\n\n# MD045/no-alt-text : Images should have alternate text (alt text) : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md045.md\nMD045: false\n\n# MD046/code-block-style : Code block style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md046.md\nMD046:\n  # Block style\n  style: \"fenced\"\n\n# MD047/single-trailing-newline : Files should end with a single newline character : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md047.md\nMD047: true\n\n# MD048/code-fence-style : Code fence style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md048.md\nMD048:\n  # Code fence style\n  style: \"backtick\"\n\n# MD049/emphasis-style : Emphasis style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md049.md\nMD049:\n  # Emphasis style\n  style: \"consistent\"\n\n# MD050/strong-style : Strong style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md050.md\nMD050:\n  # Strong style\n  style: \"consistent\"\n\n# MD051/link-fragments : Link fragments should be valid : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md051.md\nMD051: true\n\n# MD052/reference-links-images : Reference links and images should use a label that is defined : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md052.md\nMD052:\n  # Include shortcut syntax\n  shortcut_syntax: false\n\n# MD053/link-image-reference-definitions : Link and image reference definitions should be needed : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md053.md\nMD053:\n  # Ignored definitions\n  ignored_definitions:\n    - \"//\"\n\n# MD054/link-image-style : Link and image style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md054.md\nMD054:\n  # Allow autolinks\n  autolink: false\n  # Allow inline links and images\n  inline: true\n  # Allow full reference links and images\n  full: true\n  # Allow collapsed reference links and images\n  collapsed: true\n  # Allow shortcut reference links and images\n  shortcut: true\n  # Allow URLs as inline links\n  url_inline: true\n\n# MD055/table-pipe-style : Table pipe style : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md055.md\nMD055:\n  # Table pipe style\n  style: \"consistent\"\n\n# MD056/table-column-count : Table column count : https://github.com/DavidAnson/markdownlint/blob/v0.34.0/doc/md056.md\nMD056: true\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.08,
          "content": "MIT License\r\n\r\nCopyright (c) 2019-present Fenny and Contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.82,
          "content": "## help: 💡 Display available commands\n.PHONY: help\nhelp:\n\t@echo '⚡️ GoFiber/Fiber Development:'\n\t@sed -n 's/^##//p' ${MAKEFILE_LIST} | column -t -s ':' |  sed -e 's/^/ /'\n\n## audit: 🚀 Conduct quality checks\n.PHONY: audit\naudit:\n\tgo mod verify\n\tgo vet ./...\n\tgo run golang.org/x/vuln/cmd/govulncheck@latest ./...\n\n## benchmark: 📈 Benchmark code performance\n.PHONY: benchmark\nbenchmark:\n\tgo test ./... -benchmem -bench=. -run=^Benchmark_$\n\n## coverage: ☂️  Generate coverage report\n.PHONY: coverage\ncoverage:\n\tgo run gotest.tools/gotestsum@latest -f testname -- ./... -race -count=1 -coverprofile=/tmp/coverage.out -covermode=atomic\n\tgo tool cover -html=/tmp/coverage.out\n\n## format: 🎨 Fix code format issues\n.PHONY: format\nformat:\n\tgo run mvdan.cc/gofumpt@latest -w -l .\n\n## markdown: 🎨 Find markdown format issues (Requires markdownlint-cli2)\n.PHONY: markdown\nmarkdown:\n\tmarkdownlint-cli2 \"**/*.md\" \"#vendor\"\n\n## lint: 🚨 Run lint checks\n.PHONY: lint\nlint:\n\tgo run github.com/golangci/golangci-lint/cmd/golangci-lint@v1.62.2 run ./...\n\n## test: 🚦 Execute all tests\n.PHONY: test\ntest:\n\tgo run gotest.tools/gotestsum@latest -f testname -- ./... -race -count=1 -shuffle=on\n\n## longtest: 🚦 Execute all tests 10x\n.PHONY: longtest\nlongtest:\n\tgo run gotest.tools/gotestsum@latest -f testname -- ./... -race -count=15 -shuffle=on\n\n## tidy: 📌 Clean and tidy dependencies\n.PHONY: tidy\ntidy:\n\tgo mod tidy -v\n\n## betteralign: 📐 Optimize alignment of fields in structs\n.PHONY: betteralign\nbetteralign:\n\tgo run github.com/dkorunic/betteralign/cmd/betteralign@latest -test_files -generated_files -apply ./...\n\n## generate: ⚡️ Generate msgp && interface implementations\n.PHONY: generate\ngenerate:\n\tgo install github.com/tinylib/msgp@latest\n\tgo install github.com/vburenin/ifacemaker@975a95966976eeb2d4365a7fb236e274c54da64c\n\tgo generate ./...\n"
        },
        {
          "name": "addon",
          "type": "tree",
          "content": null
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 36.47,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\n// Package fiber is an Express inspired web framework built on top of Fasthttp,\n// the fastest HTTP engine for Go. Designed to ease things up for fast\n// development with zero memory allocation and performance in mind.\npackage fiber\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/gofiber/fiber/v3/log\"\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// Version of current fiber package\nconst Version = \"3.0.0-beta.4\"\n\n// Handler defines a function to serve HTTP requests.\ntype Handler = func(Ctx) error\n\n// Map is a shortcut for map[string]any, useful for JSON returns\ntype Map map[string]any\n\n// Storage interface for communicating with different database/key-value\n// providers\ntype Storage interface {\n\t// Get gets the value for the given key.\n\t// `nil, nil` is returned when the key does not exist\n\tGet(key string) ([]byte, error)\n\n\t// Set stores the given value for the given key along\n\t// with an expiration value, 0 means no expiration.\n\t// Empty key or value will be ignored without an error.\n\tSet(key string, val []byte, exp time.Duration) error\n\n\t// Delete deletes the value for the given key.\n\t// It returns no error if the storage does not contain the key,\n\tDelete(key string) error\n\n\t// Reset resets the storage and delete all keys.\n\tReset() error\n\n\t// Close closes the storage and will stop any running garbage\n\t// collectors and open connections.\n\tClose() error\n}\n\n// ErrorHandler defines a function that will process all errors\n// returned from any handlers in the stack\n//\n//\tcfg := fiber.Config{}\n//\tcfg.ErrorHandler = func(c Ctx, err error) error {\n//\t code := StatusInternalServerError\n//\t var e *fiber.Error\n//\t if errors.As(err, &e) {\n//\t   code = e.Code\n//\t }\n//\t c.Set(HeaderContentType, MIMETextPlainCharsetUTF8)\n//\t return c.Status(code).SendString(err.Error())\n//\t}\n//\tapp := fiber.New(cfg)\ntype ErrorHandler = func(Ctx, error) error\n\n// Error represents an error that occurred while handling a request.\ntype Error struct {\n\tMessage string `json:\"message\"`\n\tCode    int    `json:\"code\"`\n}\n\n// App denotes the Fiber application.\ntype App struct {\n\t// Ctx pool\n\tpool sync.Pool\n\t// Fasthttp server\n\tserver *fasthttp.Server\n\t// Converts string to a byte slice\n\tgetBytes func(s string) (b []byte)\n\t// Converts byte slice to a string\n\tgetString func(b []byte) string\n\t// Hooks\n\thooks *Hooks\n\t// Latest route & group\n\tlatestRoute *Route\n\t// newCtxFunc\n\tnewCtxFunc func(app *App) CustomCtx\n\t// TLS handler\n\ttlsHandler *TLSHandler\n\t// Mount fields\n\tmountFields *mountFields\n\t// Route stack divided by HTTP methods\n\tstack [][]*Route\n\t// Route stack divided by HTTP methods and route prefixes\n\ttreeStack []map[string][]*Route\n\t// custom binders\n\tcustomBinders []CustomBinder\n\t// customConstraints is a list of external constraints\n\tcustomConstraints []CustomConstraint\n\t// sendfiles stores configurations for handling ctx.SendFile operations\n\tsendfiles []*sendFileStore\n\t// App config\n\tconfig Config\n\t// Indicates if the value was explicitly configured\n\tconfigured Config\n\t// sendfilesMutex is a mutex used for sendfile operations\n\tsendfilesMutex sync.RWMutex\n\tmutex          sync.Mutex\n\t// Amount of registered routes\n\troutesCount uint32\n\t// Amount of registered handlers\n\thandlersCount uint32\n\t// contains the information if the route stack has been changed to build the optimized tree\n\troutesRefreshed bool\n}\n\n// Config is a struct holding the server settings.\ntype Config struct { //nolint:govet // Aligning the struct fields is not necessary. betteralign:ignore\n\t// Enables the \"Server: value\" HTTP header.\n\t//\n\t// Default: \"\"\n\tServerHeader string `json:\"server_header\"`\n\n\t// When set to true, the router treats \"/foo\" and \"/foo/\" as different.\n\t// By default this is disabled and both \"/foo\" and \"/foo/\" will execute the same handler.\n\t//\n\t// Default: false\n\tStrictRouting bool `json:\"strict_routing\"`\n\n\t// When set to true, enables case-sensitive routing.\n\t// E.g. \"/FoO\" and \"/foo\" are treated as different routes.\n\t// By default this is disabled and both \"/FoO\" and \"/foo\" will execute the same handler.\n\t//\n\t// Default: false\n\tCaseSensitive bool `json:\"case_sensitive\"`\n\n\t// When set to true, this relinquishes the 0-allocation promise in certain\n\t// cases in order to access the handler values (e.g. request bodies) in an\n\t// immutable fashion so that these values are available even if you return\n\t// from handler.\n\t//\n\t// Default: false\n\tImmutable bool `json:\"immutable\"`\n\n\t// When set to true, converts all encoded characters in the route back\n\t// before setting the path for the context, so that the routing,\n\t// the returning of the current url from the context `ctx.Path()`\n\t// and the parameters `ctx.Params(%key%)` with decoded characters will work\n\t//\n\t// Default: false\n\tUnescapePath bool `json:\"unescape_path\"`\n\n\t// Max body size that the server accepts.\n\t// -1 will decline any body size\n\t//\n\t// Default: 4 * 1024 * 1024\n\tBodyLimit int `json:\"body_limit\"`\n\n\t// Maximum number of concurrent connections.\n\t//\n\t// Default: 256 * 1024\n\tConcurrency int `json:\"concurrency\"`\n\n\t// Views is the interface that wraps the Render function.\n\t//\n\t// Default: nil\n\tViews Views `json:\"-\"`\n\n\t// Views Layout is the global layout for all template render until override on Render function.\n\t//\n\t// Default: \"\"\n\tViewsLayout string `json:\"views_layout\"`\n\n\t// PassLocalsToViews Enables passing of the locals set on a fiber.Ctx to the template engine\n\t//\n\t// Default: false\n\tPassLocalsToViews bool `json:\"pass_locals_to_views\"`\n\n\t// The amount of time allowed to read the full request including body.\n\t// It is reset after the request handler has returned.\n\t// The connection's read deadline is reset when the connection opens.\n\t//\n\t// Default: unlimited\n\tReadTimeout time.Duration `json:\"read_timeout\"`\n\n\t// The maximum duration before timing out writes of the response.\n\t// It is reset after the request handler has returned.\n\t//\n\t// Default: unlimited\n\tWriteTimeout time.Duration `json:\"write_timeout\"`\n\n\t// The maximum amount of time to wait for the next request when keep-alive is enabled.\n\t// If IdleTimeout is zero, the value of ReadTimeout is used.\n\t//\n\t// Default: unlimited\n\tIdleTimeout time.Duration `json:\"idle_timeout\"`\n\n\t// Per-connection buffer size for requests' reading.\n\t// This also limits the maximum header size.\n\t// Increase this buffer if your clients send multi-KB RequestURIs\n\t// and/or multi-KB headers (for example, BIG cookies).\n\t//\n\t// Default: 4096\n\tReadBufferSize int `json:\"read_buffer_size\"`\n\n\t// Per-connection buffer size for responses' writing.\n\t//\n\t// Default: 4096\n\tWriteBufferSize int `json:\"write_buffer_size\"`\n\n\t// CompressedFileSuffixes adds suffix to the original file name and\n\t// tries saving the resulting compressed file under the new file name.\n\t//\n\t// Default: map[string]string{\"gzip\": \".fiber.gz\", \"br\": \".fiber.br\", \"zstd\": \".fiber.zst\"}\n\tCompressedFileSuffixes map[string]string `json:\"compressed_file_suffixes\"`\n\n\t// ProxyHeader will enable c.IP() to return the value of the given header key\n\t// By default c.IP() will return the Remote IP from the TCP connection\n\t// This property can be useful if you are behind a load balancer: X-Forwarded-*\n\t// NOTE: headers are easily spoofed and the detected IP addresses are unreliable.\n\t//\n\t// Default: \"\"\n\tProxyHeader string `json:\"proxy_header\"`\n\n\t// GETOnly rejects all non-GET requests if set to true.\n\t// This option is useful as anti-DoS protection for servers\n\t// accepting only GET requests. The request size is limited\n\t// by ReadBufferSize if GETOnly is set.\n\t//\n\t// Default: false\n\tGETOnly bool `json:\"get_only\"`\n\n\t// ErrorHandler is executed when an error is returned from fiber.Handler.\n\t//\n\t// Default: DefaultErrorHandler\n\tErrorHandler ErrorHandler `json:\"-\"`\n\n\t// When set to true, disables keep-alive connections.\n\t// The server will close incoming connections after sending the first response to client.\n\t//\n\t// Default: false\n\tDisableKeepalive bool `json:\"disable_keepalive\"`\n\n\t// When set to true, causes the default date header to be excluded from the response.\n\t//\n\t// Default: false\n\tDisableDefaultDate bool `json:\"disable_default_date\"`\n\n\t// When set to true, causes the default Content-Type header to be excluded from the response.\n\t//\n\t// Default: false\n\tDisableDefaultContentType bool `json:\"disable_default_content_type\"`\n\n\t// When set to true, disables header normalization.\n\t// By default all header names are normalized: conteNT-tYPE -> Content-Type.\n\t//\n\t// Default: false\n\tDisableHeaderNormalizing bool `json:\"disable_header_normalizing\"`\n\n\t// This function allows to setup app name for the app\n\t//\n\t// Default: nil\n\tAppName string `json:\"app_name\"`\n\n\t// StreamRequestBody enables request body streaming,\n\t// and calls the handler sooner when given body is\n\t// larger than the current limit.\n\t//\n\t// Default: false\n\tStreamRequestBody bool\n\n\t// Will not pre parse Multipart Form data if set to true.\n\t//\n\t// This option is useful for servers that desire to treat\n\t// multipart form data as a binary blob, or choose when to parse the data.\n\t//\n\t// Server pre parses multipart form data by default.\n\t//\n\t// Default: false\n\tDisablePreParseMultipartForm bool\n\n\t// Aggressively reduces memory usage at the cost of higher CPU usage\n\t// if set to true.\n\t//\n\t// Try enabling this option only if the server consumes too much memory\n\t// serving mostly idle keep-alive connections. This may reduce memory\n\t// usage by more than 50%.\n\t//\n\t// Default: false\n\tReduceMemoryUsage bool `json:\"reduce_memory_usage\"`\n\n\t// When set by an external client of Fiber it will use the provided implementation of a\n\t// JSONMarshal\n\t//\n\t// Allowing for flexibility in using another json library for encoding\n\t// Default: json.Marshal\n\tJSONEncoder utils.JSONMarshal `json:\"-\"`\n\n\t// When set by an external client of Fiber it will use the provided implementation of a\n\t// JSONUnmarshal\n\t//\n\t// Allowing for flexibility in using another json library for decoding\n\t// Default: json.Unmarshal\n\tJSONDecoder utils.JSONUnmarshal `json:\"-\"`\n\n\t// When set by an external client of Fiber it will use the provided implementation of a\n\t// CBORMarshal\n\t//\n\t// Allowing for flexibility in using another cbor library for encoding\n\t// Default: cbor.Marshal\n\tCBOREncoder utils.CBORMarshal `json:\"-\"`\n\n\t// When set by an external client of Fiber it will use the provided implementation of a\n\t// CBORUnmarshal\n\t//\n\t// Allowing for flexibility in using another cbor library for decoding\n\t// Default: cbor.Unmarshal\n\tCBORDecoder utils.CBORUnmarshal `json:\"-\"`\n\n\t// XMLEncoder set by an external client of Fiber it will use the provided implementation of a\n\t// XMLMarshal\n\t//\n\t// Allowing for flexibility in using another XML library for encoding\n\t// Default: xml.Marshal\n\tXMLEncoder utils.XMLMarshal `json:\"-\"`\n\n\t// XMLDecoder set by an external client of Fiber it will use the provided implementation of a\n\t// XMLUnmarshal\n\t//\n\t// Allowing for flexibility in using another XML library for decoding\n\t// Default: xml.Unmarshal\n\tXMLDecoder utils.XMLUnmarshal `json:\"-\"`\n\n\t// If you find yourself behind some sort of proxy, like a load balancer,\n\t// then certain header information may be sent to you using special X-Forwarded-* headers or the Forwarded header.\n\t// For example, the Host HTTP header is usually used to return the requested host.\n\t// But when you’re behind a proxy, the actual host may be stored in an X-Forwarded-Host header.\n\t//\n\t// If you are behind a proxy, you should enable TrustProxy to prevent header spoofing.\n\t// If you enable TrustProxy and do not provide a TrustProxyConfig, Fiber will skip\n\t// all headers that could be spoofed.\n\t// If the request IP is in the TrustProxyConfig.Proxies allowlist, then:\n\t//   1. c.Scheme() get value from X-Forwarded-Proto, X-Forwarded-Protocol, X-Forwarded-Ssl or X-Url-Scheme header\n\t//   2. c.IP() get value from ProxyHeader header.\n\t//   3. c.Host() and c.Hostname() get value from X-Forwarded-Host header\n\t// But if the request IP is NOT in the TrustProxyConfig.Proxies allowlist, then:\n\t//   1. c.Scheme() WON'T get value from X-Forwarded-Proto, X-Forwarded-Protocol, X-Forwarded-Ssl or X-Url-Scheme header,\n\t//    will return https when a TLS connection is handled by the app, or http otherwise.\n\t//   2. c.IP() WON'T get value from ProxyHeader header, will return RemoteIP() from fasthttp context\n\t//   3. c.Host() and c.Hostname() WON'T get value from X-Forwarded-Host header, fasthttp.Request.URI().Host()\n\t//    will be used to get the hostname.\n\t//\n\t// To automatically trust all loopback, link-local, or private IP addresses,\n\t// without manually adding them to the TrustProxyConfig.Proxies allowlist,\n\t// you can set TrustProxyConfig.Loopback, TrustProxyConfig.LinkLocal, or TrustProxyConfig.Private to true.\n\t//\n\t// Default: false\n\tTrustProxy bool `json:\"trust_proxy\"`\n\n\t// Read TrustProxy doc.\n\t//\n\t// Default: DefaultTrustProxyConfig\n\tTrustProxyConfig TrustProxyConfig `json:\"trust_proxy_config\"`\n\n\t// If set to true, c.IP() and c.IPs() will validate IP addresses before returning them.\n\t// Also, c.IP() will return only the first valid IP rather than just the raw header\n\t// WARNING: this has a performance cost associated with it.\n\t//\n\t// Default: false\n\tEnableIPValidation bool `json:\"enable_ip_validation\"`\n\n\t// You can define custom color scheme. They'll be used for startup message, route list and some middlewares.\n\t//\n\t// Optional. Default: DefaultColors\n\tColorScheme Colors `json:\"color_scheme\"`\n\n\t// If you want to validate header/form/query... automatically when to bind, you can define struct validator.\n\t// Fiber doesn't have default validator, so it'll skip validator step if you don't use any validator.\n\t//\n\t// Default: nil\n\tStructValidator StructValidator\n\n\t// RequestMethods provides customizability for HTTP methods. You can add/remove methods as you wish.\n\t//\n\t// Optional. Default: DefaultMethods\n\tRequestMethods []string\n\n\t// EnableSplittingOnParsers splits the query/body/header parameters by comma when it's true.\n\t// For example, you can use it to parse multiple values from a query parameter like this:\n\t//   /api?foo=bar,baz == foo[]=bar&foo[]=baz\n\t//\n\t// Optional. Default: false\n\tEnableSplittingOnParsers bool `json:\"enable_splitting_on_parsers\"`\n}\n\n// Default TrustProxyConfig\nvar DefaultTrustProxyConfig = TrustProxyConfig{}\n\n// TrustProxyConfig is a struct for configuring trusted proxies if Config.TrustProxy is true.\ntype TrustProxyConfig struct {\n\tips map[string]struct{}\n\n\t// Proxies is a list of trusted proxy IP addresses or CIDR ranges.\n\t//\n\t// Default: []string\n\tProxies []string `json:\"proxies\"`\n\n\tranges []*net.IPNet\n\n\t// LinkLocal enables trusting all link-local IP ranges (e.g., 169.254.0.0/16, fe80::/10).\n\t//\n\t// Default: false\n\tLinkLocal bool `json:\"link_local\"`\n\n\t// Loopback enables trusting all loopback IP ranges (e.g., 127.0.0.0/8, ::1/128).\n\t//\n\t// Default: false\n\tLoopback bool `json:\"loopback\"`\n\n\t// Private enables trusting all private IP ranges (e.g., 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7).\n\t//\n\t// Default: false\n\tPrivate bool `json:\"private\"`\n}\n\n// RouteMessage is some message need to be print when server starts\ntype RouteMessage struct {\n\tname     string\n\tmethod   string\n\tpath     string\n\thandlers string\n}\n\n// Default Config values\nconst (\n\tDefaultBodyLimit       = 4 * 1024 * 1024\n\tDefaultConcurrency     = 256 * 1024\n\tDefaultReadBufferSize  = 4096\n\tDefaultWriteBufferSize = 4096\n)\n\n// HTTP methods enabled by default\nvar DefaultMethods = []string{\n\tMethodGet,\n\tMethodHead,\n\tMethodPost,\n\tMethodPut,\n\tMethodDelete,\n\tMethodConnect,\n\tMethodOptions,\n\tMethodTrace,\n\tMethodPatch,\n}\n\n// DefaultErrorHandler that process return errors from handlers\nfunc DefaultErrorHandler(c Ctx, err error) error {\n\tcode := StatusInternalServerError\n\tvar e *Error\n\tif errors.As(err, &e) {\n\t\tcode = e.Code\n\t}\n\tc.Set(HeaderContentType, MIMETextPlainCharsetUTF8)\n\treturn c.Status(code).SendString(err.Error())\n}\n\n// New creates a new Fiber named instance.\n//\n//\tapp := fiber.New()\n//\n// You can pass optional configuration options by passing a Config struct:\n//\n//\tapp := fiber.New(fiber.Config{\n//\t    Prefork: true,\n//\t    ServerHeader: \"Fiber\",\n//\t})\nfunc New(config ...Config) *App {\n\t// Create a new app\n\tapp := &App{\n\t\t// Create config\n\t\tconfig:        Config{},\n\t\tgetBytes:      utils.UnsafeBytes,\n\t\tgetString:     utils.UnsafeString,\n\t\tlatestRoute:   &Route{},\n\t\tcustomBinders: []CustomBinder{},\n\t\tsendfiles:     []*sendFileStore{},\n\t}\n\n\t// Create Ctx pool\n\tapp.pool = sync.Pool{\n\t\tNew: func() any {\n\t\t\treturn app.newCtx()\n\t\t},\n\t}\n\n\t// Define hooks\n\tapp.hooks = newHooks(app)\n\n\t// Define mountFields\n\tapp.mountFields = newMountFields(app)\n\n\t// Override config if provided\n\tif len(config) > 0 {\n\t\tapp.config = config[0]\n\t}\n\n\t// Initialize configured before defaults are set\n\tapp.configured = app.config\n\n\t// Override default values\n\tif app.config.BodyLimit == 0 {\n\t\tapp.config.BodyLimit = DefaultBodyLimit\n\t}\n\tif app.config.Concurrency <= 0 {\n\t\tapp.config.Concurrency = DefaultConcurrency\n\t}\n\tif app.config.ReadBufferSize <= 0 {\n\t\tapp.config.ReadBufferSize = DefaultReadBufferSize\n\t}\n\tif app.config.WriteBufferSize <= 0 {\n\t\tapp.config.WriteBufferSize = DefaultWriteBufferSize\n\t}\n\tif app.config.CompressedFileSuffixes == nil {\n\t\tapp.config.CompressedFileSuffixes = map[string]string{\n\t\t\t\"gzip\": \".fiber.gz\",\n\t\t\t\"br\":   \".fiber.br\",\n\t\t\t\"zstd\": \".fiber.zst\",\n\t\t}\n\t}\n\n\tif app.config.Immutable {\n\t\tapp.getBytes, app.getString = getBytesImmutable, getStringImmutable\n\t}\n\n\tif app.config.ErrorHandler == nil {\n\t\tapp.config.ErrorHandler = DefaultErrorHandler\n\t}\n\n\tif app.config.JSONEncoder == nil {\n\t\tapp.config.JSONEncoder = json.Marshal\n\t}\n\tif app.config.JSONDecoder == nil {\n\t\tapp.config.JSONDecoder = json.Unmarshal\n\t}\n\tif app.config.CBOREncoder == nil {\n\t\tapp.config.CBOREncoder = cbor.Marshal\n\t}\n\tif app.config.CBORDecoder == nil {\n\t\tapp.config.CBORDecoder = cbor.Unmarshal\n\t}\n\tif app.config.XMLEncoder == nil {\n\t\tapp.config.XMLEncoder = xml.Marshal\n\t}\n\tif app.config.XMLDecoder == nil {\n\t\tapp.config.XMLDecoder = xml.Unmarshal\n\t}\n\tif len(app.config.RequestMethods) == 0 {\n\t\tapp.config.RequestMethods = DefaultMethods\n\t}\n\n\tapp.config.TrustProxyConfig.ips = make(map[string]struct{}, len(app.config.TrustProxyConfig.Proxies))\n\tfor _, ipAddress := range app.config.TrustProxyConfig.Proxies {\n\t\tapp.handleTrustedProxy(ipAddress)\n\t}\n\n\t// Create router stack\n\tapp.stack = make([][]*Route, len(app.config.RequestMethods))\n\tapp.treeStack = make([]map[string][]*Route, len(app.config.RequestMethods))\n\n\t// Override colors\n\tapp.config.ColorScheme = defaultColors(app.config.ColorScheme)\n\n\t// Init app\n\tapp.init()\n\n\t// Return app\n\treturn app\n}\n\n// Adds an ip address to TrustProxyConfig.ranges or TrustProxyConfig.ips based on whether it is an IP range or not\nfunc (app *App) handleTrustedProxy(ipAddress string) {\n\tif strings.Contains(ipAddress, \"/\") {\n\t\t_, ipNet, err := net.ParseCIDR(ipAddress)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"IP range %q could not be parsed: %v\", ipAddress, err)\n\t\t} else {\n\t\t\tapp.config.TrustProxyConfig.ranges = append(app.config.TrustProxyConfig.ranges, ipNet)\n\t\t}\n\t} else {\n\t\tip := net.ParseIP(ipAddress)\n\t\tif ip == nil {\n\t\t\tlog.Warnf(\"IP address %q could not be parsed\", ipAddress)\n\t\t} else {\n\t\t\tapp.config.TrustProxyConfig.ips[ipAddress] = struct{}{}\n\t\t}\n\t}\n}\n\n// NewCtxFunc allows to customize ctx methods as we want.\n// Note: It doesn't allow adding new methods, only customizing exist methods.\nfunc (app *App) NewCtxFunc(function func(app *App) CustomCtx) {\n\tapp.newCtxFunc = function\n\n\tif app.server != nil {\n\t\tapp.server.Handler = app.customRequestHandler\n\t}\n}\n\n// RegisterCustomConstraint allows to register custom constraint.\nfunc (app *App) RegisterCustomConstraint(constraint CustomConstraint) {\n\tapp.customConstraints = append(app.customConstraints, constraint)\n}\n\n// RegisterCustomBinder Allows to register custom binders to use as Bind().Custom(\"name\").\n// They should be compatible with CustomBinder interface.\nfunc (app *App) RegisterCustomBinder(binder CustomBinder) {\n\tapp.customBinders = append(app.customBinders, binder)\n}\n\n// SetTLSHandler Can be used to set ClientHelloInfo when using TLS with Listener.\nfunc (app *App) SetTLSHandler(tlsHandler *TLSHandler) {\n\t// Attach the tlsHandler to the config\n\tapp.mutex.Lock()\n\tapp.tlsHandler = tlsHandler\n\tapp.mutex.Unlock()\n}\n\n// Name Assign name to specific route.\nfunc (app *App) Name(name string) Router {\n\tapp.mutex.Lock()\n\tdefer app.mutex.Unlock()\n\n\tfor _, routes := range app.stack {\n\t\tfor _, route := range routes {\n\t\t\tisMethodValid := route.Method == app.latestRoute.Method || app.latestRoute.use ||\n\t\t\t\t(app.latestRoute.Method == MethodGet && route.Method == MethodHead)\n\n\t\t\tif route.Path == app.latestRoute.Path && isMethodValid {\n\t\t\t\troute.Name = name\n\t\t\t\tif route.group != nil {\n\t\t\t\t\troute.Name = route.group.name + route.Name\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := app.hooks.executeOnNameHooks(*app.latestRoute); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn app\n}\n\n// GetRoute Get route by name\nfunc (app *App) GetRoute(name string) Route {\n\tfor _, routes := range app.stack {\n\t\tfor _, route := range routes {\n\t\t\tif route.Name == name {\n\t\t\t\treturn *route\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Route{}\n}\n\n// GetRoutes Get all routes. When filterUseOption equal to true, it will filter the routes registered by the middleware.\nfunc (app *App) GetRoutes(filterUseOption ...bool) []Route {\n\tvar rs []Route\n\tvar filterUse bool\n\tif len(filterUseOption) != 0 {\n\t\tfilterUse = filterUseOption[0]\n\t}\n\tfor _, routes := range app.stack {\n\t\tfor _, route := range routes {\n\t\t\tif filterUse && route.use {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trs = append(rs, *route)\n\t\t}\n\t}\n\treturn rs\n}\n\n// Use registers a middleware route that will match requests\n// with the provided prefix (which is optional and defaults to \"/\").\n// Also, you can pass another app instance as a sub-router along a routing path.\n// It's very useful to split up a large API as many independent routers and\n// compose them as a single service using Use. The fiber's error handler and\n// any of the fiber's sub apps are added to the application's error handlers\n// to be invoked on errors that happen within the prefix route.\n//\n//\t\tapp.Use(func(c fiber.Ctx) error {\n//\t\t     return c.Next()\n//\t\t})\n//\t\tapp.Use(\"/api\", func(c fiber.Ctx) error {\n//\t\t     return c.Next()\n//\t\t})\n//\t\tapp.Use(\"/api\", handler, func(c fiber.Ctx) error {\n//\t\t     return c.Next()\n//\t\t})\n//\t \tsubApp := fiber.New()\n//\t\tapp.Use(\"/mounted-path\", subApp)\n//\n// This method will match all HTTP verbs: GET, POST, PUT, HEAD etc...\nfunc (app *App) Use(args ...any) Router {\n\tvar prefix string\n\tvar subApp *App\n\tvar prefixes []string\n\tvar handlers []Handler\n\n\tfor i := 0; i < len(args); i++ {\n\t\tswitch arg := args[i].(type) {\n\t\tcase string:\n\t\t\tprefix = arg\n\t\tcase *App:\n\t\t\tsubApp = arg\n\t\tcase []string:\n\t\t\tprefixes = arg\n\t\tcase Handler:\n\t\t\thandlers = append(handlers, arg)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"use: invalid handler %v\\n\", reflect.TypeOf(arg)))\n\t\t}\n\t}\n\n\tif len(prefixes) == 0 {\n\t\tprefixes = append(prefixes, prefix)\n\t}\n\n\tfor _, prefix := range prefixes {\n\t\tif subApp != nil {\n\t\t\tapp.mount(prefix, subApp)\n\t\t\treturn app\n\t\t}\n\n\t\tapp.register([]string{methodUse}, prefix, nil, nil, handlers...)\n\t}\n\n\treturn app\n}\n\n// Get registers a route for GET methods that requests a representation\n// of the specified resource. Requests using GET should only retrieve data.\nfunc (app *App) Get(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodGet}, path, handler, middleware...)\n}\n\n// Head registers a route for HEAD methods that asks for a response identical\n// to that of a GET request, but without the response body.\nfunc (app *App) Head(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodHead}, path, handler, middleware...)\n}\n\n// Post registers a route for POST methods that is used to submit an entity to the\n// specified resource, often causing a change in state or side effects on the server.\nfunc (app *App) Post(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodPost}, path, handler, middleware...)\n}\n\n// Put registers a route for PUT methods that replaces all current representations\n// of the target resource with the request payload.\nfunc (app *App) Put(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodPut}, path, handler, middleware...)\n}\n\n// Delete registers a route for DELETE methods that deletes the specified resource.\nfunc (app *App) Delete(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodDelete}, path, handler, middleware...)\n}\n\n// Connect registers a route for CONNECT methods that establishes a tunnel to the\n// server identified by the target resource.\nfunc (app *App) Connect(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodConnect}, path, handler, middleware...)\n}\n\n// Options registers a route for OPTIONS methods that is used to describe the\n// communication options for the target resource.\nfunc (app *App) Options(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodOptions}, path, handler, middleware...)\n}\n\n// Trace registers a route for TRACE methods that performs a message loop-back\n// test along the path to the target resource.\nfunc (app *App) Trace(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodTrace}, path, handler, middleware...)\n}\n\n// Patch registers a route for PATCH methods that is used to apply partial\n// modifications to a resource.\nfunc (app *App) Patch(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add([]string{MethodPatch}, path, handler, middleware...)\n}\n\n// Add allows you to specify multiple HTTP methods to register a route.\nfunc (app *App) Add(methods []string, path string, handler Handler, middleware ...Handler) Router {\n\tapp.register(methods, path, nil, handler, middleware...)\n\n\treturn app\n}\n\n// All will register the handler on all HTTP methods\nfunc (app *App) All(path string, handler Handler, middleware ...Handler) Router {\n\treturn app.Add(app.config.RequestMethods, path, handler, middleware...)\n}\n\n// Group is used for Routes with common prefix to define a new sub-router with optional middleware.\n//\n//\tapi := app.Group(\"/api\")\n//\tapi.Get(\"/users\", handler)\nfunc (app *App) Group(prefix string, handlers ...Handler) Router {\n\tgrp := &Group{Prefix: prefix, app: app}\n\tif len(handlers) > 0 {\n\t\tapp.register([]string{methodUse}, prefix, grp, nil, handlers...)\n\t}\n\tif err := app.hooks.executeOnGroupHooks(*grp); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn grp\n}\n\n// Route is used to define routes with a common prefix inside the common function.\n// Uses Group method to define new sub-router.\nfunc (app *App) Route(path string) Register {\n\t// Create new route\n\troute := &Registering{app: app, path: path}\n\n\treturn route\n}\n\n// Error makes it compatible with the `error` interface.\nfunc (e *Error) Error() string {\n\treturn e.Message\n}\n\n// NewError creates a new Error instance with an optional message\nfunc NewError(code int, message ...string) *Error {\n\terr := &Error{\n\t\tCode:    code,\n\t\tMessage: utils.StatusMessage(code),\n\t}\n\tif len(message) > 0 {\n\t\terr.Message = message[0]\n\t}\n\treturn err\n}\n\n// Config returns the app config as value ( read-only ).\nfunc (app *App) Config() Config {\n\treturn app.config\n}\n\n// Handler returns the server handler.\nfunc (app *App) Handler() fasthttp.RequestHandler { //revive:disable-line:confusing-naming // Having both a Handler() (uppercase) and a handler() (lowercase) is fine. TODO: Use nolint:revive directive instead. See https://github.com/golangci/golangci-lint/issues/3476\n\t// prepare the server for the start\n\tapp.startupProcess()\n\n\tif app.newCtxFunc != nil {\n\t\treturn app.customRequestHandler\n\t}\n\treturn app.defaultRequestHandler\n}\n\n// Stack returns the raw router stack.\nfunc (app *App) Stack() [][]*Route {\n\treturn app.stack\n}\n\n// HandlersCount returns the amount of registered handlers.\nfunc (app *App) HandlersCount() uint32 {\n\treturn app.handlersCount\n}\n\n// Shutdown gracefully shuts down the server without interrupting any active connections.\n// Shutdown works by first closing all open listeners and then waiting indefinitely for all connections to return to idle before shutting down.\n//\n// Make sure the program doesn't exit and waits instead for Shutdown to return.\n//\n// Shutdown does not close keepalive connections so its recommended to set ReadTimeout to something else than 0.\nfunc (app *App) Shutdown() error {\n\treturn app.ShutdownWithContext(context.Background())\n}\n\n// ShutdownWithTimeout gracefully shuts down the server without interrupting any active connections. However, if the timeout is exceeded,\n// ShutdownWithTimeout will forcefully close any active connections.\n// ShutdownWithTimeout works by first closing all open listeners and then waiting for all connections to return to idle before shutting down.\n//\n// Make sure the program doesn't exit and waits instead for ShutdownWithTimeout to return.\n//\n// ShutdownWithTimeout does not close keepalive connections so its recommended to set ReadTimeout to something else than 0.\nfunc (app *App) ShutdownWithTimeout(timeout time.Duration) error {\n\tctx, cancelFunc := context.WithTimeout(context.Background(), timeout)\n\tdefer cancelFunc()\n\treturn app.ShutdownWithContext(ctx)\n}\n\n// ShutdownWithContext shuts down the server including by force if the context's deadline is exceeded.\n//\n// Make sure the program doesn't exit and waits instead for ShutdownWithTimeout to return.\n//\n// ShutdownWithContext does not close keepalive connections so its recommended to set ReadTimeout to something else than 0.\nfunc (app *App) ShutdownWithContext(ctx context.Context) error {\n\tif app.hooks != nil {\n\t\t// TODO: check should be defered?\n\t\tapp.hooks.executeOnShutdownHooks()\n\t}\n\n\tapp.mutex.Lock()\n\tdefer app.mutex.Unlock()\n\tif app.server == nil {\n\t\treturn ErrNotRunning\n\t}\n\treturn app.server.ShutdownWithContext(ctx)\n}\n\n// Server returns the underlying fasthttp server\nfunc (app *App) Server() *fasthttp.Server {\n\treturn app.server\n}\n\n// Hooks returns the hook struct to register hooks.\nfunc (app *App) Hooks() *Hooks {\n\treturn app.hooks\n}\n\n// TestConfig is a struct holding Test settings\ntype TestConfig struct {\n\t// Timeout defines the maximum duration a\n\t// test can run before timing out.\n\t// Default: time.Second\n\tTimeout time.Duration\n\n\t// FailOnTimeout specifies whether the test\n\t// should return a timeout error if the HTTP response\n\t// exceeds the Timeout duration.\n\t// Default: true\n\tFailOnTimeout bool\n}\n\n// Test is used for internal debugging by passing a *http.Request.\n// Config is optional and defaults to a 1s error on timeout,\n// 0 timeout will disable it completely.\nfunc (app *App) Test(req *http.Request, config ...TestConfig) (*http.Response, error) {\n\t// Default config\n\tcfg := TestConfig{\n\t\tTimeout:       time.Second,\n\t\tFailOnTimeout: true,\n\t}\n\n\t// Override config if provided\n\tif len(config) > 0 {\n\t\tcfg = config[0]\n\t}\n\n\t// Add Content-Length if not provided with body\n\tif req.Body != http.NoBody && req.Header.Get(HeaderContentLength) == \"\" {\n\t\treq.Header.Add(HeaderContentLength, strconv.FormatInt(req.ContentLength, 10))\n\t}\n\n\t// Dump raw http request\n\tdump, err := httputil.DumpRequest(req, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dump request: %w\", err)\n\t}\n\n\t// Create test connection\n\tconn := new(testConn)\n\n\t// Write raw http request\n\tif _, err := conn.r.Write(dump); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write: %w\", err)\n\t}\n\t// prepare the server for the start\n\tapp.startupProcess()\n\n\t// Serve conn to server\n\tchannel := make(chan error)\n\tgo func() {\n\t\tvar returned bool\n\t\tdefer func() {\n\t\t\tif !returned {\n\t\t\t\tchannel <- ErrHandlerExited\n\t\t\t}\n\t\t}()\n\n\t\tchannel <- app.server.ServeConn(conn)\n\t\treturned = true\n\t}()\n\n\t// Wait for callback\n\tif cfg.Timeout > 0 {\n\t\t// With timeout\n\t\tselect {\n\t\tcase err = <-channel:\n\t\tcase <-time.After(cfg.Timeout):\n\t\t\tconn.Close() //nolint:errcheck, revive // It is fine to ignore the error here\n\t\t\tif cfg.FailOnTimeout {\n\t\t\t\treturn nil, os.ErrDeadlineExceeded\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Without timeout\n\t\terr = <-channel\n\t}\n\n\t// Check for errors\n\tif err != nil && !errors.Is(err, fasthttp.ErrGetOnly) {\n\t\treturn nil, err\n\t}\n\n\t// Read response\n\tbuffer := bufio.NewReader(&conn.w)\n\n\t// Convert raw http response to *http.Response\n\tres, err := http.ReadResponse(buffer, req)\n\tif err != nil {\n\t\tif errors.Is(err, io.ErrUnexpectedEOF) {\n\t\t\treturn nil, errors.New(\"test: got empty response\")\n\t\t}\n\t\treturn nil, fmt.Errorf(\"failed to read response: %w\", err)\n\t}\n\n\treturn res, nil\n}\n\ntype disableLogger struct{}\n\nfunc (*disableLogger) Printf(string, ...any) {\n}\n\nfunc (app *App) init() *App {\n\t// lock application\n\tapp.mutex.Lock()\n\n\t// Only load templates if a view engine is specified\n\tif app.config.Views != nil {\n\t\tif err := app.config.Views.Load(); err != nil {\n\t\t\tlog.Warnf(\"failed to load views: %v\", err)\n\t\t}\n\t}\n\n\t// create fasthttp server\n\tapp.server = &fasthttp.Server{\n\t\tLogger:       &disableLogger{},\n\t\tLogAllErrors: false,\n\t\tErrorHandler: app.serverErrorHandler,\n\t}\n\n\t// fasthttp server settings\n\tif app.newCtxFunc != nil {\n\t\tapp.server.Handler = app.customRequestHandler\n\t} else {\n\t\tapp.server.Handler = app.defaultRequestHandler\n\t}\n\tapp.server.Name = app.config.ServerHeader\n\tapp.server.Concurrency = app.config.Concurrency\n\tapp.server.NoDefaultDate = app.config.DisableDefaultDate\n\tapp.server.NoDefaultContentType = app.config.DisableDefaultContentType\n\tapp.server.DisableHeaderNamesNormalizing = app.config.DisableHeaderNormalizing\n\tapp.server.DisableKeepalive = app.config.DisableKeepalive\n\tapp.server.MaxRequestBodySize = app.config.BodyLimit\n\tapp.server.NoDefaultServerHeader = app.config.ServerHeader == \"\"\n\tapp.server.ReadTimeout = app.config.ReadTimeout\n\tapp.server.WriteTimeout = app.config.WriteTimeout\n\tapp.server.IdleTimeout = app.config.IdleTimeout\n\tapp.server.ReadBufferSize = app.config.ReadBufferSize\n\tapp.server.WriteBufferSize = app.config.WriteBufferSize\n\tapp.server.GetOnly = app.config.GETOnly\n\tapp.server.ReduceMemoryUsage = app.config.ReduceMemoryUsage\n\tapp.server.StreamRequestBody = app.config.StreamRequestBody\n\tapp.server.DisablePreParseMultipartForm = app.config.DisablePreParseMultipartForm\n\n\t// unlock application\n\tapp.mutex.Unlock()\n\treturn app\n}\n\n// ErrorHandler is the application's method in charge of finding the\n// appropriate handler for the given request. It searches any mounted\n// sub fibers by their prefixes and if it finds a match, it uses that\n// error handler. Otherwise it uses the configured error handler for\n// the app, which if not set is the DefaultErrorHandler.\nfunc (app *App) ErrorHandler(ctx Ctx, err error) error {\n\tvar (\n\t\tmountedErrHandler  ErrorHandler\n\t\tmountedPrefixParts int\n\t)\n\n\tfor prefix, subApp := range app.mountFields.appList {\n\t\tif prefix != \"\" && strings.HasPrefix(ctx.Path(), prefix) {\n\t\t\tparts := len(strings.Split(prefix, \"/\"))\n\t\t\tif mountedPrefixParts <= parts {\n\t\t\t\tif subApp.configured.ErrorHandler != nil {\n\t\t\t\t\tmountedErrHandler = subApp.config.ErrorHandler\n\t\t\t\t}\n\n\t\t\t\tmountedPrefixParts = parts\n\t\t\t}\n\t\t}\n\t}\n\n\tif mountedErrHandler != nil {\n\t\treturn mountedErrHandler(ctx, err)\n\t}\n\n\treturn app.config.ErrorHandler(ctx, err)\n}\n\n// serverErrorHandler is a wrapper around the application's error handler method\n// user for the fasthttp server configuration. It maps a set of fasthttp errors to fiber\n// errors before calling the application's error handler method.\nfunc (app *App) serverErrorHandler(fctx *fasthttp.RequestCtx, err error) {\n\t// Acquire Ctx with fasthttp request from pool\n\tc := app.AcquireCtx(fctx)\n\tdefer app.ReleaseCtx(c)\n\n\tvar (\n\t\terrNetOP *net.OpError\n\t\tnetErr   net.Error\n\t)\n\n\tswitch {\n\tcase errors.As(err, new(*fasthttp.ErrSmallBuffer)):\n\t\terr = ErrRequestHeaderFieldsTooLarge\n\tcase errors.As(err, &errNetOP) && errNetOP.Timeout():\n\t\terr = ErrRequestTimeout\n\tcase errors.As(err, &netErr):\n\t\terr = ErrBadGateway\n\tcase errors.Is(err, fasthttp.ErrBodyTooLarge):\n\t\terr = ErrRequestEntityTooLarge\n\tcase errors.Is(err, fasthttp.ErrGetOnly):\n\t\terr = ErrMethodNotAllowed\n\tcase strings.Contains(err.Error(), \"timeout\"):\n\t\terr = ErrRequestTimeout\n\tdefault:\n\t\terr = NewError(StatusBadRequest, err.Error())\n\t}\n\n\tif catch := app.ErrorHandler(c, err); catch != nil {\n\t\tlog.Errorf(\"serverErrorHandler: failed to call ErrorHandler: %v\", catch)\n\t\t_ = c.SendStatus(StatusInternalServerError) //nolint:errcheck // It is fine to ignore the error here\n\t\treturn\n\t}\n}\n\n// startupProcess Is the method which executes all the necessary processes just before the start of the server.\nfunc (app *App) startupProcess() *App {\n\tapp.mutex.Lock()\n\tdefer app.mutex.Unlock()\n\n\tapp.mountStartupProcess()\n\n\t// build route tree stack\n\tapp.buildTree()\n\n\treturn app\n}\n\n// Run onListen hooks. If they return an error, panic.\nfunc (app *App) runOnListenHooks(listenData ListenData) {\n\tif err := app.hooks.executeOnListenHooks(listenData); err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "app_test.go",
          "type": "blob",
          "size": 47.04,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\n//nolint:goconst // Much easier to just ignore memory leaks in tests\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gofiber/utils/v2\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/fasthttp\"\n\t\"github.com/valyala/fasthttp/fasthttputil\"\n)\n\nfunc testEmptyHandler(_ Ctx) error {\n\treturn nil\n}\n\nfunc testStatus200(t *testing.T, app *App, url, method string) {\n\tt.Helper()\n\n\treq := httptest.NewRequest(method, url, nil)\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n}\n\nfunc testErrorResponse(t *testing.T, err error, resp *http.Response, expectedBodyError string) {\n\tt.Helper()\n\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 500, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectedBodyError, string(body), \"Response body\")\n}\n\nfunc Test_App_MethodNotAllowed(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\n\tapp.Post(\"/\", testEmptyHandler)\n\n\tapp.Options(\"/\", testEmptyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodPost, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 200, resp.StatusCode)\n\trequire.Equal(t, \"\", resp.Header.Get(HeaderAllow))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 405, resp.StatusCode)\n\trequire.Equal(t, \"POST, OPTIONS\", resp.Header.Get(HeaderAllow))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodPatch, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 405, resp.StatusCode)\n\trequire.Equal(t, \"POST, OPTIONS\", resp.Header.Get(HeaderAllow))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodPut, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 405, resp.StatusCode)\n\trequire.Equal(t, \"POST, OPTIONS\", resp.Header.Get(HeaderAllow))\n\n\tapp.Get(\"/\", testEmptyHandler)\n\n\tresp, err = app.Test(httptest.NewRequest(MethodTrace, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 405, resp.StatusCode)\n\trequire.Equal(t, \"GET, POST, OPTIONS\", resp.Header.Get(HeaderAllow))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodPatch, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 405, resp.StatusCode)\n\trequire.Equal(t, \"GET, POST, OPTIONS\", resp.Header.Get(HeaderAllow))\n\n\tapp.Head(\"/\", testEmptyHandler)\n\n\tresp, err = app.Test(httptest.NewRequest(MethodPut, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 405, resp.StatusCode)\n\trequire.Equal(t, \"GET, HEAD, POST, OPTIONS\", resp.Header.Get(HeaderAllow))\n}\n\nfunc Test_App_Custom_Middleware_404_Should_Not_SetMethodNotAllowed(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.SendStatus(404)\n\t})\n\n\tapp.Post(\"/\", testEmptyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 404, resp.StatusCode)\n\n\tg := app.Group(\"/with-next\", func(c Ctx) error {\n\t\treturn c.Status(404).Next()\n\t})\n\n\tg.Post(\"/\", testEmptyHandler)\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/with-next\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 404, resp.StatusCode)\n}\n\nfunc Test_App_ServerErrorHandler_SmallReadBuffer(t *testing.T) {\n\tt.Parallel()\n\texpectedError := regexp.MustCompile(\n\t\t`error when reading request headers: small read buffer\\. Increase ReadBufferSize\\. Buffer size=4096, contents: \"GET / HTTP/1.1\\\\r\\\\nHost: example\\.com\\\\r\\\\nVery-Long-Header: -+`,\n\t)\n\tapp := New()\n\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\tpanic(errors.New(\"should never called\"))\n\t})\n\n\trequest := httptest.NewRequest(MethodGet, \"/\", nil)\n\tlogHeaderSlice := make([]string, 5000)\n\trequest.Header.Set(\"Very-Long-Header\", strings.Join(logHeaderSlice, \"-\"))\n\t_, err := app.Test(request)\n\tif err == nil {\n\t\tt.Error(\"Expect an error at app.Test(request)\")\n\t}\n\n\trequire.Regexp(t, expectedError, err.Error())\n}\n\nfunc Test_App_Errors(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tBodyLimit: 4,\n\t})\n\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"hi, i'm an error\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 500, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"hi, i'm an error\", string(body))\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/\", strings.NewReader(\"big body\")))\n\tif err != nil {\n\t\trequire.Equal(t, \"body size exceeds the given limit\", err.Error(), \"app.Test(req)\")\n\t}\n}\n\ntype customConstraint struct{}\n\nfunc (*customConstraint) Name() string {\n\treturn \"test\"\n}\n\nfunc (*customConstraint) Execute(param string, args ...string) bool {\n\tif param == \"test\" && len(args) == 1 && args[0] == \"test\" {\n\t\treturn true\n\t}\n\n\tif len(args) == 0 && param == \"c\" {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc Test_App_CustomConstraint(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.RegisterCustomConstraint(&customConstraint{})\n\n\tapp.Get(\"/test/:param<test(test)>\", func(c Ctx) error {\n\t\treturn c.SendString(\"test\")\n\t})\n\n\tapp.Get(\"/test2/:param<test>\", func(c Ctx) error {\n\t\treturn c.SendString(\"test\")\n\t})\n\n\tapp.Get(\"/test3/:param<test()>\", func(c Ctx) error {\n\t\treturn c.SendString(\"test\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test/test2\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 404, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/c\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/cc\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 404, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test3/cc\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 404, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_ErrorHandler_Custom(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tErrorHandler: func(c Ctx, _ error) error {\n\t\t\treturn c.Status(200).SendString(\"hi, i'm an custom error\")\n\t\t},\n\t})\n\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"hi, i'm an error\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"hi, i'm an custom error\", string(body))\n}\n\nfunc Test_App_ErrorHandler_HandlerStack(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tErrorHandler: func(c Ctx, err error) error {\n\t\t\trequire.Equal(t, \"1: USE error\", err.Error())\n\t\t\treturn DefaultErrorHandler(c, err)\n\t\t},\n\t})\n\tapp.Use(\"/\", func(c Ctx) error {\n\t\terr := c.Next() // call next USE\n\t\trequire.Equal(t, \"2: USE error\", err.Error())\n\t\treturn errors.New(\"1: USE error\")\n\t}, func(c Ctx) error {\n\t\terr := c.Next() // call [0] GET\n\t\trequire.Equal(t, \"0: GET error\", err.Error())\n\t\treturn errors.New(\"2: USE error\")\n\t})\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"0: GET error\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 500, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"1: USE error\", string(body))\n}\n\nfunc Test_App_ErrorHandler_RouteStack(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tErrorHandler: func(c Ctx, err error) error {\n\t\t\trequire.Equal(t, \"1: USE error\", err.Error())\n\t\t\treturn DefaultErrorHandler(c, err)\n\t\t},\n\t})\n\tapp.Use(\"/\", func(c Ctx) error {\n\t\terr := c.Next()\n\t\trequire.Equal(t, \"0: GET error\", err.Error())\n\t\treturn errors.New(\"1: USE error\") // [2] call ErrorHandler\n\t})\n\tapp.Get(\"/test\", func(_ Ctx) error {\n\t\treturn errors.New(\"0: GET error\") // [1] return to USE\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 500, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"1: USE error\", string(body))\n}\n\nfunc Test_App_serverErrorHandler_Internal_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tmsg := \"test err\"\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tapp.serverErrorHandler(c.fasthttp, errors.New(msg))\n\trequire.Equal(t, string(c.fasthttp.Response.Body()), msg)\n\trequire.Equal(t, StatusBadRequest, c.fasthttp.Response.StatusCode())\n}\n\nfunc Test_App_serverErrorHandler_Network_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tapp.serverErrorHandler(c.fasthttp, &net.DNSError{\n\t\tErr:       \"test error\",\n\t\tName:      \"test host\",\n\t\tIsTimeout: false,\n\t})\n\trequire.Equal(t, string(c.fasthttp.Response.Body()), utils.StatusMessage(StatusBadGateway))\n\trequire.Equal(t, StatusBadGateway, c.fasthttp.Response.StatusCode())\n}\n\nfunc Test_App_Nested_Params(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\treturn c.Status(400).Send([]byte(\"Should move on\"))\n\t})\n\tapp.Get(\"/test/:param\", func(c Ctx) error {\n\t\treturn c.Status(400).Send([]byte(\"Should move on\"))\n\t})\n\tapp.Get(\"/test/:param/test\", func(c Ctx) error {\n\t\treturn c.Status(400).Send([]byte(\"Should move on\"))\n\t})\n\tapp.Get(\"/test/:param/test/:param2\", func(c Ctx) error {\n\t\treturn c.Status(200).Send([]byte(\"Good job\"))\n\t})\n\n\treq := httptest.NewRequest(MethodGet, \"/test/john/test/doe\", nil)\n\tresp, err := app.Test(req)\n\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Use_Params(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(\"/prefix/:param\", func(c Ctx) error {\n\t\trequire.Equal(t, \"john\", c.Params(\"param\"))\n\t\treturn nil\n\t})\n\n\tapp.Use(\"/foo/:bar?\", func(c Ctx) error {\n\t\trequire.Equal(t, \"foobar\", c.Params(\"bar\", \"foobar\"))\n\t\treturn nil\n\t})\n\n\tapp.Use(\"/:param/*\", func(c Ctx) error {\n\t\trequire.Equal(t, \"john\", c.Params(\"param\"))\n\t\trequire.Equal(t, \"doe\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/prefix/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/john/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/foo\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trequire.Equal(t, \"use: invalid handler func()\\n\", fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}()\n\n\tapp.Use(\"/:param/*\", func() {\n\t\t// this should panic\n\t})\n}\n\nfunc Test_App_Use_UnescapedPath(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{UnescapePath: true, CaseSensitive: true})\n\n\tapp.Use(\"/cRéeR/:param\", func(c Ctx) error {\n\t\trequire.Equal(t, \"/cRéeR/اختبار\", c.Path())\n\t\treturn c.SendString(c.Params(\"param\"))\n\t})\n\n\tapp.Use(\"/abc\", func(c Ctx) error {\n\t\trequire.Equal(t, \"/AbC\", c.Path())\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/cR%C3%A9eR/%D8%A7%D8%AE%D8%AA%D8%A8%D8%A7%D8%B1\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\t// check the param result\n\trequire.Equal(t, \"اختبار\", app.getString(body))\n\n\t// with lowercase letters\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/cr%C3%A9er/%D8%A7%D8%AE%D8%AA%D8%A8%D8%A7%D8%B1\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Use_CaseSensitive(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{CaseSensitive: true})\n\n\tapp.Use(\"/abc\", func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\t// wrong letters in the requested route -> 404\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/AbC\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n\n\t// right letters in the requrested route -> 200\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/abc\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// check the detected path when the case-insensitive recognition is activated\n\tapp.config.CaseSensitive = false\n\t// check the case-sensitive feature\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/AbC\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\t// check the detected path result\n\trequire.Equal(t, \"/AbC\", app.getString(body))\n}\n\nfunc Test_App_Not_Use_StrictRouting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(\"/abc\", func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\tg := app.Group(\"/foo\")\n\tg.Use(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\t// wrong path in the requested route -> 404\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/abc/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// right path in the requrested route -> 200\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/abc\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// wrong path with group in the requested route -> 404\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/foo\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// right path with group in the requrested route -> 200\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/foo/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Use_MultiplePrefix(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use([]string{\"/john\", \"/doe\"}, func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\tg := app.Group(\"/test\")\n\tg.Use([]string{\"/john\", \"/doe\"}, func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"/john\", string(body))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"/doe\", string(body))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"/test/john\", string(body))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"/test/doe\", string(body))\n}\n\nfunc Test_App_Use_StrictRouting(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{StrictRouting: true})\n\n\tapp.Get(\"/abc\", func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\tg := app.Group(\"/foo\")\n\tg.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(c.Path())\n\t})\n\n\t// wrong path in the requested route -> 404\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/abc/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n\n\t// right path in the requrested route -> 200\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/abc\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// wrong path with group in the requested route -> 404\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/foo\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n\n\t// right path with group in the requrested route -> 200\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/foo/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Add_Method_Test(t *testing.T) {\n\tt.Parallel()\n\n\tmethods := append(DefaultMethods, \"JOHN\") //nolint:gocritic // We want a new slice here\n\tapp := New(Config{\n\t\tRequestMethods: methods,\n\t})\n\n\tapp.Add([]string{\"JOHN\"}, \"/john\", testEmptyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(\"JOHN\", \"/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusMethodNotAllowed, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(\"UNKNOWN\", \"/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotImplemented, resp.StatusCode, \"Status code\")\n\n\t// Add a new method\n\trequire.Panics(t, func() {\n\t\tapp.Add([]string{\"JANE\"}, \"/jane\", testEmptyHandler)\n\t})\n}\n\nfunc Test_App_All_Method_Test(t *testing.T) {\n\tt.Parallel()\n\n\tmethods := append(DefaultMethods, \"JOHN\") //nolint:gocritic // We want a new slice here\n\tapp := New(Config{\n\t\tRequestMethods: methods,\n\t})\n\n\t// Add a new method with All\n\tapp.All(\"/doe\", testEmptyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(\"JOHN\", \"/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// Add a new method\n\trequire.Panics(t, func() {\n\t\tapp.Add([]string{\"JANE\"}, \"/jane\", testEmptyHandler)\n\t})\n}\n\n// go test -run Test_App_GETOnly\nfunc Test_App_GETOnly(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tGETOnly: true,\n\t})\n\n\tapp.Post(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(\"Hello 👋!\")\n\t})\n\n\treq := httptest.NewRequest(MethodPost, \"/\", nil)\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusMethodNotAllowed, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Use_Params_Group(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tgroup := app.Group(\"/prefix/:param/*\")\n\tgroup.Use(\"/\", func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\tgroup.Get(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, \"john\", c.Params(\"param\"))\n\t\trequire.Equal(t, \"doe\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/prefix/john/doe/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Chaining(t *testing.T) {\n\tt.Parallel()\n\tn := func(c Ctx) error {\n\t\treturn c.Next()\n\t}\n\tapp := New()\n\tapp.Use(\"/john\", n, n, n, n, func(c Ctx) error {\n\t\treturn c.SendStatus(202)\n\t})\n\t// check handler count for registered HEAD route\n\trequire.Len(t, app.stack[app.methodInt(MethodHead)][0].Handlers, 5, \"app.Test(req)\")\n\n\treq := httptest.NewRequest(MethodPost, \"/john\", nil)\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 202, resp.StatusCode, \"Status code\")\n\n\tapp.Get(\"/test\", n, n, n, n, func(c Ctx) error {\n\t\treturn c.SendStatus(203)\n\t})\n\n\treq = httptest.NewRequest(MethodGet, \"/test\", nil)\n\n\tresp, err = app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 203, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Order(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\t_, err := c.Write([]byte(\"1\"))\n\t\trequire.NoError(t, err)\n\n\t\treturn c.Next()\n\t})\n\n\tapp.All(\"/test\", func(c Ctx) error {\n\t\t_, err := c.Write([]byte(\"2\"))\n\t\trequire.NoError(t, err)\n\n\t\treturn c.Next()\n\t})\n\n\tapp.Use(func(c Ctx) error {\n\t\t_, err := c.Write([]byte(\"3\"))\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\treq := httptest.NewRequest(MethodGet, \"/test\", nil)\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"123\", string(body))\n}\n\nfunc Test_App_Methods(t *testing.T) {\n\tt.Parallel()\n\tdummyHandler := testEmptyHandler\n\n\tapp := New()\n\n\tapp.Connect(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", \"CONNECT\")\n\n\tapp.Put(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodPut)\n\n\tapp.Post(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodPost)\n\n\tapp.Delete(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodDelete)\n\n\tapp.Head(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodHead)\n\n\tapp.Patch(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodPatch)\n\n\tapp.Options(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodOptions)\n\n\tapp.Trace(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodTrace)\n\n\tapp.Get(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodGet)\n\n\tapp.All(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodPost)\n\n\tapp.Use(\"/:john?/:doe?\", dummyHandler)\n\ttestStatus200(t, app, \"/john/doe\", MethodGet)\n}\n\nfunc Test_App_Route_Naming(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\thandler := func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t}\n\tapp.Get(\"/john\", handler).Name(\"john\")\n\tapp.Delete(\"/doe\", handler)\n\tapp.Name(\"doe\")\n\n\tjane := app.Group(\"/jane\").Name(\"jane.\")\n\tgroup := app.Group(\"/group\")\n\tsubGroup := jane.Group(\"/sub-group\").Name(\"sub.\")\n\n\tjane.Get(\"/test\", handler).Name(\"test\")\n\tjane.Trace(\"/trace\", handler).Name(\"trace\")\n\n\tgroup.Get(\"/test\", handler).Name(\"test\")\n\n\tapp.Post(\"/post\", handler).Name(\"post\")\n\n\tsubGroup.Get(\"/done\", handler).Name(\"done\")\n\n\trequire.Equal(t, \"post\", app.GetRoute(\"post\").Name)\n\trequire.Equal(t, \"john\", app.GetRoute(\"john\").Name)\n\trequire.Equal(t, \"jane.test\", app.GetRoute(\"jane.test\").Name)\n\trequire.Equal(t, \"jane.trace\", app.GetRoute(\"jane.trace\").Name)\n\trequire.Equal(t, \"jane.sub.done\", app.GetRoute(\"jane.sub.done\").Name)\n\trequire.Equal(t, \"test\", app.GetRoute(\"test\").Name)\n}\n\nfunc Test_App_New(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", testEmptyHandler)\n\n\tappConfig := New(Config{\n\t\tImmutable: true,\n\t})\n\tappConfig.Get(\"/\", testEmptyHandler)\n}\n\nfunc Test_App_Config(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tStrictRouting: true,\n\t})\n\trequire.True(t, app.Config().StrictRouting)\n}\n\nfunc Test_App_Shutdown(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New()\n\t\trequire.NoError(t, app.Shutdown())\n\t})\n\n\tt.Run(\"no server\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := &App{}\n\t\tif err := app.Shutdown(); err != nil {\n\t\t\trequire.ErrorContains(t, err, \"shutdown: server is not running\")\n\t\t}\n\t})\n}\n\nfunc Test_App_ShutdownWithTimeout(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\ttime.Sleep(5 * time.Second)\n\t\treturn c.SendString(\"body\")\n\t})\n\n\tln := fasthttputil.NewInmemoryListener()\n\tgo func() {\n\t\terr := app.Listener(ln)\n\t\tassert.NoError(t, err)\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\tgo func() {\n\t\tconn, err := ln.Dial()\n\t\tassert.NoError(t, err)\n\n\t\t_, err = conn.Write([]byte(\"GET / HTTP/1.1\\r\\nHost: google.com\\r\\n\\r\\n\"))\n\t\tassert.NoError(t, err)\n\t}()\n\ttime.Sleep(1 * time.Second)\n\n\tshutdownErr := make(chan error)\n\tgo func() {\n\t\tshutdownErr <- app.ShutdownWithTimeout(1 * time.Second)\n\t}()\n\n\ttimer := time.NewTimer(time.Second * 5)\n\tselect {\n\tcase <-timer.C:\n\t\tt.Fatal(\"idle connections not closed on shutdown\")\n\tcase err := <-shutdownErr:\n\t\tif err == nil || !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected err %v. Expecting %v\", err, context.DeadlineExceeded)\n\t\t}\n\t}\n}\n\nfunc Test_App_ShutdownWithContext(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/\", func(ctx Ctx) error {\n\t\ttime.Sleep(5 * time.Second)\n\t\treturn ctx.SendString(\"body\")\n\t})\n\n\tln := fasthttputil.NewInmemoryListener()\n\n\tgo func() {\n\t\terr := app.Listener(ln)\n\t\tassert.NoError(t, err)\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\n\tgo func() {\n\t\tconn, err := ln.Dial()\n\t\tassert.NoError(t, err)\n\n\t\t_, err = conn.Write([]byte(\"GET / HTTP/1.1\\r\\nHost: google.com\\r\\n\\r\\n\"))\n\t\tassert.NoError(t, err)\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\n\tshutdownErr := make(chan error)\n\tgo func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n\t\tdefer cancel()\n\t\tshutdownErr <- app.ShutdownWithContext(ctx)\n\t}()\n\n\tselect {\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"idle connections not closed on shutdown\")\n\tcase err := <-shutdownErr:\n\t\tif err == nil || !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected err %v. Expecting %v\", err, context.DeadlineExceeded)\n\t\t}\n\t}\n}\n\n// go test -run Test_App_Mixed_Routes_WithSameLen\nfunc Test_App_Mixed_Routes_WithSameLen(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// middleware\n\tapp.Use(func(c Ctx) error {\n\t\tc.Set(\"TestHeader\", \"TestValue\")\n\t\treturn c.Next()\n\t})\n\t// routes with the same length\n\tapp.Get(\"/tesbar\", func(c Ctx) error {\n\t\tc.Type(\"html\")\n\t\treturn c.Send([]byte(\"TEST_BAR\"))\n\t})\n\tapp.Get(\"/foobar\", func(c Ctx) error {\n\t\tc.Type(\"html\")\n\t\treturn c.Send([]byte(\"FOO_BAR\"))\n\t})\n\n\t// match get route\n\treq := httptest.NewRequest(MethodGet, \"/foobar\", nil)\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\trequire.NotEmpty(t, resp.Header.Get(HeaderContentLength))\n\trequire.Equal(t, \"TestValue\", resp.Header.Get(\"TestHeader\"))\n\trequire.Equal(t, \"text/html\", resp.Header.Get(HeaderContentType))\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"FOO_BAR\", string(body))\n\n\t// match static route\n\treq = httptest.NewRequest(MethodGet, \"/tesbar\", nil)\n\tresp, err = app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\trequire.NotEmpty(t, resp.Header.Get(HeaderContentLength))\n\trequire.Equal(t, \"TestValue\", resp.Header.Get(\"TestHeader\"))\n\trequire.Equal(t, \"text/html\", resp.Header.Get(HeaderContentType))\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Contains(t, string(body), \"TEST_BAR\")\n}\n\nfunc Test_App_Group_Invalid(t *testing.T) {\n\tt.Parallel()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trequire.Equal(t, \"use: invalid handler int\\n\", fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}()\n\tNew().Group(\"/\").Use(1)\n}\n\nfunc Test_App_Group(t *testing.T) {\n\tt.Parallel()\n\tdummyHandler := testEmptyHandler\n\n\tapp := New()\n\n\tgrp := app.Group(\"/test\")\n\tgrp.Get(\"/\", dummyHandler)\n\ttestStatus200(t, app, \"/test\", MethodGet)\n\n\tgrp.Get(\"/:demo?\", dummyHandler)\n\ttestStatus200(t, app, \"/test/john\", MethodGet)\n\n\tgrp.Connect(\"/CONNECT\", dummyHandler)\n\ttestStatus200(t, app, \"/test/CONNECT\", MethodConnect)\n\n\tgrp.Put(\"/PUT\", dummyHandler)\n\ttestStatus200(t, app, \"/test/PUT\", MethodPut)\n\n\tgrp.Post(\"/POST\", dummyHandler)\n\ttestStatus200(t, app, \"/test/POST\", MethodPost)\n\n\tgrp.Delete(\"/DELETE\", dummyHandler)\n\ttestStatus200(t, app, \"/test/DELETE\", MethodDelete)\n\n\tgrp.Head(\"/HEAD\", dummyHandler)\n\ttestStatus200(t, app, \"/test/HEAD\", MethodHead)\n\n\tgrp.Patch(\"/PATCH\", dummyHandler)\n\ttestStatus200(t, app, \"/test/PATCH\", MethodPatch)\n\n\tgrp.Options(\"/OPTIONS\", dummyHandler)\n\ttestStatus200(t, app, \"/test/OPTIONS\", MethodOptions)\n\n\tgrp.Trace(\"/TRACE\", dummyHandler)\n\ttestStatus200(t, app, \"/test/TRACE\", MethodTrace)\n\n\tgrp.All(\"/ALL\", dummyHandler)\n\ttestStatus200(t, app, \"/test/ALL\", MethodPost)\n\n\tgrp.Use(dummyHandler)\n\ttestStatus200(t, app, \"/test/oke\", MethodGet)\n\n\tgrp.Use(\"/USE\", dummyHandler)\n\ttestStatus200(t, app, \"/test/USE/oke\", MethodGet)\n\n\tapi := grp.Group(\"/v1\")\n\tapi.Post(\"/\", dummyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodPost, \"/test/v1/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tapi.Get(\"/users\", dummyHandler)\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test/v1/UsErS\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Route(t *testing.T) {\n\tt.Parallel()\n\tdummyHandler := testEmptyHandler\n\n\tapp := New()\n\n\tregister := app.Route(\"/test\").\n\t\tGet(dummyHandler).\n\t\tHead(dummyHandler).\n\t\tPost(dummyHandler).\n\t\tPut(dummyHandler).\n\t\tDelete(dummyHandler).\n\t\tConnect(dummyHandler).\n\t\tOptions(dummyHandler).\n\t\tTrace(dummyHandler).\n\t\tPatch(dummyHandler)\n\n\ttestStatus200(t, app, \"/test\", MethodGet)\n\ttestStatus200(t, app, \"/test\", MethodHead)\n\ttestStatus200(t, app, \"/test\", MethodPost)\n\ttestStatus200(t, app, \"/test\", MethodPut)\n\ttestStatus200(t, app, \"/test\", MethodDelete)\n\ttestStatus200(t, app, \"/test\", MethodConnect)\n\ttestStatus200(t, app, \"/test\", MethodOptions)\n\ttestStatus200(t, app, \"/test\", MethodTrace)\n\ttestStatus200(t, app, \"/test\", MethodPatch)\n\n\tregister.Route(\"/v1\").Get(dummyHandler).Post(dummyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodPost, \"/test/v1\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test/v1\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tregister.Route(\"/v1\").Route(\"/v2\").Route(\"/v3\").Get(dummyHandler).Trace(dummyHandler)\n\n\tresp, err = app.Test(httptest.NewRequest(MethodTrace, \"/test/v1/v2/v3\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test/v1/v2/v3\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_App_Deep_Group(t *testing.T) {\n\tt.Parallel()\n\trunThroughCount := 0\n\tdummyHandler := func(c Ctx) error {\n\t\trunThroughCount++\n\t\treturn c.Next()\n\t}\n\n\tapp := New()\n\tgAPI := app.Group(\"/api\", dummyHandler)\n\tgV1 := gAPI.Group(\"/v1\", dummyHandler)\n\tgUser := gV1.Group(\"/user\", dummyHandler)\n\tgUser.Get(\"/authenticate\", func(c Ctx) error {\n\t\trunThroughCount++\n\t\treturn c.SendStatus(200)\n\t})\n\ttestStatus200(t, app, \"/api/v1/user/authenticate\", MethodGet)\n\trequire.Equal(t, 4, runThroughCount, \"Loop count\")\n}\n\n// go test -run Test_App_Next_Method\nfunc Test_App_Next_Method(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(func(c Ctx) error {\n\t\trequire.Equal(t, MethodGet, c.Method())\n\t\terr := c.Next()\n\t\trequire.Equal(t, MethodGet, c.Method())\n\t\treturn err\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 404, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_NewError -benchmem -count=4\nfunc Benchmark_NewError(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tNewError(200, \"test\") //nolint:errcheck // not needed\n\t}\n}\n\n// go test -run Test_NewError\nfunc Test_NewError(t *testing.T) {\n\tt.Parallel()\n\te := NewError(StatusForbidden, \"permission denied\")\n\trequire.Equal(t, StatusForbidden, e.Code)\n\trequire.Equal(t, \"permission denied\", e.Message)\n}\n\n// go test -run Test_Test_Timeout\nfunc Test_Test_Timeout(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/\", testEmptyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil), TestConfig{\n\t\tTimeout: 0,\n\t})\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tapp.Get(\"timeout\", func(_ Ctx) error {\n\t\ttime.Sleep(200 * time.Millisecond)\n\t\treturn nil\n\t})\n\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/timeout\", nil), TestConfig{\n\t\tTimeout:       20 * time.Millisecond,\n\t\tFailOnTimeout: true,\n\t})\n\trequire.Error(t, err, \"app.Test(req)\")\n}\n\ntype errorReader int\n\nvar errErrorReader = errors.New(\"errorReader\")\n\nfunc (errorReader) Read([]byte) (int, error) {\n\treturn 0, errErrorReader\n}\n\n// go test -run Test_Test_DumpError\nfunc Test_Test_DumpError(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/\", testEmptyHandler)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", errorReader(0)))\n\trequire.Nil(t, resp)\n\trequire.ErrorIs(t, err, errErrorReader)\n}\n\n// go test -run Test_App_Handler\nfunc Test_App_Handler(t *testing.T) {\n\tt.Parallel()\n\th := New().Handler()\n\trequire.Equal(t, \"fasthttp.RequestHandler\", reflect.TypeOf(h).String())\n}\n\ntype invalidView struct{}\n\nfunc (invalidView) Load() error { return errors.New(\"invalid view\") }\n\nfunc (invalidView) Render(io.Writer, string, any, ...string) error { panic(\"implement me\") }\n\n// go test -run Test_App_Init_Error_View\nfunc Test_App_Init_Error_View(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{Views: invalidView{}})\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trequire.Equal(t, \"implement me\", fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}()\n\n\terr := app.config.Views.Render(nil, \"\", nil)\n\trequire.NoError(t, err)\n}\n\n// go test -run Test_App_Stack\nfunc Test_App_Stack(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(\"/path0\", testEmptyHandler)\n\tapp.Get(\"/path1\", testEmptyHandler)\n\tapp.Get(\"/path2\", testEmptyHandler)\n\tapp.Post(\"/path3\", testEmptyHandler)\n\n\tstack := app.Stack()\n\tmethodList := app.config.RequestMethods\n\trequire.Equal(t, len(methodList), len(stack))\n\trequire.Len(t, stack[app.methodInt(MethodGet)], 3)\n\trequire.Len(t, stack[app.methodInt(MethodHead)], 1)\n\trequire.Len(t, stack[app.methodInt(MethodPost)], 2)\n\trequire.Len(t, stack[app.methodInt(MethodPut)], 1)\n\trequire.Len(t, stack[app.methodInt(MethodPatch)], 1)\n\trequire.Len(t, stack[app.methodInt(MethodDelete)], 1)\n\trequire.Len(t, stack[app.methodInt(MethodConnect)], 1)\n\trequire.Len(t, stack[app.methodInt(MethodOptions)], 1)\n\trequire.Len(t, stack[app.methodInt(MethodTrace)], 1)\n}\n\n// go test -run Test_App_HandlersCount\nfunc Test_App_HandlersCount(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Use(\"/path0\", testEmptyHandler)\n\tapp.Get(\"/path2\", testEmptyHandler)\n\tapp.Post(\"/path3\", testEmptyHandler)\n\n\tcount := app.HandlersCount()\n\trequire.Equal(t, uint32(3), count)\n}\n\n// go test -run Test_App_ReadTimeout\nfunc Test_App_ReadTimeout(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tReadTimeout:      time.Nanosecond,\n\t\tIdleTimeout:      time.Minute,\n\t\tDisableKeepalive: true,\n\t})\n\n\tapp.Get(\"/read-timeout\", func(c Ctx) error {\n\t\treturn c.SendString(\"I should not be sent\")\n\t})\n\n\tgo func() {\n\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\tconn, err := net.Dial(NetworkTCP4, \"127.0.0.1:4004\")\n\t\tassert.NoError(t, err)\n\t\tdefer func(conn net.Conn) {\n\t\t\terr := conn.Close()\n\t\t\tassert.NoError(t, err)\n\t\t}(conn)\n\n\t\t_, err = conn.Write([]byte(\"HEAD /read-timeout HTTP/1.1\\r\\n\"))\n\t\tassert.NoError(t, err)\n\n\t\tbuf := make([]byte, 1024)\n\t\tvar n int\n\t\tn, err = conn.Read(buf)\n\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, bytes.Contains(buf[:n], []byte(\"408 Request Timeout\")))\n\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":4004\", ListenConfig{DisableStartupMessage: true}))\n}\n\n// go test -run Test_App_BadRequest\nfunc Test_App_BadRequest(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/bad-request\", func(c Ctx) error {\n\t\treturn c.SendString(\"I should not be sent\")\n\t})\n\n\tgo func() {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tconn, err := net.Dial(NetworkTCP4, \"127.0.0.1:4005\")\n\t\tassert.NoError(t, err)\n\t\tdefer func(conn net.Conn) {\n\t\t\terr := conn.Close()\n\t\t\tassert.NoError(t, err)\n\t\t}(conn)\n\n\t\t_, err = conn.Write([]byte(\"BadRequest\\r\\n\"))\n\t\tassert.NoError(t, err)\n\n\t\tbuf := make([]byte, 1024)\n\t\tvar n int\n\t\tn, err = conn.Read(buf)\n\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, bytes.Contains(buf[:n], []byte(\"400 Bad Request\")))\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":4005\", ListenConfig{DisableStartupMessage: true}))\n}\n\n// go test -run Test_App_SmallReadBuffer\nfunc Test_App_SmallReadBuffer(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tReadBufferSize: 1,\n\t})\n\n\tapp.Get(\"/small-read-buffer\", func(c Ctx) error {\n\t\treturn c.SendString(\"I should not be sent\")\n\t})\n\n\tgo func() {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\treq, err := http.NewRequestWithContext(context.Background(), MethodGet, \"http://127.0.0.1:4006/small-read-buffer\", nil)\n\t\tassert.NoError(t, err)\n\t\tvar client http.Client\n\t\tresp, err := client.Do(req)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 431, resp.StatusCode)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":4006\", ListenConfig{DisableStartupMessage: true}))\n}\n\nfunc Test_App_Server(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\trequire.NotNil(t, app.Server())\n}\n\nfunc Test_App_Error_In_Fasthttp_Server(t *testing.T) {\n\tapp := New()\n\tapp.config.ErrorHandler = func(_ Ctx, _ error) error {\n\t\treturn errors.New(\"fake error\")\n\t}\n\tapp.server.GetOnly = true\n\n\tresp, err := app.Test(httptest.NewRequest(MethodPost, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 500, resp.StatusCode)\n}\n\n// go test -race -run Test_App_New_Test_Parallel\nfunc Test_App_New_Test_Parallel(t *testing.T) {\n\tt.Parallel()\n\tt.Run(\"Test_App_New_Test_Parallel_1\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New(Config{Immutable: true})\n\t\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\t\trequire.NoError(t, err)\n\t})\n\tt.Run(\"Test_App_New_Test_Parallel_2\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New(Config{Immutable: true})\n\t\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\t\trequire.NoError(t, err)\n\t})\n}\n\nfunc Test_App_ReadBodyStream(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{StreamRequestBody: true})\n\tapp.Post(\"/\", func(c Ctx) error {\n\t\t// Calling c.Body() automatically reads the entire stream.\n\t\treturn c.SendString(fmt.Sprintf(\"%v %s\", c.Request().IsBodyStream(), c.Body()))\n\t})\n\ttestString := \"this is a test\"\n\tresp, err := app.Test(httptest.NewRequest(MethodPost, \"/\", bytes.NewBufferString(testString)))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"io.ReadAll(resp.Body)\")\n\trequire.Equal(t, \"true \"+testString, string(body))\n}\n\nfunc Test_App_DisablePreParseMultipartForm(t *testing.T) {\n\tt.Parallel()\n\t// Must be used with both otherwise there is no point.\n\ttestString := \"this is a test\"\n\n\tapp := New(Config{DisablePreParseMultipartForm: true, StreamRequestBody: true})\n\tapp.Post(\"/\", func(c Ctx) error {\n\t\treq := c.Request()\n\t\tmpf, err := req.MultipartForm()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !req.IsBodyStream() {\n\t\t\treturn errors.New(\"not a body stream\")\n\t\t}\n\t\tfile, err := mpf.File[\"test\"][0].Open()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to open: %w\", err)\n\t\t}\n\t\tbuffer := make([]byte, len(testString))\n\t\tn, err := file.Read(buffer)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to read: %w\", err)\n\t\t}\n\t\tif n != len(testString) {\n\t\t\treturn errors.New(\"bad read length\")\n\t\t}\n\t\treturn c.Send(buffer)\n\t})\n\tb := &bytes.Buffer{}\n\tw := multipart.NewWriter(b)\n\twriter, err := w.CreateFormFile(\"test\", \"test\")\n\trequire.NoError(t, err, \"w.CreateFormFile\")\n\tn, err := writer.Write([]byte(testString))\n\trequire.NoError(t, err, \"writer.Write\")\n\trequire.Len(t, testString, n, \"writer n\")\n\trequire.NoError(t, w.Close(), \"w.Close()\")\n\n\treq := httptest.NewRequest(MethodPost, \"/\", b)\n\treq.Header.Set(\"Content-Type\", w.FormDataContentType())\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"io.ReadAll(resp.Body)\")\n\n\trequire.Equal(t, testString, string(body))\n}\n\nfunc Test_App_Test_no_timeout_infinitely(t *testing.T) {\n\tt.Parallel()\n\tvar err error\n\tc := make(chan int)\n\n\tgo func() {\n\t\tdefer func() { c <- 0 }()\n\t\tapp := New()\n\t\tapp.Get(\"/\", func(_ Ctx) error {\n\t\t\truntime.Goexit()\n\t\t\treturn nil\n\t\t})\n\n\t\treq := httptest.NewRequest(MethodGet, \"/\", nil)\n\t\t_, err = app.Test(req, TestConfig{\n\t\t\tTimeout: 0,\n\t\t})\n\t}()\n\n\ttk := time.NewTimer(5 * time.Second)\n\tdefer tk.Stop()\n\n\tselect {\n\tcase <-tk.C:\n\t\tt.Error(\"hanging test\")\n\t\tt.FailNow()\n\tcase <-c:\n\t}\n\n\tif err == nil {\n\t\tt.Error(\"unexpected success request\")\n\t\tt.FailNow()\n\t}\n}\n\nfunc Test_App_Test_timeout(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\ttime.Sleep(1 * time.Second)\n\t\treturn nil\n\t})\n\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil), TestConfig{\n\t\tTimeout:       100 * time.Millisecond,\n\t\tFailOnTimeout: true,\n\t})\n\trequire.Equal(t, os.ErrDeadlineExceeded, err)\n}\n\nfunc Test_App_Test_timeout_empty_response(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\ttime.Sleep(1 * time.Second)\n\t\treturn nil\n\t})\n\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil), TestConfig{\n\t\tTimeout:       100 * time.Millisecond,\n\t\tFailOnTimeout: false,\n\t})\n\trequire.Equal(t, errors.New(\"test: got empty response\"), err)\n}\n\nfunc Test_App_SetTLSHandler(t *testing.T) {\n\tt.Parallel()\n\ttlsHandler := &TLSHandler{clientHelloInfo: &tls.ClientHelloInfo{\n\t\tServerName: \"example.golang\",\n\t}}\n\n\tapp := New()\n\tapp.SetTLSHandler(tlsHandler)\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\trequire.Equal(t, \"example.golang\", c.ClientHelloInfo().ServerName)\n}\n\nfunc Test_App_AddCustomRequestMethod(t *testing.T) {\n\tt.Parallel()\n\tmethods := append(DefaultMethods, \"TEST\") //nolint:gocritic // We want a new slice here\n\tapp := New(Config{\n\t\tRequestMethods: methods,\n\t})\n\tappMethods := app.config.RequestMethods\n\n\t// method name is always uppercase - https://datatracker.ietf.org/doc/html/rfc7231#section-4.1\n\trequire.Equal(t, len(app.stack), len(appMethods))\n\trequire.Equal(t, len(app.stack), len(appMethods))\n\trequire.Equal(t, \"TEST\", appMethods[len(appMethods)-1])\n}\n\nfunc Test_App_GetRoutes(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\thandler := func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t}\n\tapp.Delete(\"/delete\", handler).Name(\"delete\")\n\tapp.Post(\"/post\", handler).Name(\"post\")\n\troutes := app.GetRoutes(false)\n\trequire.Len(t, routes, 2+len(app.config.RequestMethods))\n\tmethodMap := map[string]string{\"/delete\": \"delete\", \"/post\": \"post\"}\n\tfor _, route := range routes {\n\t\tname, ok := methodMap[route.Path]\n\t\tif ok {\n\t\t\trequire.Equal(t, name, route.Name)\n\t\t}\n\t}\n\n\troutes = app.GetRoutes(true)\n\trequire.Len(t, routes, 2)\n\tfor _, route := range routes {\n\t\tname, ok := methodMap[route.Path]\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, name, route.Name)\n\t}\n}\n\nfunc Test_Middleware_Route_Naming_With_Use(t *testing.T) {\n\tt.Parallel()\n\tnamed := \"named\"\n\tapp := New()\n\n\tapp.Get(\"/unnamed\", func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\n\tapp.Post(\"/named\", func(c Ctx) error {\n\t\treturn c.Next()\n\t}).Name(named)\n\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t}) // no name - logging MW\n\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t}).Name(\"corsMW\")\n\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t}).Name(\"compressMW\")\n\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t}) // no name - cache MW\n\n\tgrp := app.Group(\"/pages\").Name(\"pages.\")\n\tgrp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t}).Name(\"csrfMW\")\n\n\tgrp.Get(\"/home\", func(c Ctx) error {\n\t\treturn c.Next()\n\t}).Name(\"home\")\n\n\tgrp.Get(\"/unnamed\", func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\n\tfor _, route := range app.GetRoutes() {\n\t\tswitch route.Path {\n\t\tcase \"/\":\n\t\t\trequire.Equal(t, \"compressMW\", route.Name)\n\t\tcase \"/unnamed\":\n\t\t\trequire.Equal(t, \"\", route.Name)\n\t\tcase \"named\":\n\t\t\trequire.Equal(t, named, route.Name)\n\t\tcase \"/pages\":\n\t\t\trequire.Equal(t, \"pages.csrfMW\", route.Name)\n\t\tcase \"/pages/home\":\n\t\t\trequire.Equal(t, \"pages.home\", route.Name)\n\t\tcase \"/pages/unnamed\":\n\t\t\trequire.Equal(t, \"\", route.Name)\n\t\t}\n\t}\n}\n\nfunc Test_Route_Naming_Issue_2671_2685(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/\", emptyHandler).Name(\"index\")\n\trequire.Equal(t, \"/\", app.GetRoute(\"index\").Path)\n\n\tapp.Get(\"/a/:a_id\", emptyHandler).Name(\"a\")\n\trequire.Equal(t, \"/a/:a_id\", app.GetRoute(\"a\").Path)\n\n\tapp.Post(\"/b/:bId\", emptyHandler).Name(\"b\")\n\trequire.Equal(t, \"/b/:bId\", app.GetRoute(\"b\").Path)\n\n\tc := app.Group(\"/c\")\n\tc.Get(\"\", emptyHandler).Name(\"c.get\")\n\trequire.Equal(t, \"/c\", app.GetRoute(\"c.get\").Path)\n\n\tc.Post(\"\", emptyHandler).Name(\"c.post\")\n\trequire.Equal(t, \"/c\", app.GetRoute(\"c.post\").Path)\n\n\tc.Get(\"/d\", emptyHandler).Name(\"c.get.d\")\n\trequire.Equal(t, \"/c/d\", app.GetRoute(\"c.get.d\").Path)\n\n\td := app.Group(\"/d/:d_id\")\n\td.Get(\"\", emptyHandler).Name(\"d.get\")\n\trequire.Equal(t, \"/d/:d_id\", app.GetRoute(\"d.get\").Path)\n\n\td.Post(\"\", emptyHandler).Name(\"d.post\")\n\trequire.Equal(t, \"/d/:d_id\", app.GetRoute(\"d.post\").Path)\n\n\te := app.Group(\"/e/:eId\")\n\te.Get(\"\", emptyHandler).Name(\"e.get\")\n\trequire.Equal(t, \"/e/:eId\", app.GetRoute(\"e.get\").Path)\n\n\te.Post(\"\", emptyHandler).Name(\"e.post\")\n\trequire.Equal(t, \"/e/:eId\", app.GetRoute(\"e.post\").Path)\n\n\te.Get(\"f\", emptyHandler).Name(\"e.get.f\")\n\trequire.Equal(t, \"/e/:eId/f\", app.GetRoute(\"e.get.f\").Path)\n\n\tpostGroup := app.Group(\"/post/:postId\")\n\tpostGroup.Get(\"\", emptyHandler).Name(\"post.get\")\n\trequire.Equal(t, \"/post/:postId\", app.GetRoute(\"post.get\").Path)\n\n\tpostGroup.Post(\"\", emptyHandler).Name(\"post.update\")\n\trequire.Equal(t, \"/post/:postId\", app.GetRoute(\"post.update\").Path)\n\n\t// Add testcase for routes use the same PATH on different methods\n\tapp.Get(\"/users\", emptyHandler).Name(\"get-users\")\n\tapp.Post(\"/users\", emptyHandler).Name(\"add-user\")\n\tgetUsers := app.GetRoute(\"get-users\")\n\trequire.Equal(t, \"/users\", getUsers.Path)\n\n\taddUser := app.GetRoute(\"add-user\")\n\trequire.Equal(t, \"/users\", addUser.Path)\n\n\t// Add testcase for routes use the same PATH on different methods (for groups)\n\tnewGrp := app.Group(\"/name-test\")\n\tnewGrp.Get(\"/users\", emptyHandler).Name(\"grp-get-users\")\n\tnewGrp.Post(\"/users\", emptyHandler).Name(\"grp-add-user\")\n\tgetUsers = app.GetRoute(\"grp-get-users\")\n\trequire.Equal(t, \"/name-test/users\", getUsers.Path)\n\n\taddUser = app.GetRoute(\"grp-add-user\")\n\trequire.Equal(t, \"/name-test/users\", addUser.Path)\n\n\t// Add testcase for HEAD route naming\n\tapp.Get(\"/simple-route\", emptyHandler).Name(\"simple-route\")\n\tapp.Head(\"/simple-route\", emptyHandler).Name(\"simple-route2\")\n\n\tsRoute := app.GetRoute(\"simple-route\")\n\trequire.Equal(t, \"/simple-route\", sRoute.Path)\n\n\tsRoute2 := app.GetRoute(\"simple-route2\")\n\trequire.Equal(t, \"/simple-route\", sRoute2.Path)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Communication_Flow -benchmem -count=4\nfunc Benchmark_Communication_Flow(b *testing.B) {\n\tapp := New()\n\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(\"Hello, World!\")\n\t})\n\n\th := app.Handler()\n\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(MethodGet)\n\tfctx.Request.SetRequestURI(\"/\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(fctx)\n\t}\n\n\trequire.Equal(b, 200, fctx.Response.Header.StatusCode())\n\trequire.Equal(b, \"Hello, World!\", string(fctx.Response.Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcquireReleaseFlow -benchmem -count=4\nfunc Benchmark_Ctx_AcquireReleaseFlow(b *testing.B) {\n\tapp := New()\n\n\tfctx := &fasthttp.RequestCtx{}\n\n\tb.Run(\"withoutRequestCtx\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc, _ := app.AcquireCtx(fctx).(*DefaultCtx) //nolint:errcheck // not needed\n\t\t\tapp.ReleaseCtx(c)\n\t\t}\n\t})\n\n\tb.Run(\"withRequestCtx\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc, _ := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck // not needed\n\t\t\tapp.ReleaseCtx(c)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "bind.go",
          "type": "blob",
          "size": 7.88,
          "content": "package fiber\n\nimport (\n\t\"github.com/gofiber/fiber/v3/binder\"\n\t\"github.com/gofiber/utils/v2\"\n)\n\n// CustomBinder An interface to register custom binders.\ntype CustomBinder interface {\n\tName() string\n\tMIMETypes() []string\n\tParse(c Ctx, out any) error\n}\n\n// StructValidator is an interface to register custom struct validator for binding.\ntype StructValidator interface {\n\tValidate(out any) error\n}\n\n// Bind struct\ntype Bind struct {\n\tctx            Ctx\n\tdontHandleErrs bool\n}\n\n// WithoutAutoHandling If you want to handle binder errors manually, you can use `WithoutAutoHandling`.\n// It's default behavior of binder.\nfunc (b *Bind) WithoutAutoHandling() *Bind {\n\tb.dontHandleErrs = true\n\n\treturn b\n}\n\n// WithAutoHandling If you want to handle binder errors automatically, you can use `WithAutoHandling`.\n// If there's an error, it will return the error and set HTTP status to `400 Bad Request`.\n// You must still return on error explicitly\nfunc (b *Bind) WithAutoHandling() *Bind {\n\tb.dontHandleErrs = false\n\n\treturn b\n}\n\n// Check WithAutoHandling/WithoutAutoHandling errors and return it by usage.\nfunc (b *Bind) returnErr(err error) error {\n\tif err == nil || b.dontHandleErrs {\n\t\treturn err\n\t}\n\n\tb.ctx.Status(StatusBadRequest)\n\treturn NewError(StatusBadRequest, \"Bad request: \"+err.Error())\n}\n\n// Struct validation.\nfunc (b *Bind) validateStruct(out any) error {\n\tvalidator := b.ctx.App().config.StructValidator\n\tif validator != nil {\n\t\treturn validator.Validate(out)\n\t}\n\n\treturn nil\n}\n\n// Custom To use custom binders, you have to use this method.\n// You can register them from RegisterCustomBinder method of Fiber instance.\n// They're checked by name, if it's not found, it will return an error.\n// NOTE: WithAutoHandling/WithAutoHandling is still valid for Custom binders.\nfunc (b *Bind) Custom(name string, dest any) error {\n\tbinders := b.ctx.App().customBinders\n\tfor _, customBinder := range binders {\n\t\tif customBinder.Name() == name {\n\t\t\treturn b.returnErr(customBinder.Parse(b.ctx, dest))\n\t\t}\n\t}\n\n\treturn ErrCustomBinderNotFound\n}\n\n// Header binds the request header strings into the struct, map[string]string and map[string][]string.\nfunc (b *Bind) Header(out any) error {\n\tbind := binder.GetFromThePool[*binder.HeaderBinding](&binder.HeaderBinderPool)\n\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.HeaderBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(b.ctx.Request(), out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// RespHeader binds the response header strings into the struct, map[string]string and map[string][]string.\nfunc (b *Bind) RespHeader(out any) error {\n\tbind := binder.GetFromThePool[*binder.RespHeaderBinding](&binder.RespHeaderBinderPool)\n\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.RespHeaderBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(b.ctx.Response(), out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// Cookie binds the request cookie strings into the struct, map[string]string and map[string][]string.\n// NOTE: If your cookie is like key=val1,val2; they'll be binded as an slice if your map is map[string][]string. Else, it'll use last element of cookie.\nfunc (b *Bind) Cookie(out any) error {\n\tbind := binder.GetFromThePool[*binder.CookieBinding](&binder.CookieBinderPool)\n\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.CookieBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(&b.ctx.RequestCtx().Request, out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// Query binds the query string into the struct, map[string]string and map[string][]string.\nfunc (b *Bind) Query(out any) error {\n\tbind := binder.GetFromThePool[*binder.QueryBinding](&binder.QueryBinderPool)\n\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.QueryBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(&b.ctx.RequestCtx().Request, out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// JSON binds the body string into the struct.\nfunc (b *Bind) JSON(out any) error {\n\tbind := binder.GetFromThePool[*binder.JSONBinding](&binder.JSONBinderPool)\n\tbind.JSONDecoder = b.ctx.App().Config().JSONDecoder\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.JSONBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(b.ctx.Body(), out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// CBOR binds the body string into the struct.\nfunc (b *Bind) CBOR(out any) error {\n\tbind := binder.GetFromThePool[*binder.CBORBinding](&binder.CBORBinderPool)\n\tbind.CBORDecoder = b.ctx.App().Config().CBORDecoder\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.CBORBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(b.ctx.Body(), out)); err != nil {\n\t\treturn err\n\t}\n\treturn b.validateStruct(out)\n}\n\n// XML binds the body string into the struct.\nfunc (b *Bind) XML(out any) error {\n\tbind := binder.GetFromThePool[*binder.XMLBinding](&binder.XMLBinderPool)\n\tbind.XMLDecoder = b.ctx.App().config.XMLDecoder\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.XMLBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(b.ctx.Body(), out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// Form binds the form into the struct, map[string]string and map[string][]string.\n// If Content-Type is \"application/x-www-form-urlencoded\" or \"multipart/form-data\", it will bind the form values.\n//\n// Binding multipart files is not supported yet.\nfunc (b *Bind) Form(out any) error {\n\tbind := binder.GetFromThePool[*binder.FormBinding](&binder.FormBinderPool)\n\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbind.Reset()\n\t\tbinder.PutToThePool(&binder.FormBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(&b.ctx.RequestCtx().Request, out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// URI binds the route parameters into the struct, map[string]string and map[string][]string.\nfunc (b *Bind) URI(out any) error {\n\tbind := binder.GetFromThePool[*binder.URIBinding](&binder.URIBinderPool)\n\n\t// Reset & put binder\n\tdefer func() {\n\t\tbinder.PutToThePool(&binder.URIBinderPool, bind)\n\t}()\n\n\tif err := b.returnErr(bind.Bind(b.ctx.Route().Params, b.ctx.Params, out)); err != nil {\n\t\treturn err\n\t}\n\n\treturn b.validateStruct(out)\n}\n\n// Body binds the request body into the struct, map[string]string and map[string][]string.\n// It supports decoding the following content types based on the Content-Type header:\n// application/json, application/xml, application/x-www-form-urlencoded, multipart/form-data\n// If none of the content types above are matched, it'll take a look custom binders by checking the MIMETypes() method of custom binder.\n// If there're no custom binder for mime type of body, it will return a ErrUnprocessableEntity error.\nfunc (b *Bind) Body(out any) error {\n\t// Get content-type\n\tctype := utils.ToLower(utils.UnsafeString(b.ctx.RequestCtx().Request.Header.ContentType()))\n\tctype = binder.FilterFlags(utils.ParseVendorSpecificContentType(ctype))\n\n\t// Check custom binders\n\tbinders := b.ctx.App().customBinders\n\tfor _, customBinder := range binders {\n\t\tfor _, mime := range customBinder.MIMETypes() {\n\t\t\tif mime == ctype {\n\t\t\t\treturn b.returnErr(customBinder.Parse(b.ctx, out))\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parse body accordingly\n\tswitch ctype {\n\tcase MIMEApplicationJSON:\n\t\treturn b.JSON(out)\n\tcase MIMETextXML, MIMEApplicationXML:\n\t\treturn b.XML(out)\n\tcase MIMEApplicationCBOR:\n\t\treturn b.CBOR(out)\n\tcase MIMEApplicationForm, MIMEMultipartForm:\n\t\treturn b.Form(out)\n\t}\n\n\t// No suitable content type found\n\treturn ErrUnprocessableEntity\n}\n"
        },
        {
          "name": "bind_test.go",
          "type": "blob",
          "size": 50.33,
          "content": "//nolint:wrapcheck,tagliatelle // We must not wrap errors in tests\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/fxamacker/cbor/v2\"\n\t\"github.com/gofiber/fiber/v3/binder\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nconst helloWorld = \"hello world\"\n\n// go test -run Test_returnErr -v\nfunc Test_returnErr(t *testing.T) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Bind().WithAutoHandling().returnErr(nil)\n\trequire.NoError(t, err)\n}\n\n// go test -run Test_Bind_Query -v\nfunc Test_Bind_Query(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Query struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := new(Query)\n\trequire.NoError(t, c.Bind().Query(q))\n\trequire.Len(t, q.Hobby, 2)\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq = new(Query)\n\trequire.NoError(t, c.Bind().Query(q))\n\trequire.Len(t, q.Hobby, 2)\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer&hobby=basketball,football\")\n\tq = new(Query)\n\trequire.NoError(t, c.Bind().Query(q))\n\trequire.Len(t, q.Hobby, 3)\n\n\tempty := new(Query)\n\tc.Request().URI().SetQueryString(\"\")\n\trequire.NoError(t, c.Bind().Query(empty))\n\trequire.Empty(t, empty.Hobby)\n\n\ttype Query2 struct {\n\t\tName            string\n\t\tHobby           string\n\t\tDefault         string `query:\"default,default:hello\"`\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tDefaults        []string `query:\"defaults,default:hello|world\"`\n\t\tNo              []int64\n\t\tID              int\n\t\tBool            bool\n\t}\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1\")\n\tq2 := new(Query2)\n\tq2.Bool = true\n\tq2.Name = helloWorld\n\trequire.NoError(t, c.Bind().Query(q2))\n\trequire.Equal(t, \"basketball,football\", q2.Hobby)\n\trequire.True(t, q2.Bool)\n\trequire.Equal(t, \"tom\", q2.Name) // check value get overwritten\n\trequire.Equal(t, []string{\"milo\", \"coke\", \"pepsi\"}, q2.FavouriteDrinks)\n\tvar nilSlice []string\n\trequire.Equal(t, nilSlice, q2.Empty)\n\trequire.Equal(t, []string{\"\"}, q2.Alloc)\n\trequire.Equal(t, []int64{1}, q2.No)\n\trequire.Equal(t, \"hello\", q2.Default)\n\trequire.Equal(t, []string{\"hello\", \"world\"}, q2.Defaults)\n\n\ttype RequiredQuery struct {\n\t\tName string `query:\"name,required\"`\n\t}\n\trq := new(RequiredQuery)\n\tc.Request().URI().SetQueryString(\"\")\n\trequire.Equal(t, \"bind: name is empty\", c.Bind().Query(rq).Error())\n\n\ttype ArrayQuery struct {\n\t\tData []string\n\t}\n\taq := new(ArrayQuery)\n\tc.Request().URI().SetQueryString(\"data[]=john&data[]=doe\")\n\trequire.NoError(t, c.Bind().Query(aq))\n\trequire.Len(t, aq.Data, 2)\n}\n\n// go test -run Test_Bind_Query_Map -v\nfunc Test_Bind_Query_Map(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := make(map[string][]string)\n\trequire.NoError(t, c.Bind().Query(&q))\n\trequire.Len(t, q[\"hobby\"], 2)\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq = make(map[string][]string)\n\trequire.NoError(t, c.Bind().Query(&q))\n\trequire.Len(t, q[\"hobby\"], 2)\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer&hobby=basketball,football\")\n\tq = make(map[string][]string)\n\trequire.NoError(t, c.Bind().Query(&q))\n\trequire.Len(t, q[\"hobby\"], 3)\n\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=scoccer\")\n\tqq := make(map[string]string)\n\trequire.NoError(t, c.Bind().Query(&qq))\n\trequire.Equal(t, \"1\", qq[\"id\"])\n\n\tempty := make(map[string][]string)\n\tc.Request().URI().SetQueryString(\"\")\n\trequire.NoError(t, c.Bind().Query(&empty))\n\trequire.Empty(t, empty[\"hobby\"])\n\n\tem := make(map[string][]int)\n\tc.Request().URI().SetQueryString(\"\")\n\trequire.ErrorIs(t, c.Bind().Query(&em), binder.ErrMapNotConvertable)\n}\n\n// go test -run Test_Bind_Query_WithSetParserDecoder -v\nfunc Test_Bind_Query_WithSetParserDecoder(t *testing.T) {\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := binder.ParserType{\n\t\tCustomType: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tbinder.SetParserDecoder(binder.ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []binder.ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"query\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `query:\"date\"`\n\t\tTitle string     `query:\"title\"`\n\t\tBody  string     `query:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tq := new(NonRFCTimeInput)\n\n\tc.Request().URI().SetQueryString(\"date=2021-04-10&title=CustomDateTest&Body=October\")\n\trequire.NoError(t, c.Bind().Query(q))\n\trequire.Equal(t, \"CustomDateTest\", q.Title)\n\tdate := fmt.Sprintf(\"%v\", q.Date)\n\trequire.Equal(t, \"{0 63753609600 <nil>}\", date)\n\trequire.Equal(t, \"October\", q.Body)\n\n\tc.Request().URI().SetQueryString(\"date=2021-04-10&title&Body=October\")\n\tq = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\trequire.NoError(t, c.Bind().Query(q))\n\trequire.Equal(t, \"\", q.Title)\n}\n\n// go test -run Test_Bind_Query_Schema -v\nfunc Test_Bind_Query_Schema(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Query1 struct {\n\t\tName   string `query:\"name,required\"`\n\t\tNested struct {\n\t\t\tAge int `query:\"age\"`\n\t\t} `query:\"nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"name=tom&nested.age=10\")\n\tq := new(Query1)\n\trequire.NoError(t, c.Bind().Query(q))\n\n\tc.Request().URI().SetQueryString(\"namex=tom&nested.age=10\")\n\tq = new(Query1)\n\trequire.Equal(t, \"bind: name is empty\", c.Bind().Query(q).Error())\n\n\tc.Request().URI().SetQueryString(\"name=tom&nested.agex=10\")\n\tq = new(Query1)\n\trequire.NoError(t, c.Bind().Query(q))\n\n\tc.Request().URI().SetQueryString(\"name=tom&test.age=10\")\n\tq = new(Query1)\n\trequire.Equal(t, \"bind: nested is empty\", c.Bind().Query(q).Error())\n\n\ttype Query2 struct {\n\t\tName   string `query:\"name\"`\n\t\tNested struct {\n\t\t\tAge int `query:\"age,required\"`\n\t\t} `query:\"nested\"`\n\t}\n\tc.Request().URI().SetQueryString(\"name=tom&nested.age=10\")\n\tq2 := new(Query2)\n\trequire.NoError(t, c.Bind().Query(q2))\n\n\tc.Request().URI().SetQueryString(\"nested.age=10\")\n\tq2 = new(Query2)\n\trequire.NoError(t, c.Bind().Query(q2))\n\n\tc.Request().URI().SetQueryString(\"nested.agex=10\")\n\tq2 = new(Query2)\n\trequire.Equal(t, \"bind: nested.age is empty\", c.Bind().Query(q2).Error())\n\n\tc.Request().URI().SetQueryString(\"nested.agex=10\")\n\tq2 = new(Query2)\n\trequire.Equal(t, \"bind: nested.age is empty\", c.Bind().Query(q2).Error())\n\n\ttype Node struct {\n\t\tNext  *Node `query:\"next,required\"`\n\t\tValue int   `query:\"val,required\"`\n\t}\n\tc.Request().URI().SetQueryString(\"val=1&next.val=3\")\n\tn := new(Node)\n\trequire.NoError(t, c.Bind().Query(n))\n\trequire.Equal(t, 1, n.Value)\n\trequire.Equal(t, 3, n.Next.Value)\n\n\tc.Request().URI().SetQueryString(\"next.val=2\")\n\tn = new(Node)\n\trequire.Equal(t, \"bind: val is empty\", c.Bind().Query(n).Error())\n\n\tc.Request().URI().SetQueryString(\"val=3&next.value=2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\trequire.NoError(t, c.Bind().Query(n))\n\trequire.Equal(t, 3, n.Value)\n\trequire.Equal(t, 0, n.Next.Value)\n\n\ttype Person struct {\n\t\tName string `query:\"name\"`\n\t\tAge  int    `query:\"age\"`\n\t}\n\n\ttype CollectionQuery struct {\n\t\tData []Person `query:\"data\"`\n\t}\n\n\tc.Request().URI().SetQueryString(\"data[0][name]=john&data[0][age]=10&data[1][name]=doe&data[1][age]=12\")\n\tcq := new(CollectionQuery)\n\trequire.NoError(t, c.Bind().Query(cq))\n\trequire.Len(t, cq.Data, 2)\n\trequire.Equal(t, \"john\", cq.Data[0].Name)\n\trequire.Equal(t, 10, cq.Data[0].Age)\n\trequire.Equal(t, \"doe\", cq.Data[1].Name)\n\trequire.Equal(t, 12, cq.Data[1].Age)\n\n\tc.Request().URI().SetQueryString(\"data.0.name=john&data.0.age=10&data.1.name=doe&data.1.age=12\")\n\tcq = new(CollectionQuery)\n\trequire.NoError(t, c.Bind().Query(cq))\n\trequire.Len(t, cq.Data, 2)\n\trequire.Equal(t, \"john\", cq.Data[0].Name)\n\trequire.Equal(t, 10, cq.Data[0].Age)\n\trequire.Equal(t, \"doe\", cq.Data[1].Name)\n\trequire.Equal(t, 12, cq.Data[1].Age)\n}\n\n// go test -run Test_Bind_Header -v\nfunc Test_Bind_Header(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Header struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := new(Header)\n\trequire.NoError(t, c.Bind().Header(q))\n\trequire.Len(t, q.Hobby, 1)\n\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Header)\n\trequire.NoError(t, c.Bind().Header(q))\n\trequire.Len(t, q.Hobby, 1)\n\n\tempty := new(Header)\n\tc.Request().Header.Del(\"hobby\")\n\trequire.NoError(t, c.Bind().Query(empty))\n\trequire.Empty(t, empty.Hobby)\n\n\ttype Header2 struct {\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t\tID              int\n\t\tBool            bool\n\t}\n\n\tc.Request().Header.Add(\"id\", \"2\")\n\tc.Request().Header.Add(\"Name\", \"Jane Doe\")\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"go,fiber\")\n\tc.Request().Header.Add(\"favouriteDrinks\", \"milo,coke,pepsi\")\n\tc.Request().Header.Add(\"alloc\", \"\")\n\tc.Request().Header.Add(\"no\", \"1\")\n\n\th2 := new(Header2)\n\th2.Bool = true\n\th2.Name = helloWorld\n\trequire.NoError(t, c.Bind().Header(h2))\n\trequire.Equal(t, \"go,fiber\", h2.Hobby)\n\trequire.True(t, h2.Bool)\n\trequire.Equal(t, \"Jane Doe\", h2.Name) // check value get overwritten\n\trequire.Equal(t, []string{\"milo,coke,pepsi\"}, h2.FavouriteDrinks)\n\tvar nilSlice []string\n\trequire.Equal(t, nilSlice, h2.Empty)\n\trequire.Equal(t, []string{\"\"}, h2.Alloc)\n\trequire.Equal(t, []int64{1}, h2.No)\n\n\ttype RequiredHeader struct {\n\t\tName string `header:\"name,required\"`\n\t}\n\trh := new(RequiredHeader)\n\tc.Request().Header.Del(\"name\")\n\trequire.Equal(t, \"bind: name is empty\", c.Bind().Header(rh).Error())\n}\n\n// go test -run Test_Bind_Header_Map -v\nfunc Test_Bind_Header_Map(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := make(map[string][]string, 0)\n\trequire.NoError(t, c.Bind().Header(&q))\n\trequire.Len(t, q[\"Hobby\"], 1)\n\n\tc.Request().Header.Del(\"hobby\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = make(map[string][]string, 0)\n\trequire.NoError(t, c.Bind().Header(&q))\n\trequire.Len(t, q[\"Hobby\"], 1)\n\n\tempty := make(map[string][]string, 0)\n\tc.Request().Header.Del(\"hobby\")\n\trequire.NoError(t, c.Bind().Query(&empty))\n\trequire.Empty(t, empty[\"Hobby\"])\n}\n\n// go test -run Test_Bind_Header_WithSetParserDecoder -v\nfunc Test_Bind_Header_WithSetParserDecoder(t *testing.T) {\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := binder.ParserType{\n\t\tCustomType: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tbinder.SetParserDecoder(binder.ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []binder.ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"req\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `req:\"date\"`\n\t\tTitle string     `req:\"title\"`\n\t\tBody  string     `req:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tr := new(NonRFCTimeInput)\n\n\tc.Request().Header.Add(\"Date\", \"2021-04-10\")\n\tc.Request().Header.Add(\"Title\", \"CustomDateTest\")\n\tc.Request().Header.Add(\"Body\", \"October\")\n\n\trequire.NoError(t, c.Bind().Header(r))\n\trequire.Equal(t, \"CustomDateTest\", r.Title)\n\tdate := fmt.Sprintf(\"%v\", r.Date)\n\trequire.Equal(t, \"{0 63753609600 <nil>}\", date)\n\trequire.Equal(t, \"October\", r.Body)\n\n\tc.Request().Header.Add(\"Title\", \"\")\n\tr = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\trequire.NoError(t, c.Bind().Header(r))\n\trequire.Equal(t, \"\", r.Title)\n}\n\n// go test -run Test_Bind_Header_Schema -v\nfunc Test_Bind_Header_Schema(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Header1 struct {\n\t\tName   string `header:\"Name,required\"`\n\t\tNested struct {\n\t\t\tAge int `header:\"Age\"`\n\t\t} `header:\"Nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Add(\"Nested.Age\", \"10\")\n\tq := new(Header1)\n\trequire.NoError(t, c.Bind().Header(q))\n\n\tc.Request().Header.Del(\"Name\")\n\tq = new(Header1)\n\trequire.Equal(t, \"bind: Name is empty\", c.Bind().Header(q).Error())\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Del(\"Nested.Age\")\n\tc.Request().Header.Add(\"Nested.Agex\", \"10\")\n\tq = new(Header1)\n\trequire.NoError(t, c.Bind().Header(q))\n\n\tc.Request().Header.Del(\"Nested.Agex\")\n\tq = new(Header1)\n\trequire.Equal(t, \"bind: Nested is empty\", c.Bind().Header(q).Error())\n\n\tc.Request().Header.Del(\"Nested.Agex\")\n\tc.Request().Header.Del(\"Name\")\n\n\ttype Header2 struct {\n\t\tName   string `header:\"Name\"`\n\t\tNested struct {\n\t\t\tAge int `header:\"age,required\"`\n\t\t} `header:\"Nested\"`\n\t}\n\n\tc.Request().Header.Add(\"Name\", \"tom\")\n\tc.Request().Header.Add(\"Nested.Age\", \"10\")\n\n\th2 := new(Header2)\n\trequire.NoError(t, c.Bind().Header(h2))\n\n\tc.Request().Header.Del(\"Name\")\n\th2 = new(Header2)\n\trequire.NoError(t, c.Bind().Header(h2))\n\n\tc.Request().Header.Del(\"Name\")\n\tc.Request().Header.Del(\"Nested.Age\")\n\tc.Request().Header.Add(\"Nested.Agex\", \"10\")\n\th2 = new(Header2)\n\trequire.Equal(t, \"bind: Nested.age is empty\", c.Bind().Header(h2).Error())\n\n\ttype Node struct {\n\t\tNext  *Node `header:\"Next,required\"`\n\t\tValue int   `header:\"Val,required\"`\n\t}\n\tc.Request().Header.Add(\"Val\", \"1\")\n\tc.Request().Header.Add(\"Next.Val\", \"3\")\n\tn := new(Node)\n\trequire.NoError(t, c.Bind().Header(n))\n\trequire.Equal(t, 1, n.Value)\n\trequire.Equal(t, 3, n.Next.Value)\n\n\tc.Request().Header.Del(\"Val\")\n\tn = new(Node)\n\trequire.Equal(t, \"bind: Val is empty\", c.Bind().Header(n).Error())\n\n\tc.Request().Header.Add(\"Val\", \"3\")\n\tc.Request().Header.Del(\"Next.Val\")\n\tc.Request().Header.Add(\"Next.Value\", \"2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\trequire.NoError(t, c.Bind().Header(n))\n\trequire.Equal(t, 3, n.Value)\n\trequire.Equal(t, 0, n.Next.Value)\n}\n\n// go test -run Test_Bind_Resp_Header -v\nfunc Test_Bind_RespHeader(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Header struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Response().Header.Add(\"id\", \"1\")\n\tc.Response().Header.Add(\"Name\", \"John Doe\")\n\tc.Response().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := new(Header)\n\trequire.NoError(t, c.Bind().RespHeader(q))\n\trequire.Len(t, q.Hobby, 2)\n\n\tc.Response().Header.Del(\"hobby\")\n\tc.Response().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Header)\n\trequire.NoError(t, c.Bind().RespHeader(q))\n\trequire.Len(t, q.Hobby, 3)\n\n\tempty := new(Header)\n\tc.Response().Header.Del(\"hobby\")\n\trequire.NoError(t, c.Bind().Query(empty))\n\trequire.Empty(t, empty.Hobby)\n\n\ttype Header2 struct {\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t\tID              int\n\t\tBool            bool\n\t}\n\n\tc.Response().Header.Add(\"id\", \"2\")\n\tc.Response().Header.Add(\"Name\", \"Jane Doe\")\n\tc.Response().Header.Del(\"hobby\")\n\tc.Response().Header.Add(\"Hobby\", \"go,fiber\")\n\tc.Response().Header.Add(\"favouriteDrinks\", \"milo,coke,pepsi\")\n\tc.Response().Header.Add(\"alloc\", \"\")\n\tc.Response().Header.Add(\"no\", \"1\")\n\n\th2 := new(Header2)\n\th2.Bool = true\n\th2.Name = helloWorld\n\trequire.NoError(t, c.Bind().RespHeader(h2))\n\trequire.Equal(t, \"go,fiber\", h2.Hobby)\n\trequire.True(t, h2.Bool)\n\trequire.Equal(t, \"Jane Doe\", h2.Name) // check value get overwritten\n\trequire.Equal(t, []string{\"milo\", \"coke\", \"pepsi\"}, h2.FavouriteDrinks)\n\tvar nilSlice []string\n\trequire.Equal(t, nilSlice, h2.Empty)\n\trequire.Equal(t, []string{\"\"}, h2.Alloc)\n\trequire.Equal(t, []int64{1}, h2.No)\n\n\ttype RequiredHeader struct {\n\t\tName string `respHeader:\"name,required\"`\n\t}\n\trh := new(RequiredHeader)\n\tc.Response().Header.Del(\"name\")\n\trequire.Equal(t, \"bind: name is empty\", c.Bind().RespHeader(rh).Error())\n}\n\n// go test -run Test_Bind_RespHeader_Map -v\nfunc Test_Bind_RespHeader_Map(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Response().Header.Add(\"id\", \"1\")\n\tc.Response().Header.Add(\"Name\", \"John Doe\")\n\tc.Response().Header.Add(\"Hobby\", \"golang,fiber\")\n\tq := make(map[string][]string, 0)\n\trequire.NoError(t, c.Bind().RespHeader(&q))\n\trequire.Len(t, q[\"Hobby\"], 1)\n\n\tc.Response().Header.Del(\"hobby\")\n\tc.Response().Header.Add(\"Hobby\", \"golang,fiber,go\")\n\tq = make(map[string][]string, 0)\n\trequire.NoError(t, c.Bind().RespHeader(&q))\n\trequire.Len(t, q[\"Hobby\"], 1)\n\n\tempty := make(map[string][]string, 0)\n\tc.Response().Header.Del(\"hobby\")\n\trequire.NoError(t, c.Bind().Query(&empty))\n\trequire.Empty(t, empty[\"Hobby\"])\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Query -benchmem -count=4\nfunc Benchmark_Bind_Query(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Query struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Query(q)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"tom\", q.Name)\n\trequire.Equal(b, 1, q.ID)\n\trequire.Len(b, q.Hobby, 2)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Query_Default -benchmem -count=4\nfunc Benchmark_Bind_Query_Default(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Query struct {\n\t\tName  string   `query:\"name,default:tom\"`\n\t\tHobby []string `query:\"hobby,default:football|basketball\"`\n\t\tID    int      `query:\"id,default:1\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t*q = Query{}\n\t\terr = c.Bind().Query(q)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"tom\", q.Name)\n\trequire.Equal(b, 1, q.ID)\n\trequire.Len(b, q.Hobby, 2)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Query_Map -benchmem -count=4\nfunc Benchmark_Bind_Query_Map(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball&hobby=football\")\n\tq := make(map[string][]string)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Query(&q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Query_WithParseParam -benchmem -count=4\nfunc Benchmark_Bind_Query_WithParseParam(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Person struct {\n\t\tName string `query:\"name\"`\n\t\tAge  int    `query:\"age\"`\n\t}\n\n\ttype CollectionQuery struct {\n\t\tData []Person `query:\"data\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"data[0][name]=john&data[0][age]=10\")\n\tcq := new(CollectionQuery)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Query(cq)\n\t}\n\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Query_Comma -benchmem -count=4\nfunc Benchmark_Bind_Query_Comma(b *testing.B) {\n\tvar err error\n\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Query struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football\")\n\tq := new(Query)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Query(q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Header -benchmem -count=4\nfunc Benchmark_Bind_Header(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype ReqHeader struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\n\tq := new(ReqHeader)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Header(q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Header_Map -benchmem -count=4\nfunc Benchmark_Bind_Header_Map(b *testing.B) {\n\tvar err error\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.Add(\"id\", \"1\")\n\tc.Request().Header.Add(\"Name\", \"John Doe\")\n\tc.Request().Header.Add(\"Hobby\", \"golang,fiber\")\n\n\tq := make(map[string][]string)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Header(&q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_RespHeader -benchmem -count=4\nfunc Benchmark_Bind_RespHeader(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype ReqHeader struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Response().Header.Add(\"id\", \"1\")\n\tc.Response().Header.Add(\"Name\", \"John Doe\")\n\tc.Response().Header.Add(\"Hobby\", \"golang,fiber\")\n\n\tq := new(ReqHeader)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().RespHeader(q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_RespHeader_Map -benchmem -count=4\nfunc Benchmark_Bind_RespHeader_Map(b *testing.B) {\n\tvar err error\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Response().Header.Add(\"id\", \"1\")\n\tc.Response().Header.Add(\"Name\", \"John Doe\")\n\tc.Response().Header.Add(\"Hobby\", \"golang,fiber\")\n\n\tq := make(map[string][]string)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().RespHeader(&q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -run Test_Bind_Body_Compression\nfunc Test_Bind_Body(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\treqBody := []byte(`{\"name\":\"john\"}`)\n\n\ttype Demo struct {\n\t\tName  string   `json:\"name\" xml:\"name\" form:\"name\" query:\"name\"`\n\t\tNames []string `json:\"names\" xml:\"names\" form:\"names\" query:\"names\"`\n\t}\n\n\t// Helper function to test compressed bodies\n\ttestCompressedBody := func(t *testing.T, compressedBody []byte, encoding string) {\n\t\tt.Helper()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\t\tc.Request().Header.Set(fasthttp.HeaderContentEncoding, encoding)\n\t\tc.Request().SetBody(compressedBody)\n\t\tc.Request().Header.SetContentLength(len(compressedBody))\n\t\td := new(Demo)\n\t\trequire.NoError(t, c.Bind().Body(d))\n\t\trequire.Equal(t, \"john\", d.Name)\n\t\tc.Request().Header.Del(fasthttp.HeaderContentEncoding)\n\t}\n\n\tt.Run(\"Gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcompressedBody := fasthttp.AppendGzipBytes(nil, reqBody)\n\t\trequire.NotEqual(t, reqBody, compressedBody)\n\t\ttestCompressedBody(t, compressedBody, \"gzip\")\n\t})\n\n\tt.Run(\"Deflate\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcompressedBody := fasthttp.AppendDeflateBytes(nil, reqBody)\n\t\trequire.NotEqual(t, reqBody, compressedBody)\n\t\ttestCompressedBody(t, compressedBody, \"deflate\")\n\t})\n\n\tt.Run(\"Brotli\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcompressedBody := fasthttp.AppendBrotliBytes(nil, reqBody)\n\t\trequire.NotEqual(t, reqBody, compressedBody)\n\t\ttestCompressedBody(t, compressedBody, \"br\")\n\t})\n\n\tt.Run(\"Zstd\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tcompressedBody := fasthttp.AppendZstdBytes(nil, reqBody)\n\t\trequire.NotEqual(t, reqBody, compressedBody)\n\t\ttestCompressedBody(t, compressedBody, \"zstd\")\n\t})\n\n\ttestDecodeParser := func(t *testing.T, contentType string, body []byte) {\n\t\tt.Helper()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody(body)\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\td := new(Demo)\n\t\trequire.NoError(t, c.Bind().Body(d))\n\t\trequire.Equal(t, \"john\", d.Name)\n\t}\n\n\tt.Run(\"JSON\", func(t *testing.T) {\n\t\ttestDecodeParser(t, MIMEApplicationJSON, []byte(`{\"name\":\"john\"}`))\n\t})\n\tt.Run(\"CBOR\", func(t *testing.T) {\n\t\tenc, err := cbor.Marshal(&Demo{Name: \"john\"})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\ttestDecodeParser(t, MIMEApplicationCBOR, enc)\n\n\t\t// Test invalid CBOR data\n\t\tt.Run(\"Invalid\", func(t *testing.T) {\n\t\t\tinvalidData := []byte{0xFF, 0xFF} // Invalid CBOR data\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().Header.SetContentType(MIMEApplicationCBOR)\n\t\t\tc.Request().SetBody(invalidData)\n\t\t\td := new(Demo)\n\t\t\trequire.Error(t, c.Bind().Body(d))\n\t\t})\n\t})\n\n\tt.Run(\"XML\", func(t *testing.T) {\n\t\ttestDecodeParser(t, MIMEApplicationXML, []byte(`<Demo><name>john</name></Demo>`))\n\t})\n\n\tt.Run(\"Form\", func(t *testing.T) {\n\t\ttestDecodeParser(t, MIMEApplicationForm, []byte(\"name=john\"))\n\t})\n\n\tt.Run(\"MultipartForm\", func(t *testing.T) {\n\t\ttestDecodeParser(t, MIMEMultipartForm+`;boundary=\"b\"`, []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\"))\n\t})\n\n\ttestDecodeParserError := func(t *testing.T, contentType, body string) {\n\t\tt.Helper()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\trequire.Error(t, c.Bind().Body(nil))\n\t}\n\n\tt.Run(\"ErrorInvalidContentType\", func(t *testing.T) {\n\t\ttestDecodeParserError(t, \"invalid-content-type\", \"\")\n\t})\n\n\tt.Run(\"ErrorMalformedMultipart\", func(t *testing.T) {\n\t\ttestDecodeParserError(t, MIMEMultipartForm+`;boundary=\"b\"`, \"--b\")\n\t})\n\n\ttype CollectionQuery struct {\n\t\tData []Demo `query:\"data\"`\n\t}\n\n\tt.Run(\"MultipartCollectionQueryDotNotation\", func(t *testing.T) {\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Reset()\n\n\t\tbuf := &bytes.Buffer{}\n\t\twriter := multipart.NewWriter(buf)\n\t\trequire.NoError(t, writer.WriteField(\"data.0.name\", \"john\"))\n\t\trequire.NoError(t, writer.WriteField(\"data.1.name\", \"doe\"))\n\t\trequire.NoError(t, writer.Close())\n\n\t\tc.Request().Header.SetContentType(writer.FormDataContentType())\n\t\tc.Request().SetBody(buf.Bytes())\n\t\tc.Request().Header.SetContentLength(len(c.Body()))\n\n\t\tcq := new(CollectionQuery)\n\t\trequire.NoError(t, c.Bind().Body(cq))\n\t\trequire.Len(t, cq.Data, 2)\n\t\trequire.Equal(t, \"john\", cq.Data[0].Name)\n\t\trequire.Equal(t, \"doe\", cq.Data[1].Name)\n\t})\n\n\tt.Run(\"MultipartCollectionQuerySquareBrackets\", func(t *testing.T) {\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Reset()\n\n\t\tbuf := &bytes.Buffer{}\n\t\twriter := multipart.NewWriter(buf)\n\t\trequire.NoError(t, writer.WriteField(\"data[0][name]\", \"john\"))\n\t\trequire.NoError(t, writer.WriteField(\"data[1][name]\", \"doe\"))\n\t\trequire.NoError(t, writer.Close())\n\n\t\tc.Request().Header.SetContentType(writer.FormDataContentType())\n\t\tc.Request().SetBody(buf.Bytes())\n\t\tc.Request().Header.SetContentLength(len(c.Body()))\n\n\t\tcq := new(CollectionQuery)\n\t\trequire.NoError(t, c.Bind().Body(cq))\n\t\trequire.Len(t, cq.Data, 2)\n\t\trequire.Equal(t, \"john\", cq.Data[0].Name)\n\t\trequire.Equal(t, \"doe\", cq.Data[1].Name)\n\t})\n\n\tt.Run(\"CollectionQuerySquareBrackets\", func(t *testing.T) {\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Reset()\n\t\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\t\tc.Request().SetBody([]byte(\"data[0][name]=john&data[1][name]=doe\"))\n\t\tc.Request().Header.SetContentLength(len(c.Body()))\n\t\tcq := new(CollectionQuery)\n\t\trequire.NoError(t, c.Bind().Body(cq))\n\t\trequire.Len(t, cq.Data, 2)\n\t\trequire.Equal(t, \"john\", cq.Data[0].Name)\n\t\trequire.Equal(t, \"doe\", cq.Data[1].Name)\n\t})\n\n\tt.Run(\"CollectionQueryDotNotation\", func(t *testing.T) {\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Reset()\n\t\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\t\tc.Request().SetBody([]byte(\"data.0.name=john&data.1.name=doe\"))\n\t\tc.Request().Header.SetContentLength(len(c.Body()))\n\t\tcq := new(CollectionQuery)\n\t\trequire.NoError(t, c.Bind().Body(cq))\n\t\trequire.Len(t, cq.Data, 2)\n\t\trequire.Equal(t, \"john\", cq.Data[0].Name)\n\t\trequire.Equal(t, \"doe\", cq.Data[1].Name)\n\t})\n}\n\n// go test -run Test_Bind_Body_WithSetParserDecoder\nfunc Test_Bind_Body_WithSetParserDecoder(t *testing.T) {\n\ttype CustomTime time.Time\n\n\ttimeConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tcustomTime := binder.ParserType{\n\t\tCustomType: CustomTime{},\n\t\tConverter:  timeConverter,\n\t}\n\n\tbinder.SetParserDecoder(binder.ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []binder.ParserType{customTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"form\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Demo struct {\n\t\tDate  CustomTime `form:\"date\"`\n\t\tTitle string     `form:\"title\"`\n\t\tBody  string     `form:\"body\"`\n\t}\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\td := Demo{\n\t\t\tTitle: \"Existing title\",\n\t\t\tBody:  \"Existing Body\",\n\t\t}\n\t\trequire.NoError(t, c.Bind().Body(&d))\n\t\tdate := fmt.Sprintf(\"%v\", d.Date)\n\t\trequire.Equal(t, \"{0 63743587200 <nil>}\", date)\n\t\trequire.Equal(t, \"\", d.Title)\n\t\trequire.Equal(t, \"New Body\", d.Body)\n\t}\n\n\ttestDecodeParser(MIMEApplicationForm, \"date=2020-12-15&title=&body=New Body\")\n\ttestDecodeParser(MIMEMultipartForm+`; boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"date\\\"\\r\\n\\r\\n2020-12-15\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"title\\\"\\r\\n\\r\\n\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"body\\\"\\r\\n\\r\\nNew Body\\r\\n--b--\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_JSON -benchmem -count=4\nfunc Benchmark_Bind_Body_JSON(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Demo struct {\n\t\tName string `json:\"name\"`\n\t}\n\tbody := []byte(`{\"name\":\"john\"}`)\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(d)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_XML -benchmem -count=4\nfunc Benchmark_Bind_Body_XML(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Demo struct {\n\t\tName string `xml:\"name\"`\n\t}\n\tbody := []byte(\"<Demo><name>john</name></Demo>\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationXML)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(d)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_CBOR -benchmem -count=4\nfunc Benchmark_Bind_Body_CBOR(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Demo struct {\n\t\tName string `json:\"name\"`\n\t}\n\tbody, err := cbor.Marshal(&Demo{Name: \"john\"})\n\tif err != nil {\n\t\tb.Error(err)\n\t}\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationCBOR)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(d)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_Form -benchmem -count=4\nfunc Benchmark_Bind_Body_Form(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Demo struct {\n\t\tName string `form:\"name\"`\n\t}\n\tbody := []byte(\"name=john\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(d)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_MultipartForm -benchmem -count=4\nfunc Benchmark_Bind_Body_MultipartForm(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Demo struct {\n\t\tName string `form:\"name\"`\n\t}\n\n\tbuf := &bytes.Buffer{}\n\twriter := multipart.NewWriter(buf)\n\trequire.NoError(b, writer.WriteField(\"name\", \"john\"))\n\trequire.NoError(b, writer.Close())\n\tbody := buf.Bytes()\n\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEMultipartForm + `;boundary=` + writer.Boundary())\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(d)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d.Name)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_MultipartForm_Nested -benchmem -count=4\nfunc Benchmark_Bind_Body_MultipartForm_Nested(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Person struct {\n\t\tName string `form:\"name\"`\n\t\tAge  int    `form:\"age\"`\n\t}\n\n\ttype Demo struct {\n\t\tName    string   `form:\"name\"`\n\t\tPersons []Person `form:\"persons\"`\n\t}\n\n\tbuf := &bytes.Buffer{}\n\twriter := multipart.NewWriter(buf)\n\trequire.NoError(b, writer.WriteField(\"name\", \"john\"))\n\trequire.NoError(b, writer.WriteField(\"persons.0.name\", \"john\"))\n\trequire.NoError(b, writer.WriteField(\"persons[0][age]\", \"10\"))\n\trequire.NoError(b, writer.WriteField(\"persons[1][name]\", \"doe\"))\n\trequire.NoError(b, writer.WriteField(\"persons.1.age\", \"20\"))\n\trequire.NoError(b, writer.Close())\n\tbody := buf.Bytes()\n\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEMultipartForm + `;boundary=` + writer.Boundary())\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(d)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d.Name)\n\trequire.Equal(b, \"john\", d.Persons[0].Name)\n\trequire.Equal(b, 10, d.Persons[0].Age)\n\trequire.Equal(b, \"doe\", d.Persons[1].Name)\n\trequire.Equal(b, 20, d.Persons[1].Age)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_Body_Form_Map -benchmem -count=4\nfunc Benchmark_Bind_Body_Form_Map(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tbody := []byte(\"name=john\")\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\tc.Request().Header.SetContentLength(len(body))\n\td := make(map[string]string)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Body(&d)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", d[\"name\"])\n}\n\n// go test -run Test_Bind_URI\nfunc Test_Bind_URI(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/test1/userId/role/:roleId\", func(c Ctx) error {\n\t\ttype Demo struct {\n\t\t\tUserID uint `uri:\"userId\"`\n\t\t\tRoleID uint `uri:\"roleId\"`\n\t\t}\n\t\td := new(Demo)\n\t\tif err := c.Bind().URI(d); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\trequire.Equal(t, uint(111), d.UserID)\n\t\trequire.Equal(t, uint(222), d.RoleID)\n\t\treturn nil\n\t})\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test1/111/role/222\", nil))\n\trequire.NoError(t, err)\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/111/role/222\", nil))\n\trequire.NoError(t, err)\n}\n\n// go test -run Test_Bind_URI_Map\nfunc Test_Bind_URI_Map(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/test1/userId/role/:roleId\", func(c Ctx) error {\n\t\td := make(map[string]string)\n\n\t\tif err := c.Bind().URI(&d); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\trequire.Equal(t, uint(111), d[\"userId\"])\n\t\trequire.Equal(t, uint(222), d[\"roleId\"])\n\t\treturn nil\n\t})\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test1/111/role/222\", nil))\n\trequire.NoError(t, err)\n\t_, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/111/role/222\", nil))\n\trequire.NoError(t, err)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_URI -benchmem -count=4\nfunc Benchmark_Bind_URI(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\n\tvar res struct {\n\t\tParam1 string `uri:\"param1\"`\n\t\tParam2 string `uri:\"param2\"`\n\t\tParam3 string `uri:\"param3\"`\n\t\tParam4 string `uri:\"param4\"`\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().URI(&res)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", res.Param1)\n\trequire.Equal(b, \"doe\", res.Param2)\n\trequire.Equal(b, \"is\", res.Param3)\n\trequire.Equal(b, \"awesome\", res.Param4)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Bind_URI_Map -benchmem -count=4\nfunc Benchmark_Bind_URI_Map(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\n\tres := make(map[string]string)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().URI(&res)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"john\", res[\"param1\"])\n\trequire.Equal(b, \"doe\", res[\"param2\"])\n\trequire.Equal(b, \"is\", res[\"param3\"])\n\trequire.Equal(b, \"awesome\", res[\"param4\"])\n}\n\n// go test -run Test_Bind_Cookie -v\nfunc Test_Bind_Cookie(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Cookie struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.SetCookie(\"id\", \"1\")\n\tc.Request().Header.SetCookie(\"Name\", \"John Doe\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"golang,fiber\")\n\tq := new(Cookie)\n\trequire.NoError(t, c.Bind().Cookie(q))\n\trequire.Len(t, q.Hobby, 2)\n\n\tc.Request().Header.DelCookie(\"hobby\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"golang,fiber,go\")\n\tq = new(Cookie)\n\trequire.NoError(t, c.Bind().Cookie(q))\n\trequire.Len(t, q.Hobby, 3)\n\n\tempty := new(Cookie)\n\tc.Request().Header.DelCookie(\"hobby\")\n\trequire.NoError(t, c.Bind().Query(empty))\n\trequire.Empty(t, empty.Hobby)\n\n\ttype Cookie2 struct {\n\t\tName            string\n\t\tHobby           string\n\t\tFavouriteDrinks []string\n\t\tEmpty           []string\n\t\tAlloc           []string\n\t\tNo              []int64\n\t\tID              int\n\t\tBool            bool\n\t}\n\n\tc.Request().Header.SetCookie(\"id\", \"2\")\n\tc.Request().Header.SetCookie(\"Name\", \"Jane Doe\")\n\tc.Request().Header.DelCookie(\"hobby\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"go,fiber\")\n\tc.Request().Header.SetCookie(\"favouriteDrinks\", \"milo,coke,pepsi\")\n\tc.Request().Header.SetCookie(\"alloc\", \"\")\n\tc.Request().Header.SetCookie(\"no\", \"1\")\n\n\th2 := new(Cookie2)\n\th2.Bool = true\n\th2.Name = helloWorld\n\trequire.NoError(t, c.Bind().Cookie(h2))\n\trequire.Equal(t, \"go,fiber\", h2.Hobby)\n\trequire.True(t, h2.Bool)\n\trequire.Equal(t, \"Jane Doe\", h2.Name) // check value get overwritten\n\trequire.Equal(t, []string{\"milo\", \"coke\", \"pepsi\"}, h2.FavouriteDrinks)\n\tvar nilSlice []string\n\trequire.Equal(t, nilSlice, h2.Empty)\n\trequire.Equal(t, []string{\"\"}, h2.Alloc)\n\trequire.Equal(t, []int64{1}, h2.No)\n\n\ttype RequiredCookie struct {\n\t\tName string `cookie:\"name,required\"`\n\t}\n\trh := new(RequiredCookie)\n\tc.Request().Header.DelCookie(\"name\")\n\trequire.Equal(t, \"bind: name is empty\", c.Bind().Cookie(rh).Error())\n}\n\n// go test -run Test_Bind_Cookie_Map -v\nfunc Test_Bind_Cookie_Map(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.SetCookie(\"id\", \"1\")\n\tc.Request().Header.SetCookie(\"Name\", \"John Doe\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"golang,fiber\")\n\tq := make(map[string][]string)\n\trequire.NoError(t, c.Bind().Cookie(&q))\n\trequire.Len(t, q[\"Hobby\"], 2)\n\n\tc.Request().Header.DelCookie(\"hobby\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"golang,fiber,go\")\n\tq = make(map[string][]string)\n\trequire.NoError(t, c.Bind().Cookie(&q))\n\trequire.Len(t, q[\"Hobby\"], 3)\n\n\tempty := make(map[string][]string)\n\tc.Request().Header.DelCookie(\"hobby\")\n\trequire.NoError(t, c.Bind().Query(&empty))\n\trequire.Empty(t, empty[\"Hobby\"])\n}\n\n// go test -run Test_Bind_Cookie_WithSetParserDecoder -v\nfunc Test_Bind_Cookie_WithSetParserDecoder(t *testing.T) {\n\ttype NonRFCTime time.Time\n\n\tnonRFCConverter := func(value string) reflect.Value {\n\t\tif v, err := time.Parse(\"2006-01-02\", value); err == nil {\n\t\t\treturn reflect.ValueOf(v)\n\t\t}\n\t\treturn reflect.Value{}\n\t}\n\n\tnonRFCTime := binder.ParserType{\n\t\tCustomType: NonRFCTime{},\n\t\tConverter:  nonRFCConverter,\n\t}\n\n\tbinder.SetParserDecoder(binder.ParserConfig{\n\t\tIgnoreUnknownKeys: true,\n\t\tParserType:        []binder.ParserType{nonRFCTime},\n\t\tZeroEmpty:         true,\n\t\tSetAliasTag:       \"cerez\",\n\t})\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype NonRFCTimeInput struct {\n\t\tDate  NonRFCTime `cerez:\"date\"`\n\t\tTitle string     `cerez:\"title\"`\n\t\tBody  string     `cerez:\"body\"`\n\t}\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tr := new(NonRFCTimeInput)\n\n\tc.Request().Header.SetCookie(\"Date\", \"2021-04-10\")\n\tc.Request().Header.SetCookie(\"Title\", \"CustomDateTest\")\n\tc.Request().Header.SetCookie(\"Body\", \"October\")\n\n\trequire.NoError(t, c.Bind().Cookie(r))\n\trequire.Equal(t, \"CustomDateTest\", r.Title)\n\tdate := fmt.Sprintf(\"%v\", r.Date)\n\trequire.Equal(t, \"{0 63753609600 <nil>}\", date)\n\trequire.Equal(t, \"October\", r.Body)\n\n\tc.Request().Header.SetCookie(\"Title\", \"\")\n\tr = &NonRFCTimeInput{\n\t\tTitle: \"Existing title\",\n\t\tBody:  \"Existing Body\",\n\t}\n\trequire.NoError(t, c.Bind().Cookie(r))\n\trequire.Equal(t, \"\", r.Title)\n}\n\n// go test -run Test_Bind_Cookie_Schema -v\nfunc Test_Bind_Cookie_Schema(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Cookie1 struct {\n\t\tName   string `cookie:\"Name,required\"`\n\t\tNested struct {\n\t\t\tAge int `cookie:\"Age\"`\n\t\t} `cookie:\"Nested,required\"`\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.SetCookie(\"Name\", \"tom\")\n\tc.Request().Header.SetCookie(\"Nested.Age\", \"10\")\n\tq := new(Cookie1)\n\trequire.NoError(t, c.Bind().Cookie(q))\n\n\tc.Request().Header.DelCookie(\"Name\")\n\tq = new(Cookie1)\n\trequire.Equal(t, \"bind: Name is empty\", c.Bind().Cookie(q).Error())\n\n\tc.Request().Header.SetCookie(\"Name\", \"tom\")\n\tc.Request().Header.DelCookie(\"Nested.Age\")\n\tc.Request().Header.SetCookie(\"Nested.Agex\", \"10\")\n\tq = new(Cookie1)\n\trequire.NoError(t, c.Bind().Cookie(q))\n\n\tc.Request().Header.DelCookie(\"Nested.Agex\")\n\tq = new(Cookie1)\n\trequire.Equal(t, \"bind: Nested is empty\", c.Bind().Cookie(q).Error())\n\n\tc.Request().Header.DelCookie(\"Nested.Agex\")\n\tc.Request().Header.DelCookie(\"Name\")\n\n\ttype Cookie2 struct {\n\t\tName   string `cookie:\"Name\"`\n\t\tNested struct {\n\t\t\tAge int `cookie:\"Age,required\"`\n\t\t} `cookie:\"Nested\"`\n\t}\n\n\tc.Request().Header.SetCookie(\"Name\", \"tom\")\n\tc.Request().Header.SetCookie(\"Nested.Age\", \"10\")\n\n\th2 := new(Cookie2)\n\trequire.NoError(t, c.Bind().Cookie(h2))\n\n\tc.Request().Header.DelCookie(\"Name\")\n\th2 = new(Cookie2)\n\trequire.NoError(t, c.Bind().Cookie(h2))\n\n\tc.Request().Header.DelCookie(\"Name\")\n\tc.Request().Header.DelCookie(\"Nested.Age\")\n\tc.Request().Header.SetCookie(\"Nested.Agex\", \"10\")\n\th2 = new(Cookie2)\n\trequire.Equal(t, \"bind: Nested.Age is empty\", c.Bind().Cookie(h2).Error())\n\n\ttype Node struct {\n\t\tNext  *Node `cookie:\"Next,required\"`\n\t\tValue int   `cookie:\"Val,required\"`\n\t}\n\tc.Request().Header.SetCookie(\"Val\", \"1\")\n\tc.Request().Header.SetCookie(\"Next.Val\", \"3\")\n\tn := new(Node)\n\trequire.NoError(t, c.Bind().Cookie(n))\n\trequire.Equal(t, 1, n.Value)\n\trequire.Equal(t, 3, n.Next.Value)\n\n\tc.Request().Header.DelCookie(\"Val\")\n\tn = new(Node)\n\trequire.Equal(t, \"bind: Val is empty\", c.Bind().Cookie(n).Error())\n\n\tc.Request().Header.SetCookie(\"Val\", \"3\")\n\tc.Request().Header.DelCookie(\"Next.Val\")\n\tc.Request().Header.SetCookie(\"Next.Value\", \"2\")\n\tn = new(Node)\n\tn.Next = new(Node)\n\trequire.NoError(t, c.Bind().Cookie(n))\n\trequire.Equal(t, 3, n.Value)\n\trequire.Equal(t, 0, n.Next.Value)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Cookie -benchmem -count=4\nfunc Benchmark_Bind_Cookie(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Cookie struct {\n\t\tName  string\n\t\tHobby []string\n\t\tID    int\n\t}\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.SetCookie(\"id\", \"1\")\n\tc.Request().Header.SetCookie(\"Name\", \"John Doe\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"golang,fiber\")\n\n\tq := new(Cookie)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Cookie(q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Bind_Cookie_Map -benchmem -count=4\nfunc Benchmark_Bind_Cookie_Map(b *testing.B) {\n\tvar err error\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\n\tc.Request().Header.SetCookie(\"id\", \"1\")\n\tc.Request().Header.SetCookie(\"Name\", \"John Doe\")\n\tc.Request().Header.SetCookie(\"Hobby\", \"golang,fiber\")\n\n\tq := make(map[string][]string)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Bind().Cookie(&q)\n\t}\n\trequire.NoError(b, err)\n}\n\n// custom binder for testing\ntype customBinder struct{}\n\nfunc (*customBinder) Name() string {\n\treturn \"custom\"\n}\n\nfunc (*customBinder) MIMETypes() []string {\n\treturn []string{\"test\", \"test2\"}\n}\n\nfunc (*customBinder) Parse(c Ctx, out any) error {\n\treturn json.Unmarshal(c.Body(), out)\n}\n\n// go test -run Test_Bind_CustomBinder\nfunc Test_Bind_CustomBinder(t *testing.T) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// Register binder\n\tcustomBinder := &customBinder{}\n\tapp.RegisterCustomBinder(customBinder)\n\n\ttype Demo struct {\n\t\tName string `json:\"name\"`\n\t}\n\tbody := []byte(`{\"name\":\"john\"}`)\n\tc.Request().SetBody(body)\n\tc.Request().Header.SetContentType(\"test\")\n\tc.Request().Header.SetContentLength(len(body))\n\td := new(Demo)\n\n\trequire.NoError(t, c.Bind().Body(d))\n\trequire.NoError(t, c.Bind().Custom(\"custom\", d))\n\trequire.Equal(t, ErrCustomBinderNotFound, c.Bind().Custom(\"not_custom\", d))\n\trequire.Equal(t, \"john\", d.Name)\n}\n\n// go test -run Test_Bind_WithAutoHandling\nfunc Test_Bind_WithAutoHandling(t *testing.T) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype RequiredQuery struct {\n\t\tName string `query:\"name,required\"`\n\t}\n\trq := new(RequiredQuery)\n\tc.Request().URI().SetQueryString(\"\")\n\terr := c.Bind().WithAutoHandling().Query(rq)\n\trequire.Equal(t, StatusBadRequest, c.Response().StatusCode())\n\trequire.Equal(t, \"Bad request: bind: name is empty\", err.Error())\n}\n\n// simple struct validator for testing\ntype structValidator struct{}\n\nfunc (*structValidator) Validate(out any) error {\n\tout = reflect.ValueOf(out).Elem().Interface()\n\tsq, ok := out.(simpleQuery)\n\tif !ok {\n\t\treturn errors.New(\"failed to type-assert to simpleQuery\")\n\t}\n\n\tif sq.Name != \"john\" {\n\t\treturn errors.New(\"you should have entered right name\")\n\t}\n\n\treturn nil\n}\n\ntype simpleQuery struct {\n\tName string `query:\"name\"`\n}\n\n// go test -run Test_Bind_StructValidator\nfunc Test_Bind_StructValidator(t *testing.T) {\n\tapp := New(Config{StructValidator: &structValidator{}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trq := new(simpleQuery)\n\tc.Request().URI().SetQueryString(\"name=efe\")\n\trequire.Equal(t, \"you should have entered right name\", c.Bind().Query(rq).Error())\n\n\trq = new(simpleQuery)\n\tc.Request().URI().SetQueryString(\"name=john\")\n\trequire.NoError(t, c.Bind().Query(rq))\n}\n\n// go test -run Test_Bind_RepeatParserWithSameStruct -v\nfunc Test_Bind_RepeatParserWithSameStruct(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttype Request struct {\n\t\tQueryParam  string `query:\"query_param\"`\n\t\tHeaderParam string `header:\"header_param\"`\n\t\tBodyParam   string `json:\"body_param\" xml:\"body_param\" form:\"body_param\"`\n\t}\n\n\tr := new(Request)\n\n\tc.Request().URI().SetQueryString(\"query_param=query_param\")\n\trequire.NoError(t, c.Bind().Query(r))\n\trequire.Equal(t, \"query_param\", r.QueryParam)\n\n\tc.Request().Header.Add(\"header_param\", \"header_param\")\n\trequire.NoError(t, c.Bind().Header(r))\n\trequire.Equal(t, \"header_param\", r.HeaderParam)\n\n\tvar gzipJSON bytes.Buffer\n\tw := gzip.NewWriter(&gzipJSON)\n\t_, err := w.Write([]byte(`{\"body_param\":\"body_param\"}`))\n\trequire.NoError(t, err)\n\terr = w.Close()\n\trequire.NoError(t, err)\n\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\tc.Request().Header.Set(HeaderContentEncoding, \"gzip\")\n\tc.Request().SetBody(gzipJSON.Bytes())\n\tc.Request().Header.SetContentLength(len(gzipJSON.Bytes()))\n\trequire.NoError(t, c.Bind().Body(r))\n\trequire.Equal(t, \"body_param\", r.BodyParam)\n\tc.Request().Header.Del(HeaderContentEncoding)\n\n\ttestDecodeParser := func(contentType, body string) {\n\t\tc.Request().Header.SetContentType(contentType)\n\t\tc.Request().SetBody([]byte(body))\n\t\tc.Request().Header.SetContentLength(len(body))\n\t\trequire.NoError(t, c.Bind().Body(r))\n\t\trequire.Equal(t, \"body_param\", r.BodyParam)\n\t}\n\n\tcb, err := cbor.Marshal(&Request{BodyParam: \"body_param\"})\n\trequire.NoError(t, err, \"Failed to marshal CBOR data\")\n\n\ttestDecodeParser(MIMEApplicationJSON, `{\"body_param\":\"body_param\"}`)\n\ttestDecodeParser(MIMEApplicationXML, `<Demo><body_param>body_param</body_param></Demo>`)\n\ttestDecodeParser(MIMEApplicationCBOR, string(cb))\n\ttestDecodeParser(MIMEApplicationForm, \"body_param=body_param\")\n\ttestDecodeParser(MIMEMultipartForm+`;boundary=\"b\"`, \"--b\\r\\nContent-Disposition: form-data; name=\\\"body_param\\\"\\r\\n\\r\\nbody_param\\r\\n--b--\")\n}\n"
        },
        {
          "name": "binder",
          "type": "tree",
          "content": null
        },
        {
          "name": "client",
          "type": "tree",
          "content": null
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 1.91,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\n// Colors is a struct to define custom colors for Fiber app and middlewares.\ntype Colors struct {\n\t// Black color.\n\t//\n\t// Optional. Default: \"\\u001b[90m\"\n\tBlack string\n\n\t// Red color.\n\t//\n\t// Optional. Default: \"\\u001b[91m\"\n\tRed string\n\n\t// Green color.\n\t//\n\t// Optional. Default: \"\\u001b[92m\"\n\tGreen string\n\n\t// Yellow color.\n\t//\n\t// Optional. Default: \"\\u001b[93m\"\n\tYellow string\n\n\t// Blue color.\n\t//\n\t// Optional. Default: \"\\u001b[94m\"\n\tBlue string\n\n\t// Magenta color.\n\t//\n\t// Optional. Default: \"\\u001b[95m\"\n\tMagenta string\n\n\t// Cyan color.\n\t//\n\t// Optional. Default: \"\\u001b[96m\"\n\tCyan string\n\n\t// White color.\n\t//\n\t// Optional. Default: \"\\u001b[97m\"\n\tWhite string\n\n\t// Reset color.\n\t//\n\t// Optional. Default: \"\\u001b[0m\"\n\tReset string\n}\n\n// DefaultColors Default color codes\nvar DefaultColors = Colors{\n\tBlack:   \"\\u001b[90m\",\n\tRed:     \"\\u001b[91m\",\n\tGreen:   \"\\u001b[92m\",\n\tYellow:  \"\\u001b[93m\",\n\tBlue:    \"\\u001b[94m\",\n\tMagenta: \"\\u001b[95m\",\n\tCyan:    \"\\u001b[96m\",\n\tWhite:   \"\\u001b[97m\",\n\tReset:   \"\\u001b[0m\",\n}\n\n// defaultColors is a function to override default colors to config\nfunc defaultColors(colors Colors) Colors {\n\tif colors.Black == \"\" {\n\t\tcolors.Black = DefaultColors.Black\n\t}\n\n\tif colors.Red == \"\" {\n\t\tcolors.Red = DefaultColors.Red\n\t}\n\n\tif colors.Green == \"\" {\n\t\tcolors.Green = DefaultColors.Green\n\t}\n\n\tif colors.Yellow == \"\" {\n\t\tcolors.Yellow = DefaultColors.Yellow\n\t}\n\n\tif colors.Blue == \"\" {\n\t\tcolors.Blue = DefaultColors.Blue\n\t}\n\n\tif colors.Magenta == \"\" {\n\t\tcolors.Magenta = DefaultColors.Magenta\n\t}\n\n\tif colors.Cyan == \"\" {\n\t\tcolors.Cyan = DefaultColors.Cyan\n\t}\n\n\tif colors.White == \"\" {\n\t\tcolors.White = DefaultColors.White\n\t}\n\n\tif colors.Reset == \"\" {\n\t\tcolors.Reset = DefaultColors.Reset\n\t}\n\n\treturn colors\n}\n"
        },
        {
          "name": "constants.go",
          "type": "blob",
          "size": 17.67,
          "content": "package fiber\n\n// HTTP methods were copied from net/http.\nconst (\n\tMethodGet     = \"GET\"     // RFC 7231, 4.3.1\n\tMethodHead    = \"HEAD\"    // RFC 7231, 4.3.2\n\tMethodPost    = \"POST\"    // RFC 7231, 4.3.3\n\tMethodPut     = \"PUT\"     // RFC 7231, 4.3.4\n\tMethodPatch   = \"PATCH\"   // RFC 5789\n\tMethodDelete  = \"DELETE\"  // RFC 7231, 4.3.5\n\tMethodConnect = \"CONNECT\" // RFC 7231, 4.3.6\n\tMethodOptions = \"OPTIONS\" // RFC 7231, 4.3.7\n\tMethodTrace   = \"TRACE\"   // RFC 7231, 4.3.8\n\tmethodUse     = \"USE\"\n)\n\n// MIME types that are commonly used\nconst (\n\tMIMETextXML         = \"text/xml\"\n\tMIMETextHTML        = \"text/html\"\n\tMIMETextPlain       = \"text/plain\"\n\tMIMETextJavaScript  = \"text/javascript\"\n\tMIMETextCSS         = \"text/css\"\n\tMIMEApplicationXML  = \"application/xml\"\n\tMIMEApplicationJSON = \"application/json\"\n\tMIMEApplicationCBOR = \"application/cbor\"\n\t// Deprecated: use MIMETextJavaScript instead\n\tMIMEApplicationJavaScript = \"application/javascript\"\n\tMIMEApplicationForm       = \"application/x-www-form-urlencoded\"\n\tMIMEOctetStream           = \"application/octet-stream\"\n\tMIMEMultipartForm         = \"multipart/form-data\"\n\n\tMIMETextXMLCharsetUTF8         = \"text/xml; charset=utf-8\"\n\tMIMETextHTMLCharsetUTF8        = \"text/html; charset=utf-8\"\n\tMIMETextPlainCharsetUTF8       = \"text/plain; charset=utf-8\"\n\tMIMETextJavaScriptCharsetUTF8  = \"text/javascript; charset=utf-8\"\n\tMIMETextCSSCharsetUTF8         = \"text/css; charset=utf-8\"\n\tMIMEApplicationXMLCharsetUTF8  = \"application/xml; charset=utf-8\"\n\tMIMEApplicationJSONCharsetUTF8 = \"application/json; charset=utf-8\"\n\t// Deprecated: use MIMETextJavaScriptCharsetUTF8 instead\n\tMIMEApplicationJavaScriptCharsetUTF8 = \"application/javascript; charset=utf-8\"\n)\n\n// HTTP status codes were copied from net/http with the following updates:\n// - Rename StatusNonAuthoritativeInfo to StatusNonAuthoritativeInformation\n// - Add StatusSwitchProxy (306)\n// NOTE: Keep this list in sync with statusMessage\nconst (\n\tStatusContinue           = 100 // RFC 9110, 15.2.1\n\tStatusSwitchingProtocols = 101 // RFC 9110, 15.2.2\n\tStatusProcessing         = 102 // RFC 2518, 10.1\n\tStatusEarlyHints         = 103 // RFC 8297\n\n\tStatusOK                          = 200 // RFC 9110, 15.3.1\n\tStatusCreated                     = 201 // RFC 9110, 15.3.2\n\tStatusAccepted                    = 202 // RFC 9110, 15.3.3\n\tStatusNonAuthoritativeInformation = 203 // RFC 9110, 15.3.4\n\tStatusNoContent                   = 204 // RFC 9110, 15.3.5\n\tStatusResetContent                = 205 // RFC 9110, 15.3.6\n\tStatusPartialContent              = 206 // RFC 9110, 15.3.7\n\tStatusMultiStatus                 = 207 // RFC 4918, 11.1\n\tStatusAlreadyReported             = 208 // RFC 5842, 7.1\n\tStatusIMUsed                      = 226 // RFC 3229, 10.4.1\n\n\tStatusMultipleChoices   = 300 // RFC 9110, 15.4.1\n\tStatusMovedPermanently  = 301 // RFC 9110, 15.4.2\n\tStatusFound             = 302 // RFC 9110, 15.4.3\n\tStatusSeeOther          = 303 // RFC 9110, 15.4.4\n\tStatusNotModified       = 304 // RFC 9110, 15.4.5\n\tStatusUseProxy          = 305 // RFC 9110, 15.4.6\n\tStatusSwitchProxy       = 306 // RFC 9110, 15.4.7 (Unused)\n\tStatusTemporaryRedirect = 307 // RFC 9110, 15.4.8\n\tStatusPermanentRedirect = 308 // RFC 9110, 15.4.9\n\n\tStatusBadRequest                   = 400 // RFC 9110, 15.5.1\n\tStatusUnauthorized                 = 401 // RFC 9110, 15.5.2\n\tStatusPaymentRequired              = 402 // RFC 9110, 15.5.3\n\tStatusForbidden                    = 403 // RFC 9110, 15.5.4\n\tStatusNotFound                     = 404 // RFC 9110, 15.5.5\n\tStatusMethodNotAllowed             = 405 // RFC 9110, 15.5.6\n\tStatusNotAcceptable                = 406 // RFC 9110, 15.5.7\n\tStatusProxyAuthRequired            = 407 // RFC 9110, 15.5.8\n\tStatusRequestTimeout               = 408 // RFC 9110, 15.5.9\n\tStatusConflict                     = 409 // RFC 9110, 15.5.10\n\tStatusGone                         = 410 // RFC 9110, 15.5.11\n\tStatusLengthRequired               = 411 // RFC 9110, 15.5.12\n\tStatusPreconditionFailed           = 412 // RFC 9110, 15.5.13\n\tStatusRequestEntityTooLarge        = 413 // RFC 9110, 15.5.14\n\tStatusRequestURITooLong            = 414 // RFC 9110, 15.5.15\n\tStatusUnsupportedMediaType         = 415 // RFC 9110, 15.5.16\n\tStatusRequestedRangeNotSatisfiable = 416 // RFC 9110, 15.5.17\n\tStatusExpectationFailed            = 417 // RFC 9110, 15.5.18\n\tStatusTeapot                       = 418 // RFC 9110, 15.5.19 (Unused)\n\tStatusMisdirectedRequest           = 421 // RFC 9110, 15.5.20\n\tStatusUnprocessableEntity          = 422 // RFC 9110, 15.5.21\n\tStatusLocked                       = 423 // RFC 4918, 11.3\n\tStatusFailedDependency             = 424 // RFC 4918, 11.4\n\tStatusTooEarly                     = 425 // RFC 8470, 5.2.\n\tStatusUpgradeRequired              = 426 // RFC 9110, 15.5.22\n\tStatusPreconditionRequired         = 428 // RFC 6585, 3\n\tStatusTooManyRequests              = 429 // RFC 6585, 4\n\tStatusRequestHeaderFieldsTooLarge  = 431 // RFC 6585, 5\n\tStatusUnavailableForLegalReasons   = 451 // RFC 7725, 3\n\n\tStatusInternalServerError           = 500 // RFC 9110, 15.6.1\n\tStatusNotImplemented                = 501 // RFC 9110, 15.6.2\n\tStatusBadGateway                    = 502 // RFC 9110, 15.6.3\n\tStatusServiceUnavailable            = 503 // RFC 9110, 15.6.4\n\tStatusGatewayTimeout                = 504 // RFC 9110, 15.6.5\n\tStatusHTTPVersionNotSupported       = 505 // RFC 9110, 15.6.6\n\tStatusVariantAlsoNegotiates         = 506 // RFC 2295, 8.1\n\tStatusInsufficientStorage           = 507 // RFC 4918, 11.5\n\tStatusLoopDetected                  = 508 // RFC 5842, 7.2\n\tStatusNotExtended                   = 510 // RFC 2774, 7\n\tStatusNetworkAuthenticationRequired = 511 // RFC 6585, 6\n)\n\n// Errors\nvar (\n\tErrBadRequest                   = NewError(StatusBadRequest)                   // 400\n\tErrUnauthorized                 = NewError(StatusUnauthorized)                 // 401\n\tErrPaymentRequired              = NewError(StatusPaymentRequired)              // 402\n\tErrForbidden                    = NewError(StatusForbidden)                    // 403\n\tErrNotFound                     = NewError(StatusNotFound)                     // 404\n\tErrMethodNotAllowed             = NewError(StatusMethodNotAllowed)             // 405\n\tErrNotAcceptable                = NewError(StatusNotAcceptable)                // 406\n\tErrProxyAuthRequired            = NewError(StatusProxyAuthRequired)            // 407\n\tErrRequestTimeout               = NewError(StatusRequestTimeout)               // 408\n\tErrConflict                     = NewError(StatusConflict)                     // 409\n\tErrGone                         = NewError(StatusGone)                         // 410\n\tErrLengthRequired               = NewError(StatusLengthRequired)               // 411\n\tErrPreconditionFailed           = NewError(StatusPreconditionFailed)           // 412\n\tErrRequestEntityTooLarge        = NewError(StatusRequestEntityTooLarge)        // 413\n\tErrRequestURITooLong            = NewError(StatusRequestURITooLong)            // 414\n\tErrUnsupportedMediaType         = NewError(StatusUnsupportedMediaType)         // 415\n\tErrRequestedRangeNotSatisfiable = NewError(StatusRequestedRangeNotSatisfiable) // 416\n\tErrExpectationFailed            = NewError(StatusExpectationFailed)            // 417\n\tErrTeapot                       = NewError(StatusTeapot)                       // 418\n\tErrMisdirectedRequest           = NewError(StatusMisdirectedRequest)           // 421\n\tErrUnprocessableEntity          = NewError(StatusUnprocessableEntity)          // 422\n\tErrLocked                       = NewError(StatusLocked)                       // 423\n\tErrFailedDependency             = NewError(StatusFailedDependency)             // 424\n\tErrTooEarly                     = NewError(StatusTooEarly)                     // 425\n\tErrUpgradeRequired              = NewError(StatusUpgradeRequired)              // 426\n\tErrPreconditionRequired         = NewError(StatusPreconditionRequired)         // 428\n\tErrTooManyRequests              = NewError(StatusTooManyRequests)              // 429\n\tErrRequestHeaderFieldsTooLarge  = NewError(StatusRequestHeaderFieldsTooLarge)  // 431\n\tErrUnavailableForLegalReasons   = NewError(StatusUnavailableForLegalReasons)   // 451\n\n\tErrInternalServerError           = NewError(StatusInternalServerError)           // 500\n\tErrNotImplemented                = NewError(StatusNotImplemented)                // 501\n\tErrBadGateway                    = NewError(StatusBadGateway)                    // 502\n\tErrServiceUnavailable            = NewError(StatusServiceUnavailable)            // 503\n\tErrGatewayTimeout                = NewError(StatusGatewayTimeout)                // 504\n\tErrHTTPVersionNotSupported       = NewError(StatusHTTPVersionNotSupported)       // 505\n\tErrVariantAlsoNegotiates         = NewError(StatusVariantAlsoNegotiates)         // 506\n\tErrInsufficientStorage           = NewError(StatusInsufficientStorage)           // 507\n\tErrLoopDetected                  = NewError(StatusLoopDetected)                  // 508\n\tErrNotExtended                   = NewError(StatusNotExtended)                   // 510\n\tErrNetworkAuthenticationRequired = NewError(StatusNetworkAuthenticationRequired) // 511\n)\n\n// HTTP Headers were copied from net/http.\nconst (\n\tHeaderAuthorization                      = \"Authorization\"\n\tHeaderProxyAuthenticate                  = \"Proxy-Authenticate\"\n\tHeaderProxyAuthorization                 = \"Proxy-Authorization\"\n\tHeaderWWWAuthenticate                    = \"WWW-Authenticate\"\n\tHeaderAge                                = \"Age\"\n\tHeaderCacheControl                       = \"Cache-Control\"\n\tHeaderClearSiteData                      = \"Clear-Site-Data\"\n\tHeaderExpires                            = \"Expires\"\n\tHeaderPragma                             = \"Pragma\"\n\tHeaderWarning                            = \"Warning\"\n\tHeaderAcceptCH                           = \"Accept-CH\"\n\tHeaderAcceptCHLifetime                   = \"Accept-CH-Lifetime\"\n\tHeaderContentDPR                         = \"Content-DPR\"\n\tHeaderDPR                                = \"DPR\"\n\tHeaderEarlyData                          = \"Early-Data\"\n\tHeaderSaveData                           = \"Save-Data\"\n\tHeaderViewportWidth                      = \"Viewport-Width\"\n\tHeaderWidth                              = \"Width\"\n\tHeaderETag                               = \"ETag\"\n\tHeaderIfMatch                            = \"If-Match\"\n\tHeaderIfModifiedSince                    = \"If-Modified-Since\"\n\tHeaderIfNoneMatch                        = \"If-None-Match\"\n\tHeaderIfUnmodifiedSince                  = \"If-Unmodified-Since\"\n\tHeaderLastModified                       = \"Last-Modified\"\n\tHeaderVary                               = \"Vary\"\n\tHeaderConnection                         = \"Connection\"\n\tHeaderKeepAlive                          = \"Keep-Alive\"\n\tHeaderAccept                             = \"Accept\"\n\tHeaderAcceptCharset                      = \"Accept-Charset\"\n\tHeaderAcceptEncoding                     = \"Accept-Encoding\"\n\tHeaderAcceptLanguage                     = \"Accept-Language\"\n\tHeaderCookie                             = \"Cookie\"\n\tHeaderExpect                             = \"Expect\"\n\tHeaderMaxForwards                        = \"Max-Forwards\"\n\tHeaderSetCookie                          = \"Set-Cookie\"\n\tHeaderAccessControlAllowCredentials      = \"Access-Control-Allow-Credentials\"\n\tHeaderAccessControlAllowHeaders          = \"Access-Control-Allow-Headers\"\n\tHeaderAccessControlAllowMethods          = \"Access-Control-Allow-Methods\"\n\tHeaderAccessControlAllowOrigin           = \"Access-Control-Allow-Origin\"\n\tHeaderAccessControlExposeHeaders         = \"Access-Control-Expose-Headers\"\n\tHeaderAccessControlMaxAge                = \"Access-Control-Max-Age\"\n\tHeaderAccessControlRequestHeaders        = \"Access-Control-Request-Headers\"\n\tHeaderAccessControlRequestMethod         = \"Access-Control-Request-Method\"\n\tHeaderOrigin                             = \"Origin\"\n\tHeaderTimingAllowOrigin                  = \"Timing-Allow-Origin\"\n\tHeaderXPermittedCrossDomainPolicies      = \"X-Permitted-Cross-Domain-Policies\"\n\tHeaderDNT                                = \"DNT\"\n\tHeaderTk                                 = \"Tk\"\n\tHeaderContentDisposition                 = \"Content-Disposition\"\n\tHeaderContentEncoding                    = \"Content-Encoding\"\n\tHeaderContentLanguage                    = \"Content-Language\"\n\tHeaderContentLength                      = \"Content-Length\"\n\tHeaderContentLocation                    = \"Content-Location\"\n\tHeaderContentType                        = \"Content-Type\"\n\tHeaderForwarded                          = \"Forwarded\"\n\tHeaderVia                                = \"Via\"\n\tHeaderXForwardedFor                      = \"X-Forwarded-For\"\n\tHeaderXForwardedHost                     = \"X-Forwarded-Host\"\n\tHeaderXForwardedProto                    = \"X-Forwarded-Proto\"\n\tHeaderXForwardedProtocol                 = \"X-Forwarded-Protocol\"\n\tHeaderXForwardedSsl                      = \"X-Forwarded-Ssl\"\n\tHeaderXUrlScheme                         = \"X-Url-Scheme\"\n\tHeaderLocation                           = \"Location\"\n\tHeaderFrom                               = \"From\"\n\tHeaderHost                               = \"Host\"\n\tHeaderReferer                            = \"Referer\"\n\tHeaderReferrerPolicy                     = \"Referrer-Policy\"\n\tHeaderUserAgent                          = \"User-Agent\"\n\tHeaderAllow                              = \"Allow\"\n\tHeaderServer                             = \"Server\"\n\tHeaderAcceptRanges                       = \"Accept-Ranges\"\n\tHeaderContentRange                       = \"Content-Range\"\n\tHeaderIfRange                            = \"If-Range\"\n\tHeaderRange                              = \"Range\"\n\tHeaderContentSecurityPolicy              = \"Content-Security-Policy\"\n\tHeaderContentSecurityPolicyReportOnly    = \"Content-Security-Policy-Report-Only\"\n\tHeaderCrossOriginResourcePolicy          = \"Cross-Origin-Resource-Policy\"\n\tHeaderExpectCT                           = \"Expect-CT\"\n\tHeaderPermissionsPolicy                  = \"Permissions-Policy\"\n\tHeaderPublicKeyPins                      = \"Public-Key-Pins\"\n\tHeaderPublicKeyPinsReportOnly            = \"Public-Key-Pins-Report-Only\"\n\tHeaderStrictTransportSecurity            = \"Strict-Transport-Security\"\n\tHeaderUpgradeInsecureRequests            = \"Upgrade-Insecure-Requests\"\n\tHeaderXContentTypeOptions                = \"X-Content-Type-Options\"\n\tHeaderXDownloadOptions                   = \"X-Download-Options\"\n\tHeaderXFrameOptions                      = \"X-Frame-Options\"\n\tHeaderXPoweredBy                         = \"X-Powered-By\"\n\tHeaderXXSSProtection                     = \"X-XSS-Protection\"\n\tHeaderLastEventID                        = \"Last-Event-ID\"\n\tHeaderNEL                                = \"NEL\"\n\tHeaderPingFrom                           = \"Ping-From\"\n\tHeaderPingTo                             = \"Ping-To\"\n\tHeaderReportTo                           = \"Report-To\"\n\tHeaderTE                                 = \"TE\"\n\tHeaderTrailer                            = \"Trailer\"\n\tHeaderTransferEncoding                   = \"Transfer-Encoding\"\n\tHeaderSecWebSocketAccept                 = \"Sec-WebSocket-Accept\"\n\tHeaderSecWebSocketExtensions             = \"Sec-WebSocket-Extensions\"\n\tHeaderSecWebSocketKey                    = \"Sec-WebSocket-Key\"\n\tHeaderSecWebSocketProtocol               = \"Sec-WebSocket-Protocol\"\n\tHeaderSecWebSocketVersion                = \"Sec-WebSocket-Version\"\n\tHeaderAcceptPatch                        = \"Accept-Patch\"\n\tHeaderAcceptPushPolicy                   = \"Accept-Push-Policy\"\n\tHeaderAcceptSignature                    = \"Accept-Signature\"\n\tHeaderAltSvc                             = \"Alt-Svc\"\n\tHeaderDate                               = \"Date\"\n\tHeaderIndex                              = \"Index\"\n\tHeaderLargeAllocation                    = \"Large-Allocation\"\n\tHeaderLink                               = \"Link\"\n\tHeaderPushPolicy                         = \"Push-Policy\"\n\tHeaderRetryAfter                         = \"Retry-After\"\n\tHeaderServerTiming                       = \"Server-Timing\"\n\tHeaderSignature                          = \"Signature\"\n\tHeaderSignedHeaders                      = \"Signed-Headers\"\n\tHeaderSourceMap                          = \"SourceMap\"\n\tHeaderUpgrade                            = \"Upgrade\"\n\tHeaderXDNSPrefetchControl                = \"X-DNS-Prefetch-Control\"\n\tHeaderXPingback                          = \"X-Pingback\"\n\tHeaderXRequestID                         = \"X-Request-ID\"\n\tHeaderXRequestedWith                     = \"X-Requested-With\"\n\tHeaderXRobotsTag                         = \"X-Robots-Tag\"\n\tHeaderXUACompatible                      = \"X-UA-Compatible\"\n\tHeaderAccessControlAllowPrivateNetwork   = \"Access-Control-Allow-Private-Network\"\n\tHeaderAccessControlRequestPrivateNetwork = \"Access-Control-Request-Private-Network\"\n)\n\n// Network types that are commonly used\nconst (\n\tNetworkTCP  = \"tcp\"\n\tNetworkTCP4 = \"tcp4\"\n\tNetworkTCP6 = \"tcp6\"\n)\n\n// Compression types\nconst (\n\tStrGzip    = \"gzip\"\n\tStrBr      = \"br\"\n\tStrDeflate = \"deflate\"\n\tStrBrotli  = \"brotli\"\n\tStrZstd    = \"zstd\"\n)\n\n// Cookie SameSite\n// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7\nconst (\n\tCookieSameSiteDisabled   = \"disabled\" // not in RFC, just control \"SameSite\" attribute will not be set.\n\tCookieSameSiteLaxMode    = \"lax\"\n\tCookieSameSiteStrictMode = \"strict\"\n\tCookieSameSiteNoneMode   = \"none\"\n)\n\n// Route Constraints\nconst (\n\tConstraintInt             = \"int\"\n\tConstraintBool            = \"bool\"\n\tConstraintFloat           = \"float\"\n\tConstraintAlpha           = \"alpha\"\n\tConstraintGUID            = \"guid\"\n\tConstraintMinLen          = \"minLen\"\n\tConstraintMaxLen          = \"maxLen\"\n\tConstraintLen             = \"len\"\n\tConstraintBetweenLen      = \"betweenLen\"\n\tConstraintMinLenLower     = \"minlen\"\n\tConstraintMaxLenLower     = \"maxlen\"\n\tConstraintBetweenLenLower = \"betweenlen\"\n\tConstraintMin             = \"min\"\n\tConstraintMax             = \"max\"\n\tConstraintRange           = \"range\"\n\tConstraintDatetime        = \"datetime\"\n\tConstraintRegex           = \"regex\"\n)\n"
        },
        {
          "name": "ctx.go",
          "type": "blob",
          "size": 62.05,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nconst (\n\tschemeHTTP  = \"http\"\n\tschemeHTTPS = \"https\"\n)\n\n// maxParams defines the maximum number of parameters per route.\nconst maxParams = 30\n\n// The contextKey type is unexported to prevent collisions with context keys defined in\n// other packages.\ntype contextKey int\n\n// userContextKey define the key name for storing context.Context in *fasthttp.RequestCtx\nconst userContextKey contextKey = 0 // __local_user_context__\n\n// DefaultCtx is the default implementation of the Ctx interface\n// generation tool `go install github.com/vburenin/ifacemaker@975a95966976eeb2d4365a7fb236e274c54da64c`\n// https://github.com/vburenin/ifacemaker/blob/975a95966976eeb2d4365a7fb236e274c54da64c/ifacemaker.go#L14-L30\n//\n//go:generate ifacemaker --file ctx.go --struct DefaultCtx --iface Ctx --pkg fiber --output ctx_interface_gen.go --not-exported true --iface-comment \"Ctx represents the Context which hold the HTTP request and response.\\nIt has methods for the request query string, parameters, body, HTTP headers and so on.\"\ntype DefaultCtx struct {\n\tapp                 *App                 // Reference to *App\n\troute               *Route               // Reference to *Route\n\tfasthttp            *fasthttp.RequestCtx // Reference to *fasthttp.RequestCtx\n\tbind                *Bind                // Default bind reference\n\tredirect            *Redirect            // Default redirect reference\n\tvalues              [maxParams]string    // Route parameter values\n\tviewBindMap         sync.Map             // Default view map to bind template engine\n\tmethod              string               // HTTP method\n\tbaseURI             string               // HTTP base uri\n\tpath                string               // HTTP path with the modifications by the configuration -> string copy from pathBuffer\n\tdetectionPath       string               // Route detection path                                  -> string copy from detectionPathBuffer\n\ttreePath            string               // Path for the search in the tree\n\tpathOriginal        string               // Original HTTP path\n\tpathBuffer          []byte               // HTTP path buffer\n\tdetectionPathBuffer []byte               // HTTP detectionPath buffer\n\tflashMessages       redirectionMsgs      // Flash messages\n\tindexRoute          int                  // Index of the current route\n\tindexHandler        int                  // Index of the current handler\n\tmethodINT           int                  // HTTP method INT equivalent\n\tmatched             bool                 // Non use route matched\n}\n\n// SendFile defines configuration options when to transfer file with SendFile.\ntype SendFile struct {\n\t// FS is the file system to serve the static files from.\n\t// You can use interfaces compatible with fs.FS like embed.FS, os.DirFS etc.\n\t//\n\t// Optional. Default: nil\n\tFS fs.FS\n\n\t// When set to true, the server tries minimizing CPU usage by caching compressed files.\n\t// This works differently than the github.com/gofiber/compression middleware.\n\t// You have to set Content-Encoding header to compress the file.\n\t// Available compression methods are gzip, br, and zstd.\n\t//\n\t// Optional. Default: false\n\tCompress bool `json:\"compress\"`\n\n\t// When set to true, enables byte range requests.\n\t//\n\t// Optional. Default: false\n\tByteRange bool `json:\"byte_range\"`\n\n\t// When set to true, enables direct download.\n\t//\n\t// Optional. Default: false\n\tDownload bool `json:\"download\"`\n\n\t// Expiration duration for inactive file handlers.\n\t// Use a negative time.Duration to disable it.\n\t//\n\t// Optional. Default: 10 * time.Second\n\tCacheDuration time.Duration `json:\"cache_duration\"`\n\n\t// The value for the Cache-Control HTTP-header\n\t// that is set on the file response. MaxAge is defined in seconds.\n\t//\n\t// Optional. Default: 0\n\tMaxAge int `json:\"max_age\"`\n}\n\n// sendFileStore is used to keep the SendFile configuration and the handler.\ntype sendFileStore struct {\n\thandler           fasthttp.RequestHandler\n\tcacheControlValue string\n\tconfig            SendFile\n}\n\n// compareConfig compares the current SendFile config with the new one\n// and returns true if they are different.\n//\n// Here we don't use reflect.DeepEqual because it is quite slow compared to manual comparison.\nfunc (sf *sendFileStore) compareConfig(cfg SendFile) bool {\n\tif sf.config.FS != cfg.FS {\n\t\treturn false\n\t}\n\n\tif sf.config.Compress != cfg.Compress {\n\t\treturn false\n\t}\n\n\tif sf.config.ByteRange != cfg.ByteRange {\n\t\treturn false\n\t}\n\n\tif sf.config.Download != cfg.Download {\n\t\treturn false\n\t}\n\n\tif sf.config.CacheDuration != cfg.CacheDuration {\n\t\treturn false\n\t}\n\n\tif sf.config.MaxAge != cfg.MaxAge {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// TLSHandler object\ntype TLSHandler struct {\n\tclientHelloInfo *tls.ClientHelloInfo\n}\n\n// GetClientInfo Callback function to set ClientHelloInfo\n// Must comply with the method structure of https://cs.opensource.google/go/go/+/refs/tags/go1.20:src/crypto/tls/common.go;l=554-563\n// Since we overlay the method of the TLS config in the listener method\nfunc (t *TLSHandler) GetClientInfo(info *tls.ClientHelloInfo) (*tls.Certificate, error) {\n\tt.clientHelloInfo = info\n\treturn nil, nil //nolint:nilnil // Not returning anything useful here is probably fine\n}\n\n// Range data for c.Range\ntype Range struct {\n\tType   string\n\tRanges []RangeSet\n}\n\n// RangeSet represents a single content range from a request.\ntype RangeSet struct {\n\tStart int\n\tEnd   int\n}\n\n// Cookie data for c.Cookie\ntype Cookie struct {\n\tExpires     time.Time `json:\"expires\"`      // The expiration date of the cookie\n\tName        string    `json:\"name\"`         // The name of the cookie\n\tValue       string    `json:\"value\"`        // The value of the cookie\n\tPath        string    `json:\"path\"`         // Specifies a URL path which is allowed to receive the cookie\n\tDomain      string    `json:\"domain\"`       // Specifies the domain which is allowed to receive the cookie\n\tSameSite    string    `json:\"same_site\"`    // Controls whether or not a cookie is sent with cross-site requests\n\tMaxAge      int       `json:\"max_age\"`      // The maximum age (in seconds) of the cookie\n\tSecure      bool      `json:\"secure\"`       // Indicates that the cookie should only be transmitted over a secure HTTPS connection\n\tHTTPOnly    bool      `json:\"http_only\"`    // Indicates that the cookie is accessible only through the HTTP protocol\n\tPartitioned bool      `json:\"partitioned\"`  // Indicates if the cookie is stored in a partitioned cookie jar\n\tSessionOnly bool      `json:\"session_only\"` // Indicates if the cookie is a session-only cookie\n}\n\n// Views is the interface that wraps the Render function.\ntype Views interface {\n\tLoad() error\n\tRender(out io.Writer, name string, binding any, layout ...string) error\n}\n\n// ResFmt associates a Content Type to a fiber.Handler for c.Format\ntype ResFmt struct {\n\tHandler   func(Ctx) error\n\tMediaType string\n}\n\n// Accepts checks if the specified extensions or content types are acceptable.\nfunc (c *DefaultCtx) Accepts(offers ...string) string {\n\treturn getOffer(c.fasthttp.Request.Header.Peek(HeaderAccept), acceptsOfferType, offers...)\n}\n\n// AcceptsCharsets checks if the specified charset is acceptable.\nfunc (c *DefaultCtx) AcceptsCharsets(offers ...string) string {\n\treturn getOffer(c.fasthttp.Request.Header.Peek(HeaderAcceptCharset), acceptsOffer, offers...)\n}\n\n// AcceptsEncodings checks if the specified encoding is acceptable.\nfunc (c *DefaultCtx) AcceptsEncodings(offers ...string) string {\n\treturn getOffer(c.fasthttp.Request.Header.Peek(HeaderAcceptEncoding), acceptsOffer, offers...)\n}\n\n// AcceptsLanguages checks if the specified language is acceptable.\nfunc (c *DefaultCtx) AcceptsLanguages(offers ...string) string {\n\treturn getOffer(c.fasthttp.Request.Header.Peek(HeaderAcceptLanguage), acceptsOffer, offers...)\n}\n\n// App returns the *App reference to the instance of the Fiber application\nfunc (c *DefaultCtx) App() *App {\n\treturn c.app\n}\n\n// Append the specified value to the HTTP response header field.\n// If the header is not already set, it creates the header with the specified value.\nfunc (c *DefaultCtx) Append(field string, values ...string) {\n\tif len(values) == 0 {\n\t\treturn\n\t}\n\th := c.app.getString(c.fasthttp.Response.Header.Peek(field))\n\toriginalH := h\n\tfor _, value := range values {\n\t\tif len(h) == 0 {\n\t\t\th = value\n\t\t} else if h != value && !strings.HasPrefix(h, value+\",\") && !strings.HasSuffix(h, \" \"+value) &&\n\t\t\t!strings.Contains(h, \" \"+value+\",\") {\n\t\t\th += \", \" + value\n\t\t}\n\t}\n\tif originalH != h {\n\t\tc.Set(field, h)\n\t}\n}\n\n// Attachment sets the HTTP response Content-Disposition header field to attachment.\nfunc (c *DefaultCtx) Attachment(filename ...string) {\n\tif len(filename) > 0 {\n\t\tfname := filepath.Base(filename[0])\n\t\tc.Type(filepath.Ext(fname))\n\n\t\tc.setCanonical(HeaderContentDisposition, `attachment; filename=\"`+c.app.quoteString(fname)+`\"`)\n\t\treturn\n\t}\n\tc.setCanonical(HeaderContentDisposition, \"attachment\")\n}\n\n// BaseURL returns (protocol + host + base path).\nfunc (c *DefaultCtx) BaseURL() string {\n\t// TODO: Could be improved: 53.8 ns/op  32 B/op  1 allocs/op\n\t// Should work like https://codeigniter.com/user_guide/helpers/url_helper.html\n\tif c.baseURI != \"\" {\n\t\treturn c.baseURI\n\t}\n\tc.baseURI = c.Scheme() + \"://\" + c.Host()\n\treturn c.baseURI\n}\n\n// BodyRaw contains the raw body submitted in a POST request.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *DefaultCtx) BodyRaw() []byte {\n\treturn c.getBody()\n}\n\nfunc (c *DefaultCtx) tryDecodeBodyInOrder(\n\toriginalBody *[]byte,\n\tencodings []string,\n) ([]byte, uint8, error) {\n\tvar (\n\t\terr             error\n\t\tbody            []byte\n\t\tdecodesRealized uint8\n\t)\n\n\tfor index, encoding := range encodings {\n\t\tdecodesRealized++\n\t\tswitch encoding {\n\t\tcase StrGzip:\n\t\t\tbody, err = c.fasthttp.Request.BodyGunzip()\n\t\tcase StrBr, StrBrotli:\n\t\t\tbody, err = c.fasthttp.Request.BodyUnbrotli()\n\t\tcase StrDeflate:\n\t\t\tbody, err = c.fasthttp.Request.BodyInflate()\n\t\tcase StrZstd:\n\t\t\tbody, err = c.fasthttp.Request.BodyUnzstd()\n\t\tdefault:\n\t\t\tdecodesRealized--\n\t\t\tif len(encodings) == 1 {\n\t\t\t\tbody = c.fasthttp.Request.Body()\n\t\t\t}\n\t\t\treturn body, decodesRealized, nil\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, decodesRealized, err\n\t\t}\n\n\t\t// Only execute body raw update if it has a next iteration to try to decode\n\t\tif index < len(encodings)-1 && decodesRealized > 0 {\n\t\t\tif index == 0 {\n\t\t\t\ttempBody := c.fasthttp.Request.Body()\n\t\t\t\t*originalBody = make([]byte, len(tempBody))\n\t\t\t\tcopy(*originalBody, tempBody)\n\t\t\t}\n\t\t\tc.fasthttp.Request.SetBodyRaw(body)\n\t\t}\n\t}\n\n\treturn body, decodesRealized, nil\n}\n\n// Body contains the raw body submitted in a POST request.\n// This method will decompress the body if the 'Content-Encoding' header is provided.\n// It returns the original (or decompressed) body data which is valid only within the handler.\n// Don't store direct references to the returned data.\n// If you need to keep the body's data later, make a copy or use the Immutable option.\nfunc (c *DefaultCtx) Body() []byte {\n\tvar (\n\t\terr                error\n\t\tbody, originalBody []byte\n\t\theaderEncoding     string\n\t\tencodingOrder      = []string{\"\", \"\", \"\"}\n\t)\n\n\t// Get Content-Encoding header\n\theaderEncoding = utils.UnsafeString(c.Request().Header.ContentEncoding())\n\n\t// If no encoding is provided, return the original body\n\tif len(headerEncoding) == 0 {\n\t\treturn c.getBody()\n\t}\n\n\t// Split and get the encodings list, in order to attend the\n\t// rule defined at: https://www.rfc-editor.org/rfc/rfc9110#section-8.4-5\n\tencodingOrder = getSplicedStrList(headerEncoding, encodingOrder)\n\tif len(encodingOrder) == 0 {\n\t\treturn c.getBody()\n\t}\n\n\tvar decodesRealized uint8\n\tbody, decodesRealized, err = c.tryDecodeBodyInOrder(&originalBody, encodingOrder)\n\n\t// Ensure that the body will be the original\n\tif originalBody != nil && decodesRealized > 0 {\n\t\tc.fasthttp.Request.SetBodyRaw(originalBody)\n\t}\n\tif err != nil {\n\t\treturn []byte(err.Error())\n\t}\n\n\tif c.app.config.Immutable {\n\t\treturn utils.CopyBytes(body)\n\t}\n\treturn body\n}\n\n// ClearCookie expires a specific cookie by key on the client side.\n// If no key is provided it expires all cookies that came with the request.\nfunc (c *DefaultCtx) ClearCookie(key ...string) {\n\tif len(key) > 0 {\n\t\tfor i := range key {\n\t\t\tc.fasthttp.Response.Header.DelClientCookie(key[i])\n\t\t}\n\t\treturn\n\t}\n\tc.fasthttp.Request.Header.VisitAllCookie(func(k, _ []byte) {\n\t\tc.fasthttp.Response.Header.DelClientCookieBytes(k)\n\t})\n}\n\n// RequestCtx returns *fasthttp.RequestCtx that carries a deadline\n// a cancellation signal, and other values across API boundaries.\nfunc (c *DefaultCtx) RequestCtx() *fasthttp.RequestCtx {\n\treturn c.fasthttp\n}\n\n// Context returns a context implementation that was set by\n// user earlier or returns a non-nil, empty context,if it was not set earlier.\nfunc (c *DefaultCtx) Context() context.Context {\n\tctx, ok := c.fasthttp.UserValue(userContextKey).(context.Context)\n\tif !ok {\n\t\tctx = context.Background()\n\t\tc.SetContext(ctx)\n\t}\n\n\treturn ctx\n}\n\n// SetContext sets a context implementation by user.\nfunc (c *DefaultCtx) SetContext(ctx context.Context) {\n\tc.fasthttp.SetUserValue(userContextKey, ctx)\n}\n\n// Cookie sets a cookie by passing a cookie struct.\nfunc (c *DefaultCtx) Cookie(cookie *Cookie) {\n\tfcookie := fasthttp.AcquireCookie()\n\tfcookie.SetKey(cookie.Name)\n\tfcookie.SetValue(cookie.Value)\n\tfcookie.SetPath(cookie.Path)\n\tfcookie.SetDomain(cookie.Domain)\n\t// only set max age and expiry when SessionOnly is false\n\t// i.e. cookie supposed to last beyond browser session\n\t// refer: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#define_the_lifetime_of_a_cookie\n\tif !cookie.SessionOnly {\n\t\tfcookie.SetMaxAge(cookie.MaxAge)\n\t\tfcookie.SetExpire(cookie.Expires)\n\t}\n\tfcookie.SetSecure(cookie.Secure)\n\tfcookie.SetHTTPOnly(cookie.HTTPOnly)\n\n\tswitch utils.ToLower(cookie.SameSite) {\n\tcase CookieSameSiteStrictMode:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteStrictMode)\n\tcase CookieSameSiteNoneMode:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteNoneMode)\n\tcase CookieSameSiteDisabled:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteDisabled)\n\tdefault:\n\t\tfcookie.SetSameSite(fasthttp.CookieSameSiteLaxMode)\n\t}\n\n\t// CHIPS allows to partition cookie jar by top-level site.\n\t// refer: https://developers.google.com/privacy-sandbox/3pcd/chips\n\tfcookie.SetPartitioned(cookie.Partitioned)\n\n\tc.fasthttp.Response.Header.SetCookie(fcookie)\n\tfasthttp.ReleaseCookie(fcookie)\n}\n\n// Cookies are used for getting a cookie value by key.\n// Defaults to the empty string \"\" if the cookie doesn't exist.\n// If a default value is given, it will return that value if the cookie doesn't exist.\n// The returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n}\n\n// Download transfers the file from path as an attachment.\n// Typically, browsers will prompt the user for download.\n// By default, the Content-Disposition header filename= parameter is the filepath (this typically appears in the browser dialog).\n// Override this default with the filename parameter.\nfunc (c *DefaultCtx) Download(file string, filename ...string) error {\n\tvar fname string\n\tif len(filename) > 0 {\n\t\tfname = filename[0]\n\t} else {\n\t\tfname = filepath.Base(file)\n\t}\n\tc.setCanonical(HeaderContentDisposition, `attachment; filename=\"`+c.app.quoteString(fname)+`\"`)\n\treturn c.SendFile(file)\n}\n\n// Request return the *fasthttp.Request object\n// This allows you to use all fasthttp request methods\n// https://godoc.org/github.com/valyala/fasthttp#Request\nfunc (c *DefaultCtx) Request() *fasthttp.Request {\n\treturn &c.fasthttp.Request\n}\n\n// Response return the *fasthttp.Response object\n// This allows you to use all fasthttp response methods\n// https://godoc.org/github.com/valyala/fasthttp#Response\nfunc (c *DefaultCtx) Response() *fasthttp.Response {\n\treturn &c.fasthttp.Response\n}\n\n// Format performs content-negotiation on the Accept HTTP header.\n// It uses Accepts to select a proper format and calls the matching\n// user-provided handler function.\n// If no accepted format is found, and a format with MediaType \"default\" is given,\n// that default handler is called. If no format is found and no default is given,\n// StatusNotAcceptable is sent.\nfunc (c *DefaultCtx) Format(handlers ...ResFmt) error {\n\tif len(handlers) == 0 {\n\t\treturn ErrNoHandlers\n\t}\n\n\tc.Vary(HeaderAccept)\n\n\tif c.Get(HeaderAccept) == \"\" {\n\t\tc.Response().Header.SetContentType(handlers[0].MediaType)\n\t\treturn handlers[0].Handler(c)\n\t}\n\n\t// Using an int literal as the slice capacity allows for the slice to be\n\t// allocated on the stack. The number was chosen arbitrarily as an\n\t// approximation of the maximum number of content types a user might handle.\n\t// If the user goes over, it just causes allocations, so it's not a problem.\n\ttypes := make([]string, 0, 8)\n\tvar defaultHandler Handler\n\tfor _, h := range handlers {\n\t\tif h.MediaType == \"default\" {\n\t\t\tdefaultHandler = h.Handler\n\t\t\tcontinue\n\t\t}\n\t\ttypes = append(types, h.MediaType)\n\t}\n\taccept := c.Accepts(types...)\n\n\tif accept == \"\" {\n\t\tif defaultHandler == nil {\n\t\t\treturn c.SendStatus(StatusNotAcceptable)\n\t\t}\n\t\treturn defaultHandler(c)\n\t}\n\n\tfor _, h := range handlers {\n\t\tif h.MediaType == accept {\n\t\t\tc.Response().Header.SetContentType(h.MediaType)\n\t\t\treturn h.Handler(c)\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%w: format: an Accept was found but no handler was called\", errUnreachable)\n}\n\n// AutoFormat performs content-negotiation on the Accept HTTP header.\n// It uses Accepts to select a proper format.\n// The supported content types are text/html, text/plain, application/json, and application/xml.\n// For more flexible content negotiation, use Format.\n// If the header is not specified or there is no proper format, text/plain is used.\nfunc (c *DefaultCtx) AutoFormat(body any) error {\n\t// Get accepted content type\n\taccept := c.Accepts(\"html\", \"json\", \"txt\", \"xml\")\n\t// Set accepted content type\n\tc.Type(accept)\n\t// Type convert provided body\n\tvar b string\n\tswitch val := body.(type) {\n\tcase string:\n\t\tb = val\n\tcase []byte:\n\t\tb = c.app.getString(val)\n\tdefault:\n\t\tb = fmt.Sprintf(\"%v\", val)\n\t}\n\n\t// Format based on the accept content type\n\tswitch accept {\n\tcase \"html\":\n\t\treturn c.SendString(\"<p>\" + b + \"</p>\")\n\tcase \"json\":\n\t\treturn c.JSON(body)\n\tcase \"txt\":\n\t\treturn c.SendString(b)\n\tcase \"xml\":\n\t\treturn c.XML(body)\n\t}\n\treturn c.SendString(b)\n}\n\n// FormFile returns the first file by key from a MultipartForm.\nfunc (c *DefaultCtx) FormFile(key string) (*multipart.FileHeader, error) {\n\treturn c.fasthttp.FormFile(key)\n}\n\n// FormValue returns the first value by key from a MultipartForm.\n// Search is performed in QueryArgs, PostArgs, MultipartForm and FormFile in this particular order.\n// Defaults to the empty string \"\" if the form value doesn't exist.\n// If a default value is given, it will return that value if the form value does not exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *DefaultCtx) FormValue(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.FormValue(key)), defaultValue)\n}\n\n// Fresh returns true when the response is still “fresh” in the client's cache,\n// otherwise false is returned to indicate that the client cache is now stale\n// and the full response should be sent.\n// When a client sends the Cache-Control: no-cache request header to indicate an end-to-end\n// reload request, this module will return false to make handling these requests transparent.\n// https://github.com/jshttp/fresh/blob/10e0471669dbbfbfd8de65bc6efac2ddd0bfa057/index.js#L33\nfunc (c *DefaultCtx) Fresh() bool {\n\t// fields\n\tmodifiedSince := c.Get(HeaderIfModifiedSince)\n\tnoneMatch := c.Get(HeaderIfNoneMatch)\n\n\t// unconditional request\n\tif modifiedSince == \"\" && noneMatch == \"\" {\n\t\treturn false\n\t}\n\n\t// Always return stale when Cache-Control: no-cache\n\t// to support end-to-end reload requests\n\t// https://tools.ietf.org/html/rfc2616#section-14.9.4\n\tcacheControl := c.Get(HeaderCacheControl)\n\tif cacheControl != \"\" && isNoCache(cacheControl) {\n\t\treturn false\n\t}\n\n\t// if-none-match\n\tif noneMatch != \"\" && noneMatch != \"*\" {\n\t\tetag := c.app.getString(c.fasthttp.Response.Header.Peek(HeaderETag))\n\t\tif etag == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tif c.app.isEtagStale(etag, c.app.getBytes(noneMatch)) {\n\t\t\treturn false\n\t\t}\n\n\t\tif modifiedSince != \"\" {\n\t\t\tlastModified := c.app.getString(c.fasthttp.Response.Header.Peek(HeaderLastModified))\n\t\t\tif lastModified != \"\" {\n\t\t\t\tlastModifiedTime, err := http.ParseTime(lastModified)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tmodifiedSinceTime, err := http.ParseTime(modifiedSince)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn lastModifiedTime.Compare(modifiedSinceTime) != 1\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// Get returns the HTTP request header specified by field.\n// Field names are case-insensitive\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *DefaultCtx) Get(key string, defaultValue ...string) string {\n\treturn GetReqHeader(c, key, defaultValue...)\n}\n\n// GetReqHeader returns the HTTP request header specified by filed.\n// This function is generic and can handle different headers type values.\nfunc GetReqHeader[V GenericType](c Ctx, key string, defaultValue ...V) V {\n\tvar v V\n\treturn genericParseType[V](c.App().getString(c.Request().Header.Peek(key)), v, defaultValue...)\n}\n\n// GetRespHeader returns the HTTP response header specified by field.\n// Field names are case-insensitive\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *DefaultCtx) GetRespHeader(key string, defaultValue ...string) string {\n\treturn defaultString(c.app.getString(c.fasthttp.Response.Header.Peek(key)), defaultValue)\n}\n\n// GetRespHeaders returns the HTTP response headers.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *DefaultCtx) GetRespHeaders() map[string][]string {\n\theaders := make(map[string][]string)\n\tc.Response().Header.VisitAll(func(k, v []byte) {\n\t\tkey := c.app.getString(k)\n\t\theaders[key] = append(headers[key], c.app.getString(v))\n\t})\n\treturn headers\n}\n\n// GetReqHeaders returns the HTTP request headers.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting instead.\nfunc (c *DefaultCtx) GetReqHeaders() map[string][]string {\n\theaders := make(map[string][]string)\n\tc.Request().Header.VisitAll(func(k, v []byte) {\n\t\tkey := c.app.getString(k)\n\t\theaders[key] = append(headers[key], c.app.getString(v))\n\t})\n\treturn headers\n}\n\n// Host contains the host derived from the X-Forwarded-Host or Host HTTP header.\n// Returned value is only valid within the handler. Do not store any references.\n// In a network context, `Host` refers to the combination of a hostname and potentially a port number used for connecting,\n// while `Hostname` refers specifically to the name assigned to a device on a network, excluding any port information.\n// Example: URL: https://example.com:8080 -> Host: example.com:8080\n// Make copies or use the Immutable setting instead.\n// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *DefaultCtx) Host() string {\n\tif c.IsProxyTrusted() {\n\t\tif host := c.Get(HeaderXForwardedHost); len(host) > 0 {\n\t\t\tcommaPos := strings.Index(host, \",\")\n\t\t\tif commaPos != -1 {\n\t\t\t\treturn host[:commaPos]\n\t\t\t}\n\t\t\treturn host\n\t\t}\n\t}\n\treturn c.app.getString(c.fasthttp.Request.URI().Host())\n}\n\n// Hostname contains the hostname derived from the X-Forwarded-Host or Host HTTP header using the c.Host() method.\n// Returned value is only valid within the handler. Do not store any references.\n// Example: URL: https://example.com:8080 -> Hostname: example.com\n// Make copies or use the Immutable setting instead.\n// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *DefaultCtx) Hostname() string {\n\taddr, _ := parseAddr(c.Host())\n\n\treturn addr\n}\n\n// Port returns the remote port of the request.\nfunc (c *DefaultCtx) Port() string {\n\ttcpaddr, ok := c.fasthttp.RemoteAddr().(*net.TCPAddr)\n\tif !ok {\n\t\tpanic(errors.New(\"failed to type-assert to *net.TCPAddr\"))\n\t}\n\treturn strconv.Itoa(tcpaddr.Port)\n}\n\n// IP returns the remote IP address of the request.\n// If ProxyHeader and IP Validation is configured, it will parse that header and return the first valid IP address.\n// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *DefaultCtx) IP() string {\n\tif c.IsProxyTrusted() && len(c.app.config.ProxyHeader) > 0 {\n\t\treturn c.extractIPFromHeader(c.app.config.ProxyHeader)\n\t}\n\n\treturn c.fasthttp.RemoteIP().String()\n}\n\n// extractIPsFromHeader will return a slice of IPs it found given a header name in the order they appear.\n// When IP validation is enabled, any invalid IPs will be omitted.\nfunc (c *DefaultCtx) extractIPsFromHeader(header string) []string {\n\t// TODO: Reuse the c.extractIPFromHeader func somehow in here\n\n\theaderValue := c.Get(header)\n\n\t// We can't know how many IPs we will return, but we will try to guess with this constant division.\n\t// Counting ',' makes function slower for about 50ns in general case.\n\tconst maxEstimatedCount = 8\n\testimatedCount := len(headerValue) / maxEstimatedCount\n\tif estimatedCount > maxEstimatedCount {\n\t\testimatedCount = maxEstimatedCount // Avoid big allocation on big header\n\t}\n\n\tipsFound := make([]string, 0, estimatedCount)\n\n\ti := 0\n\tj := -1\n\niploop:\n\tfor {\n\t\tvar v4, v6 bool\n\n\t\t// Manually splitting string without allocating slice, working with parts directly\n\t\ti, j = j+1, j+2\n\n\t\tif j > len(headerValue) {\n\t\t\tbreak\n\t\t}\n\n\t\tfor j < len(headerValue) && headerValue[j] != ',' {\n\t\t\tif headerValue[j] == ':' {\n\t\t\t\tv6 = true\n\t\t\t} else if headerValue[j] == '.' {\n\t\t\t\tv4 = true\n\t\t\t}\n\t\t\tj++\n\t\t}\n\n\t\tfor i < j && (headerValue[i] == ' ' || headerValue[i] == ',') {\n\t\t\ti++\n\t\t}\n\n\t\ts := utils.TrimRight(headerValue[i:j], ' ')\n\n\t\tif c.app.config.EnableIPValidation {\n\t\t\t// Skip validation if IP is clearly not IPv4/IPv6, otherwise validate without allocations\n\t\t\tif (!v6 && !v4) || (v6 && !utils.IsIPv6(s)) || (v4 && !utils.IsIPv4(s)) {\n\t\t\t\tcontinue iploop\n\t\t\t}\n\t\t}\n\n\t\tipsFound = append(ipsFound, s)\n\t}\n\n\treturn ipsFound\n}\n\n// extractIPFromHeader will attempt to pull the real client IP from the given header when IP validation is enabled.\n// currently, it will return the first valid IP address in header.\n// when IP validation is disabled, it will simply return the value of the header without any inspection.\n// Implementation is almost the same as in extractIPsFromHeader, but without allocation of []string.\nfunc (c *DefaultCtx) extractIPFromHeader(header string) string {\n\tif c.app.config.EnableIPValidation {\n\t\theaderValue := c.Get(header)\n\n\t\ti := 0\n\t\tj := -1\n\n\tiploop:\n\t\tfor {\n\t\t\tvar v4, v6 bool\n\n\t\t\t// Manually splitting string without allocating slice, working with parts directly\n\t\t\ti, j = j+1, j+2\n\n\t\t\tif j > len(headerValue) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfor j < len(headerValue) && headerValue[j] != ',' {\n\t\t\t\tif headerValue[j] == ':' {\n\t\t\t\t\tv6 = true\n\t\t\t\t} else if headerValue[j] == '.' {\n\t\t\t\t\tv4 = true\n\t\t\t\t}\n\t\t\t\tj++\n\t\t\t}\n\n\t\t\tfor i < j && headerValue[i] == ' ' {\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\ts := utils.TrimRight(headerValue[i:j], ' ')\n\n\t\t\tif c.app.config.EnableIPValidation {\n\t\t\t\tif (!v6 && !v4) || (v6 && !utils.IsIPv6(s)) || (v4 && !utils.IsIPv4(s)) {\n\t\t\t\t\tcontinue iploop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn s\n\t\t}\n\n\t\treturn c.fasthttp.RemoteIP().String()\n\t}\n\n\t// default behavior if IP validation is not enabled is just to return whatever value is\n\t// in the proxy header. Even if it is empty or invalid\n\treturn c.Get(c.app.config.ProxyHeader)\n}\n\n// IPs returns a string slice of IP addresses specified in the X-Forwarded-For request header.\n// When IP validation is enabled, only valid IPs are returned.\nfunc (c *DefaultCtx) IPs() []string {\n\treturn c.extractIPsFromHeader(HeaderXForwardedFor)\n}\n\n// Is returns the matching content type,\n// if the incoming request's Content-Type HTTP header field matches the MIME type specified by the type parameter\nfunc (c *DefaultCtx) Is(extension string) bool {\n\textensionHeader := utils.GetMIME(extension)\n\tif extensionHeader == \"\" {\n\t\treturn false\n\t}\n\n\treturn strings.HasPrefix(\n\t\tutils.TrimLeft(utils.UnsafeString(c.fasthttp.Request.Header.ContentType()), ' '),\n\t\textensionHeader,\n\t)\n}\n\n// JSON converts any interface or string to JSON.\n// Array and slice values encode as JSON arrays,\n// except that []byte encodes as a base64-encoded string,\n// and a nil slice encodes as the null JSON value.\n// If the ctype parameter is given, this method will set the\n// Content-Type header equal to ctype. If ctype is not given,\n// The Content-Type header will be set to application/json.\nfunc (c *DefaultCtx) JSON(data any, ctype ...string) error {\n\traw, err := c.app.config.JSONEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tif len(ctype) > 0 {\n\t\tc.fasthttp.Response.Header.SetContentType(ctype[0])\n\t} else {\n\t\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationJSON)\n\t}\n\treturn nil\n}\n\n// CBOR converts any interface or string to CBOR encoded bytes.\n// If the ctype parameter is given, this method will set the\n// Content-Type header equal to ctype. If ctype is not given,\n// The Content-Type header will be set to application/cbor.\nfunc (c *DefaultCtx) CBOR(data any, ctype ...string) error {\n\traw, err := c.app.config.CBOREncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tif len(ctype) > 0 {\n\t\tc.fasthttp.Response.Header.SetContentType(ctype[0])\n\t} else {\n\t\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationCBOR)\n\t}\n\treturn nil\n}\n\n// JSONP sends a JSON response with JSONP support.\n// This method is identical to JSON, except that it opts-in to JSONP callback support.\n// By default, the callback name is simply callback.\nfunc (c *DefaultCtx) JSONP(data any, callback ...string) error {\n\traw, err := c.app.config.JSONEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar result, cb string\n\n\tif len(callback) > 0 {\n\t\tcb = callback[0]\n\t} else {\n\t\tcb = \"callback\"\n\t}\n\n\tresult = cb + \"(\" + c.app.getString(raw) + \");\"\n\n\tc.setCanonical(HeaderXContentTypeOptions, \"nosniff\")\n\tc.fasthttp.Response.Header.SetContentType(MIMETextJavaScriptCharsetUTF8)\n\treturn c.SendString(result)\n}\n\n// XML converts any interface or string to XML.\n// This method also sets the content header to application/xml.\nfunc (c *DefaultCtx) XML(data any) error {\n\traw, err := c.app.config.XMLEncoder(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fasthttp.Response.SetBodyRaw(raw)\n\tc.fasthttp.Response.Header.SetContentType(MIMEApplicationXML)\n\treturn nil\n}\n\n// Links joins the links followed by the property to populate the response's Link HTTP header field.\nfunc (c *DefaultCtx) Links(link ...string) {\n\tif len(link) == 0 {\n\t\treturn\n\t}\n\tbb := bytebufferpool.Get()\n\tfor i := range link {\n\t\tif i%2 == 0 {\n\t\t\tbb.WriteByte('<')\n\t\t\tbb.WriteString(link[i])\n\t\t\tbb.WriteByte('>')\n\t\t} else {\n\t\t\tbb.WriteString(`; rel=\"` + link[i] + `\",`)\n\t\t}\n\t}\n\tc.setCanonical(HeaderLink, utils.TrimRight(c.app.getString(bb.Bytes()), ','))\n\tbytebufferpool.Put(bb)\n}\n\n// Locals makes it possible to pass any values under keys scoped to the request\n// and therefore available to all following routes that match the request.\n//\n// All the values are removed from ctx after returning from the top\n// RequestHandler. Additionally, Close method is called on each value\n// implementing io.Closer before removing the value from ctx.\nfunc (c *DefaultCtx) Locals(key any, value ...any) any {\n\tif len(value) == 0 {\n\t\treturn c.fasthttp.UserValue(key)\n\t}\n\tc.fasthttp.SetUserValue(key, value[0])\n\treturn value[0]\n}\n\n// Locals function utilizing Go's generics feature.\n// This function allows for manipulating and retrieving local values within a\n// request context with a more specific data type.\n//\n// All the values are removed from ctx after returning from the top\n// RequestHandler. Additionally, Close method is called on each value\n// implementing io.Closer before removing the value from ctx.\nfunc Locals[V any](c Ctx, key any, value ...V) V {\n\tvar v V\n\tvar ok bool\n\tif len(value) == 0 {\n\t\tv, ok = c.Locals(key).(V)\n\t} else {\n\t\tv, ok = c.Locals(key, value[0]).(V)\n\t}\n\tif !ok {\n\t\treturn v // return zero of type V\n\t}\n\treturn v\n}\n\n// Location sets the response Location HTTP header to the specified path parameter.\nfunc (c *DefaultCtx) Location(path string) {\n\tc.setCanonical(HeaderLocation, path)\n}\n\n// Method returns the HTTP request method for the context, optionally overridden by the provided argument.\n// If no override is given or if the provided override is not a valid HTTP method, it returns the current method from the context.\n// Otherwise, it updates the context's method and returns the overridden method as a string.\nfunc (c *DefaultCtx) Method(override ...string) string {\n\tif len(override) == 0 {\n\t\t// Nothing to override, just return current method from context\n\t\treturn c.method\n\t}\n\n\tmethod := utils.ToUpper(override[0])\n\tmINT := c.app.methodInt(method)\n\tif mINT == -1 {\n\t\t// Provided override does not valid HTTP method, no override, return current method\n\t\treturn c.method\n\t}\n\n\tc.method = method\n\tc.methodINT = mINT\n\treturn c.method\n}\n\n// MultipartForm parse form entries from binary.\n// This returns a map[string][]string, so given a key the value will be a string slice.\nfunc (c *DefaultCtx) MultipartForm() (*multipart.Form, error) {\n\treturn c.fasthttp.MultipartForm()\n}\n\n// ClientHelloInfo return CHI from context\nfunc (c *DefaultCtx) ClientHelloInfo() *tls.ClientHelloInfo {\n\tif c.app.tlsHandler != nil {\n\t\treturn c.app.tlsHandler.clientHelloInfo\n\t}\n\n\treturn nil\n}\n\n// Next executes the next method in the stack that matches the current route.\nfunc (c *DefaultCtx) Next() error {\n\t// Increment handler index\n\tc.indexHandler++\n\n\t// Did we execute all route handlers?\n\tif c.indexHandler < len(c.route.Handlers) {\n\t\t// Continue route stack\n\t\treturn c.route.Handlers[c.indexHandler](c)\n\t}\n\n\t// Continue handler stack\n\tif c.app.newCtxFunc != nil {\n\t\t_, err := c.app.nextCustom(c)\n\t\treturn err\n\t}\n\n\t_, err := c.app.next(c)\n\treturn err\n}\n\n// RestartRouting instead of going to the next handler. This may be useful after\n// changing the request path. Note that handlers might be executed again.\nfunc (c *DefaultCtx) RestartRouting() error {\n\tvar err error\n\n\tc.indexRoute = -1\n\tif c.app.newCtxFunc != nil {\n\t\t_, err = c.app.nextCustom(c)\n\t} else {\n\t\t_, err = c.app.next(c)\n\t}\n\treturn err\n}\n\n// OriginalURL contains the original request URL.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *DefaultCtx) OriginalURL() string {\n\treturn c.app.getString(c.fasthttp.Request.Header.RequestURI())\n}\n\n// Params is used to get the route parameters.\n// Defaults to empty string \"\" if the param doesn't exist.\n// If a default value is given, it will return that value if the param doesn't exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *DefaultCtx) Params(key string, defaultValue ...string) string {\n\tif key == \"*\" || key == \"+\" {\n\t\tkey += \"1\"\n\t}\n\n\troute := c.Route()\n\tfor i := range route.Params {\n\t\tif len(key) != len(c.route.Params[i]) {\n\t\t\tcontinue\n\t\t}\n\t\tif route.Params[i] == key || (!c.app.config.CaseSensitive && utils.EqualFold(route.Params[i], key)) {\n\t\t\t// in case values are not here\n\t\t\tif len(c.values) <= i || len(c.values[i]) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn c.values[i]\n\t\t}\n\t}\n\treturn defaultString(\"\", defaultValue)\n}\n\n// Params is used to get the route parameters.\n// This function is generic and can handle different route parameters type values.\n//\n// Example:\n//\n// http://example.com/user/:user -> http://example.com/user/john\n// Params[string](c, \"user\") -> returns john\n//\n// http://example.com/id/:id -> http://example.com/user/114\n// Params[int](c, \"id\") ->  returns 114 as integer.\n//\n// http://example.com/id/:number -> http://example.com/id/john\n// Params[int](c, \"number\", 0) -> returns 0 because can't parse 'john' as integer.\nfunc Params[V GenericType](c Ctx, key string, defaultValue ...V) V {\n\tvar v V\n\treturn genericParseType(c.Params(key), v, defaultValue...)\n}\n\n// Path returns the path part of the request URL.\n// Optionally, you could override the path.\nfunc (c *DefaultCtx) Path(override ...string) string {\n\tif len(override) != 0 && c.path != override[0] {\n\t\t// Set new path to context\n\t\tc.pathOriginal = override[0]\n\n\t\t// Set new path to request context\n\t\tc.fasthttp.Request.URI().SetPath(c.pathOriginal)\n\t\t// Prettify path\n\t\tc.configDependentPaths()\n\t}\n\treturn c.path\n}\n\n// Scheme contains the request protocol string: http or https for TLS requests.\n// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\nfunc (c *DefaultCtx) Scheme() string {\n\tif c.fasthttp.IsTLS() {\n\t\treturn schemeHTTPS\n\t}\n\tif !c.IsProxyTrusted() {\n\t\treturn schemeHTTP\n\t}\n\n\tscheme := schemeHTTP\n\tconst lenXHeaderName = 12\n\tc.fasthttp.Request.Header.VisitAll(func(key, val []byte) {\n\t\tif len(key) < lenXHeaderName {\n\t\t\treturn // Neither \"X-Forwarded-\" nor \"X-Url-Scheme\"\n\t\t}\n\t\tswitch {\n\t\tcase bytes.HasPrefix(key, []byte(\"X-Forwarded-\")):\n\t\t\tif bytes.Equal(key, []byte(HeaderXForwardedProto)) ||\n\t\t\t\tbytes.Equal(key, []byte(HeaderXForwardedProtocol)) {\n\t\t\t\tv := c.app.getString(val)\n\t\t\t\tcommaPos := strings.Index(v, \",\")\n\t\t\t\tif commaPos != -1 {\n\t\t\t\t\tscheme = v[:commaPos]\n\t\t\t\t} else {\n\t\t\t\t\tscheme = v\n\t\t\t\t}\n\t\t\t} else if bytes.Equal(key, []byte(HeaderXForwardedSsl)) && bytes.Equal(val, []byte(\"on\")) {\n\t\t\t\tscheme = schemeHTTPS\n\t\t\t}\n\n\t\tcase bytes.Equal(key, []byte(HeaderXUrlScheme)):\n\t\t\tscheme = c.app.getString(val)\n\t\t}\n\t})\n\treturn scheme\n}\n\n// Protocol returns the HTTP protocol of request: HTTP/1.1 and HTTP/2.\nfunc (c *DefaultCtx) Protocol() string {\n\treturn utils.UnsafeString(c.fasthttp.Request.Header.Protocol())\n}\n\n// Query returns the query string parameter in the url.\n// Defaults to empty string \"\" if the query doesn't exist.\n// If a default value is given, it will return that value if the query doesn't exist.\n// Returned value is only valid within the handler. Do not store any references.\n// Make copies or use the Immutable setting to use the value outside the Handler.\nfunc (c *DefaultCtx) Query(key string, defaultValue ...string) string {\n\treturn Query[string](c, key, defaultValue...)\n}\n\n// Queries returns a map of query parameters and their values.\n//\n// GET /?name=alex&wanna_cake=2&id=\n// Queries()[\"name\"] == \"alex\"\n// Queries()[\"wanna_cake\"] == \"2\"\n// Queries()[\"id\"] == \"\"\n//\n// GET /?field1=value1&field1=value2&field2=value3\n// Queries()[\"field1\"] == \"value2\"\n// Queries()[\"field2\"] == \"value3\"\n//\n// GET /?list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\n// Queries()[\"list_a\"] == \"3\"\n// Queries()[\"list_b[]\"] == \"3\"\n// Queries()[\"list_c\"] == \"1,2,3\"\n//\n// GET /api/search?filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\n// Queries()[\"filters.author.name\"] == \"John\"\n// Queries()[\"filters.category.name\"] == \"Technology\"\n// Queries()[\"filters[customer][name]\"] == \"Alice\"\n// Queries()[\"filters[status]\"] == \"pending\"\nfunc (c *DefaultCtx) Queries() map[string]string {\n\tm := make(map[string]string, c.RequestCtx().QueryArgs().Len())\n\tc.RequestCtx().QueryArgs().VisitAll(func(key, value []byte) {\n\t\tm[c.app.getString(key)] = c.app.getString(value)\n\t})\n\treturn m\n}\n\n// Query Retrieves the value of a query parameter from the request's URI.\n// The function is generic and can handle query parameter values of different types.\n// It takes the following parameters:\n// - c: The context object representing the current request.\n// - key: The name of the query parameter.\n// - defaultValue: (Optional) The default value to return in case the query parameter is not found or cannot be parsed.\n// The function performs the following steps:\n//  1. Type-asserts the context object to *DefaultCtx.\n//  2. Retrieves the raw query parameter value from the request's URI.\n//  3. Parses the raw value into the appropriate type based on the generic type parameter V.\n//     If parsing fails, the function checks if a default value is provided. If so, it returns the default value.\n//  4. Returns the parsed value.\n//\n// If the generic type cannot be matched to a supported type, the function returns the default value (if provided) or the zero value of type V.\n//\n// Example usage:\n//\n//\tGET /?search=john&age=8\n//\tname := Query[string](c, \"search\") // Returns \"john\"\n//\tage := Query[int](c, \"age\") // Returns 8\n//\tunknown := Query[string](c, \"unknown\", \"default\") // Returns \"default\" since the query parameter \"unknown\" is not found\nfunc Query[V GenericType](c Ctx, key string, defaultValue ...V) V {\n\tvar v V\n\tq := c.App().getString(c.RequestCtx().QueryArgs().Peek(key))\n\n\treturn genericParseType[V](q, v, defaultValue...)\n}\n\n// Range returns a struct containing the type and a slice of ranges.\nfunc (c *DefaultCtx) Range(size int) (Range, error) {\n\tvar (\n\t\trangeData Range\n\t\tranges    string\n\t)\n\trangeStr := c.Get(HeaderRange)\n\n\ti := strings.IndexByte(rangeStr, '=')\n\tif i == -1 || strings.Contains(rangeStr[i+1:], \"=\") {\n\t\treturn rangeData, ErrRangeMalformed\n\t}\n\trangeData.Type = rangeStr[:i]\n\tranges = rangeStr[i+1:]\n\n\tvar (\n\t\tsingleRange string\n\t\tmoreRanges  = ranges\n\t)\n\tfor moreRanges != \"\" {\n\t\tsingleRange = moreRanges\n\t\tif i := strings.IndexByte(moreRanges, ','); i >= 0 {\n\t\t\tsingleRange = moreRanges[:i]\n\t\t\tmoreRanges = moreRanges[i+1:]\n\t\t} else {\n\t\t\tmoreRanges = \"\"\n\t\t}\n\n\t\tvar (\n\t\t\tstartStr, endStr string\n\t\t\ti                int\n\t\t)\n\t\tif i = strings.IndexByte(singleRange, '-'); i == -1 {\n\t\t\treturn rangeData, ErrRangeMalformed\n\t\t}\n\t\tstartStr = singleRange[:i]\n\t\tendStr = singleRange[i+1:]\n\n\t\tstart, startErr := fasthttp.ParseUint(utils.UnsafeBytes(startStr))\n\t\tend, endErr := fasthttp.ParseUint(utils.UnsafeBytes(endStr))\n\t\tif startErr != nil { // -nnn\n\t\t\tstart = size - end\n\t\t\tend = size - 1\n\t\t} else if endErr != nil { // nnn-\n\t\t\tend = size - 1\n\t\t}\n\t\tif end > size-1 { // limit last-byte-pos to current length\n\t\t\tend = size - 1\n\t\t}\n\t\tif start > end || start < 0 {\n\t\t\tcontinue\n\t\t}\n\t\trangeData.Ranges = append(rangeData.Ranges, struct {\n\t\t\tStart int\n\t\t\tEnd   int\n\t\t}{\n\t\t\tStart: start,\n\t\t\tEnd:   end,\n\t\t})\n\t}\n\tif len(rangeData.Ranges) < 1 {\n\t\treturn rangeData, ErrRangeUnsatisfiable\n\t}\n\n\treturn rangeData, nil\n}\n\n// Redirect returns the Redirect reference.\n// Use Redirect().Status() to set custom redirection status code.\n// If status is not specified, status defaults to 302 Found.\n// You can use Redirect().To(), Redirect().Route() and Redirect().Back() for redirection.\nfunc (c *DefaultCtx) Redirect() *Redirect {\n\tif c.redirect == nil {\n\t\tc.redirect = AcquireRedirect()\n\t\tc.redirect.c = c\n\t}\n\n\treturn c.redirect\n}\n\n// ViewBind Add vars to default view var map binding to template engine.\n// Variables are read by the Render method and may be overwritten.\nfunc (c *DefaultCtx) ViewBind(vars Map) error {\n\t// init viewBindMap - lazy map\n\tfor k, v := range vars {\n\t\tc.viewBindMap.Store(k, v)\n\t}\n\treturn nil\n}\n\n// getLocationFromRoute get URL location from route using parameters\nfunc (c *DefaultCtx) getLocationFromRoute(route Route, params Map) (string, error) {\n\tbuf := bytebufferpool.Get()\n\tfor _, segment := range route.routeParser.segs {\n\t\tif !segment.IsParam {\n\t\t\t_, err := buf.WriteString(segment.Const)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to write string: %w\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor key, val := range params {\n\t\t\tisSame := key == segment.ParamName || (!c.app.config.CaseSensitive && utils.EqualFold(key, segment.ParamName))\n\t\t\tisGreedy := segment.IsGreedy && len(key) == 1 && isInCharset(key[0], greedyParameters)\n\t\t\tif isSame || isGreedy {\n\t\t\t\t_, err := buf.WriteString(utils.ToString(val))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", fmt.Errorf(\"failed to write string: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlocation := buf.String()\n\t// release buffer\n\tbytebufferpool.Put(buf)\n\treturn location, nil\n}\n\n// GetRouteURL generates URLs to named routes, with parameters. URLs are relative, for example: \"/user/1831\"\nfunc (c *DefaultCtx) GetRouteURL(routeName string, params Map) (string, error) {\n\treturn c.getLocationFromRoute(c.App().GetRoute(routeName), params)\n}\n\n// Render a template with data and sends a text/html response.\n// We support the following engines: https://github.com/gofiber/template\nfunc (c *DefaultCtx) Render(name string, bind any, layouts ...string) error {\n\t// Get new buffer from pool\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\t// Initialize empty bind map if bind is nil\n\tif bind == nil {\n\t\tbind = make(Map)\n\t}\n\n\t// Pass-locals-to-views, bind, appListKeys\n\tc.renderExtensions(bind)\n\n\tvar rendered bool\n\tfor i := len(c.app.mountFields.appListKeys) - 1; i >= 0; i-- {\n\t\tprefix := c.app.mountFields.appListKeys[i]\n\t\tapp := c.app.mountFields.appList[prefix]\n\t\tif prefix == \"\" || strings.Contains(c.OriginalURL(), prefix) {\n\t\t\tif len(layouts) == 0 && app.config.ViewsLayout != \"\" {\n\t\t\t\tlayouts = []string{\n\t\t\t\t\tapp.config.ViewsLayout,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Render template from Views\n\t\t\tif app.config.Views != nil {\n\t\t\t\tif err := app.config.Views.Render(buf, name, bind, layouts...); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to render: %w\", err)\n\t\t\t\t}\n\n\t\t\t\trendered = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !rendered {\n\t\t// Render raw template using 'name' as filepath if no engine is set\n\t\tvar tmpl *template.Template\n\t\tif _, err := readContent(buf, name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Parse template\n\t\ttmpl, err := template.New(\"\").Parse(c.app.getString(buf.Bytes()))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse: %w\", err)\n\t\t}\n\t\tbuf.Reset()\n\t\t// Render template\n\t\tif err := tmpl.Execute(buf, bind); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute: %w\", err)\n\t\t}\n\t}\n\n\t// Set Content-Type to text/html\n\tc.fasthttp.Response.Header.SetContentType(MIMETextHTMLCharsetUTF8)\n\t// Set rendered template to body\n\tc.fasthttp.Response.SetBody(buf.Bytes())\n\n\treturn nil\n}\n\nfunc (c *DefaultCtx) renderExtensions(bind any) {\n\tif bindMap, ok := bind.(Map); ok {\n\t\t// Bind view map\n\t\tc.viewBindMap.Range(func(key, value any) bool {\n\t\t\tkeyValue, ok := key.(string)\n\t\t\tif !ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif _, ok := bindMap[keyValue]; !ok {\n\t\t\t\tbindMap[keyValue] = value\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\t// Check if the PassLocalsToViews option is enabled (by default it is disabled)\n\t\tif c.app.config.PassLocalsToViews {\n\t\t\t// Loop through each local and set it in the map\n\t\t\tc.fasthttp.VisitUserValues(func(key []byte, val any) {\n\t\t\t\t// check if bindMap doesn't contain the key\n\t\t\t\tif _, ok := bindMap[c.app.getString(key)]; !ok {\n\t\t\t\t\t// Set the key and value in the bindMap\n\t\t\t\t\tbindMap[c.app.getString(key)] = val\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tif len(c.app.mountFields.appListKeys) == 0 {\n\t\tc.app.generateAppListKeys()\n\t}\n}\n\n// Route returns the matched Route struct.\nfunc (c *DefaultCtx) Route() *Route {\n\tif c.route == nil {\n\t\t// Fallback for fasthttp error handler\n\t\treturn &Route{\n\t\t\tpath:     c.pathOriginal,\n\t\t\tPath:     c.pathOriginal,\n\t\t\tMethod:   c.method,\n\t\t\tHandlers: make([]Handler, 0),\n\t\t\tParams:   make([]string, 0),\n\t\t}\n\t}\n\treturn c.route\n}\n\n// SaveFile saves any multipart file to disk.\nfunc (*DefaultCtx) SaveFile(fileheader *multipart.FileHeader, path string) error {\n\treturn fasthttp.SaveMultipartFile(fileheader, path)\n}\n\n// SaveFileToStorage saves any multipart file to an external storage system.\nfunc (*DefaultCtx) SaveFileToStorage(fileheader *multipart.FileHeader, path string, storage Storage) error {\n\tfile, err := fileheader.Open()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open: %w\", err)\n\t}\n\tdefer file.Close() //nolint:errcheck // not needed\n\n\tcontent, err := io.ReadAll(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\n\tif err := storage.Set(path, content, 0); err != nil {\n\t\treturn fmt.Errorf(\"failed to store: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// Secure returns whether a secure connection was established.\nfunc (c *DefaultCtx) Secure() bool {\n\treturn c.Protocol() == schemeHTTPS\n}\n\n// Send sets the HTTP response body without copying it.\n// From this point onward the body argument must not be changed.\nfunc (c *DefaultCtx) Send(body []byte) error {\n\t// Write response body\n\tc.fasthttp.Response.SetBodyRaw(body)\n\treturn nil\n}\n\n// SendFile transfers the file from the specified path.\n// By default, the file is not compressed. To enable compression, set SendFile.Compress to true.\n// The Content-Type response HTTP header field is set based on the file's extension.\n// If the file extension is missing or invalid, the Content-Type is detected from the file's format.\nfunc (c *DefaultCtx) SendFile(file string, config ...SendFile) error {\n\t// Save the filename, we will need it in the error message if the file isn't found\n\tfilename := file\n\n\tvar cfg SendFile\n\tif len(config) > 0 {\n\t\tcfg = config[0]\n\t}\n\n\tif cfg.CacheDuration == 0 {\n\t\tcfg.CacheDuration = 10 * time.Second\n\t}\n\n\tvar fsHandler fasthttp.RequestHandler\n\tvar cacheControlValue string\n\n\tc.app.sendfilesMutex.RLock()\n\tfor _, sf := range c.app.sendfiles {\n\t\tif sf.compareConfig(cfg) {\n\t\t\tfsHandler = sf.handler\n\t\t\tcacheControlValue = sf.cacheControlValue\n\t\t\tbreak\n\t\t}\n\t}\n\tc.app.sendfilesMutex.RUnlock()\n\n\tif fsHandler == nil {\n\t\tfasthttpFS := &fasthttp.FS{\n\t\t\tRoot:                   \"\",\n\t\t\tFS:                     cfg.FS,\n\t\t\tAllowEmptyRoot:         true,\n\t\t\tGenerateIndexPages:     false,\n\t\t\tAcceptByteRange:        cfg.ByteRange,\n\t\t\tCompress:               cfg.Compress,\n\t\t\tCompressBrotli:         cfg.Compress,\n\t\t\tCompressedFileSuffixes: c.app.config.CompressedFileSuffixes,\n\t\t\tCacheDuration:          cfg.CacheDuration,\n\t\t\tSkipCache:              cfg.CacheDuration < 0,\n\t\t\tIndexNames:             []string{\"index.html\"},\n\t\t\tPathNotFound: func(ctx *fasthttp.RequestCtx) {\n\t\t\t\tctx.Response.SetStatusCode(StatusNotFound)\n\t\t\t},\n\t\t}\n\n\t\tif cfg.FS != nil {\n\t\t\tfasthttpFS.Root = \".\"\n\t\t}\n\n\t\tsf := &sendFileStore{\n\t\t\tconfig:  cfg,\n\t\t\thandler: fasthttpFS.NewRequestHandler(),\n\t\t}\n\n\t\tmaxAge := cfg.MaxAge\n\t\tif maxAge > 0 {\n\t\t\tsf.cacheControlValue = \"public, max-age=\" + strconv.Itoa(maxAge)\n\t\t}\n\n\t\t// set vars\n\t\tfsHandler = sf.handler\n\t\tcacheControlValue = sf.cacheControlValue\n\n\t\tc.app.sendfilesMutex.Lock()\n\t\tc.app.sendfiles = append(c.app.sendfiles, sf)\n\t\tc.app.sendfilesMutex.Unlock()\n\t}\n\n\t// Keep original path for mutable params\n\tc.pathOriginal = utils.CopyString(c.pathOriginal)\n\n\t// Delete the Accept-Encoding header if compression is disabled\n\tif !cfg.Compress {\n\t\t// https://github.com/valyala/fasthttp/blob/7cc6f4c513f9e0d3686142e0a1a5aa2f76b3194a/fs.go#L55\n\t\tc.fasthttp.Request.Header.Del(HeaderAcceptEncoding)\n\t}\n\n\t// copy of https://github.com/valyala/fasthttp/blob/7cc6f4c513f9e0d3686142e0a1a5aa2f76b3194a/fs.go#L103-L121 with small adjustments\n\tif len(file) == 0 || (!filepath.IsAbs(file) && cfg.FS == nil) {\n\t\t// extend relative path to absolute path\n\t\thasTrailingSlash := len(file) > 0 && (file[len(file)-1] == '/' || file[len(file)-1] == '\\\\')\n\n\t\tvar err error\n\t\tfile = filepath.FromSlash(file)\n\t\tif file, err = filepath.Abs(file); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine abs file path: %w\", err)\n\t\t}\n\t\tif hasTrailingSlash {\n\t\t\tfile += \"/\"\n\t\t}\n\t}\n\n\t// convert the path to forward slashes regardless the OS in order to set the URI properly\n\t// the handler will convert back to OS path separator before opening the file\n\tfile = filepath.ToSlash(file)\n\n\t// Restore the original requested URL\n\toriginalURL := utils.CopyString(c.OriginalURL())\n\tdefer c.fasthttp.Request.SetRequestURI(originalURL)\n\n\t// Set new URI for fileHandler\n\tc.fasthttp.Request.SetRequestURI(file)\n\n\t// Save status code\n\tstatus := c.fasthttp.Response.StatusCode()\n\n\t// Serve file\n\tfsHandler(c.fasthttp)\n\n\t// Sets the response Content-Disposition header to attachment if the Download option is true\n\tif cfg.Download {\n\t\tc.Attachment()\n\t}\n\n\t// Get the status code which is set by fasthttp\n\tfsStatus := c.fasthttp.Response.StatusCode()\n\n\t// Check for error\n\tif status != StatusNotFound && fsStatus == StatusNotFound {\n\t\treturn NewError(StatusNotFound, fmt.Sprintf(\"sendfile: file %s not found\", filename))\n\t}\n\n\t// Set the status code set by the user if it is different from the fasthttp status code and 200\n\tif status != fsStatus && status != StatusOK {\n\t\tc.Status(status)\n\t}\n\n\t// Apply cache control header\n\tif status != StatusNotFound && status != StatusForbidden {\n\t\tif len(cacheControlValue) > 0 {\n\t\t\tc.RequestCtx().Response.Header.Set(HeaderCacheControl, cacheControlValue)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// SendStatus sets the HTTP status code and if the response body is empty,\n// it sets the correct status message in the body.\nfunc (c *DefaultCtx) SendStatus(status int) error {\n\tc.Status(status)\n\n\t// Only set status body when there is no response body\n\tif len(c.fasthttp.Response.Body()) == 0 {\n\t\treturn c.SendString(utils.StatusMessage(status))\n\t}\n\n\treturn nil\n}\n\n// SendString sets the HTTP response body for string types.\n// This means no type assertion, recommended for faster performance\nfunc (c *DefaultCtx) SendString(body string) error {\n\tc.fasthttp.Response.SetBodyString(body)\n\n\treturn nil\n}\n\n// SendStream sets response body stream and optional body size.\nfunc (c *DefaultCtx) SendStream(stream io.Reader, size ...int) error {\n\tif len(size) > 0 && size[0] >= 0 {\n\t\tc.fasthttp.Response.SetBodyStream(stream, size[0])\n\t} else {\n\t\tc.fasthttp.Response.SetBodyStream(stream, -1)\n\t}\n\n\treturn nil\n}\n\n// SendStreamWriter sets response body stream writer\nfunc (c *DefaultCtx) SendStreamWriter(streamWriter func(*bufio.Writer)) error {\n\tc.fasthttp.Response.SetBodyStreamWriter(fasthttp.StreamWriter(streamWriter))\n\n\treturn nil\n}\n\n// Set sets the response's HTTP header field to the specified key, value.\nfunc (c *DefaultCtx) Set(key, val string) {\n\tc.fasthttp.Response.Header.Set(key, val)\n}\n\nfunc (c *DefaultCtx) setCanonical(key, val string) {\n\tc.fasthttp.Response.Header.SetCanonical(utils.UnsafeBytes(key), utils.UnsafeBytes(val))\n}\n\n// Subdomains returns a string slice of subdomains in the domain name of the request.\n// The subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments.\nfunc (c *DefaultCtx) Subdomains(offset ...int) []string {\n\to := 2\n\tif len(offset) > 0 {\n\t\to = offset[0]\n\t}\n\tsubdomains := strings.Split(c.Host(), \".\")\n\tl := len(subdomains) - o\n\t// Check index to avoid slice bounds out of range panic\n\tif l < 0 {\n\t\tl = len(subdomains)\n\t}\n\tsubdomains = subdomains[:l]\n\treturn subdomains\n}\n\n// Stale is not implemented yet, pull requests are welcome!\nfunc (c *DefaultCtx) Stale() bool {\n\treturn !c.Fresh()\n}\n\n// Status sets the HTTP status for the response.\n// This method is chainable.\nfunc (c *DefaultCtx) Status(status int) Ctx {\n\tc.fasthttp.Response.SetStatusCode(status)\n\treturn c\n}\n\n// String returns unique string representation of the ctx.\n//\n// The returned value may be useful for logging.\nfunc (c *DefaultCtx) String() string {\n\t// Get buffer from pool\n\tbuf := bytebufferpool.Get()\n\n\t// Start with the ID, converting it to a hex string without fmt.Sprintf\n\tbuf.WriteByte('#')\n\t// Convert ID to hexadecimal\n\tid := strconv.FormatUint(c.fasthttp.ID(), 16)\n\t// Pad with leading zeros to ensure 16 characters\n\tfor i := 0; i < (16 - len(id)); i++ {\n\t\tbuf.WriteByte('0')\n\t}\n\tbuf.WriteString(id)\n\tbuf.WriteString(\" - \")\n\n\t// Add local and remote addresses directly\n\tbuf.WriteString(c.fasthttp.LocalAddr().String())\n\tbuf.WriteString(\" <-> \")\n\tbuf.WriteString(c.fasthttp.RemoteAddr().String())\n\tbuf.WriteString(\" - \")\n\n\t// Add method and URI\n\tbuf.Write(c.fasthttp.Request.Header.Method())\n\tbuf.WriteByte(' ')\n\tbuf.Write(c.fasthttp.URI().FullURI())\n\n\t// Allocate string\n\tstr := buf.String()\n\n\t// Reset buffer\n\tbuf.Reset()\n\tbytebufferpool.Put(buf)\n\n\treturn str\n}\n\n// Type sets the Content-Type HTTP header to the MIME type specified by the file extension.\nfunc (c *DefaultCtx) Type(extension string, charset ...string) Ctx {\n\tif len(charset) > 0 {\n\t\tc.fasthttp.Response.Header.SetContentType(utils.GetMIME(extension) + \"; charset=\" + charset[0])\n\t} else {\n\t\tc.fasthttp.Response.Header.SetContentType(utils.GetMIME(extension))\n\t}\n\treturn c\n}\n\n// Vary adds the given header field to the Vary response header.\n// This will append the header, if not already listed, otherwise leaves it listed in the current location.\nfunc (c *DefaultCtx) Vary(fields ...string) {\n\tc.Append(HeaderVary, fields...)\n}\n\n// Write appends p into response body.\nfunc (c *DefaultCtx) Write(p []byte) (int, error) {\n\tc.fasthttp.Response.AppendBody(p)\n\treturn len(p), nil\n}\n\n// Writef appends f & a into response body writer.\nfunc (c *DefaultCtx) Writef(f string, a ...any) (int, error) {\n\t//nolint:wrapcheck // This must not be wrapped\n\treturn fmt.Fprintf(c.fasthttp.Response.BodyWriter(), f, a...)\n}\n\n// WriteString appends s to response body.\nfunc (c *DefaultCtx) WriteString(s string) (int, error) {\n\tc.fasthttp.Response.AppendBodyString(s)\n\treturn len(s), nil\n}\n\n// XHR returns a Boolean property, that is true, if the request's X-Requested-With header field is XMLHttpRequest,\n// indicating that the request was issued by a client library (such as jQuery).\nfunc (c *DefaultCtx) XHR() bool {\n\treturn utils.EqualFold(c.app.getBytes(c.Get(HeaderXRequestedWith)), []byte(\"xmlhttprequest\"))\n}\n\n// configDependentPaths set paths for route recognition and prepared paths for the user,\n// here the features for caseSensitive, decoded paths, strict paths are evaluated\nfunc (c *DefaultCtx) configDependentPaths() {\n\tc.pathBuffer = append(c.pathBuffer[0:0], c.pathOriginal...)\n\t// If UnescapePath enabled, we decode the path and save it for the framework user\n\tif c.app.config.UnescapePath {\n\t\tc.pathBuffer = fasthttp.AppendUnquotedArg(c.pathBuffer[:0], c.pathBuffer)\n\t}\n\tc.path = c.app.getString(c.pathBuffer)\n\n\t// another path is specified which is for routing recognition only\n\t// use the path that was changed by the previous configuration flags\n\tc.detectionPathBuffer = append(c.detectionPathBuffer[0:0], c.pathBuffer...)\n\t// If CaseSensitive is disabled, we lowercase the original path\n\tif !c.app.config.CaseSensitive {\n\t\tc.detectionPathBuffer = utils.ToLowerBytes(c.detectionPathBuffer)\n\t}\n\t// If StrictRouting is disabled, we strip all trailing slashes\n\tif !c.app.config.StrictRouting && len(c.detectionPathBuffer) > 1 && c.detectionPathBuffer[len(c.detectionPathBuffer)-1] == '/' {\n\t\tc.detectionPathBuffer = utils.TrimRight(c.detectionPathBuffer, '/')\n\t}\n\tc.detectionPath = c.app.getString(c.detectionPathBuffer)\n\n\t// Define the path for dividing routes into areas for fast tree detection, so that fewer routes need to be traversed,\n\t// since the first three characters area select a list of routes\n\tc.treePath = c.treePath[0:0]\n\tconst maxDetectionPaths = 3\n\tif len(c.detectionPath) >= maxDetectionPaths {\n\t\tc.treePath = c.detectionPath[:maxDetectionPaths]\n\t}\n}\n\n// IsProxyTrusted checks trustworthiness of remote ip.\n// If Config.TrustProxy false, it returns true\n// IsProxyTrusted can check remote ip by proxy ranges and ip map.\nfunc (c *DefaultCtx) IsProxyTrusted() bool {\n\tif !c.app.config.TrustProxy {\n\t\treturn true\n\t}\n\n\tip := c.fasthttp.RemoteIP()\n\n\tif (c.app.config.TrustProxyConfig.Loopback && ip.IsLoopback()) ||\n\t\t(c.app.config.TrustProxyConfig.Private && ip.IsPrivate()) ||\n\t\t(c.app.config.TrustProxyConfig.LinkLocal && ip.IsLinkLocalUnicast()) {\n\t\treturn true\n\t}\n\n\tif _, trusted := c.app.config.TrustProxyConfig.ips[ip.String()]; trusted {\n\t\treturn true\n\t}\n\n\tfor _, ipNet := range c.app.config.TrustProxyConfig.ranges {\n\t\tif ipNet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// IsFromLocal will return true if request came from local.\nfunc (c *DefaultCtx) IsFromLocal() bool {\n\treturn c.fasthttp.RemoteIP().IsLoopback()\n}\n\n// Bind You can bind body, cookie, headers etc. into the map, map slice, struct easily by using Binding method.\n// It gives custom binding support, detailed binding options and more.\n// Replacement of: BodyParser, ParamsParser, GetReqHeaders, GetRespHeaders, AllParams, QueryParser, ReqHeaderParser\nfunc (c *DefaultCtx) Bind() *Bind {\n\tif c.bind == nil {\n\t\tc.bind = &Bind{\n\t\t\tctx:            c,\n\t\t\tdontHandleErrs: true,\n\t\t}\n\t}\n\treturn c.bind\n}\n\n// Reset is a method to reset context fields by given request when to use server handlers.\nfunc (c *DefaultCtx) Reset(fctx *fasthttp.RequestCtx) {\n\t// Reset route and handler index\n\tc.indexRoute = -1\n\tc.indexHandler = 0\n\t// Reset matched flag\n\tc.matched = false\n\t// Set paths\n\tc.pathOriginal = c.app.getString(fctx.URI().PathOriginal())\n\t// Set method\n\tc.method = c.app.getString(fctx.Request.Header.Method())\n\tc.methodINT = c.app.methodInt(c.method)\n\t// Attach *fasthttp.RequestCtx to ctx\n\tc.fasthttp = fctx\n\t// reset base uri\n\tc.baseURI = \"\"\n\t// Prettify path\n\tc.configDependentPaths()\n}\n\n// Release is a method to reset context fields when to use ReleaseCtx()\nfunc (c *DefaultCtx) release() {\n\tc.route = nil\n\tc.fasthttp = nil\n\tc.bind = nil\n\tc.flashMessages = c.flashMessages[:0]\n\tc.viewBindMap = sync.Map{}\n\tif c.redirect != nil {\n\t\tReleaseRedirect(c.redirect)\n\t\tc.redirect = nil\n\t}\n}\n\nfunc (c *DefaultCtx) getBody() []byte {\n\tif c.app.config.Immutable {\n\t\treturn utils.CopyBytes(c.fasthttp.Request.Body())\n\t}\n\n\treturn c.fasthttp.Request.Body()\n}\n\n// Methods to use with next stack.\nfunc (c *DefaultCtx) getMethodINT() int {\n\treturn c.methodINT\n}\n\nfunc (c *DefaultCtx) getIndexRoute() int {\n\treturn c.indexRoute\n}\n\nfunc (c *DefaultCtx) getTreePath() string {\n\treturn c.treePath\n}\n\nfunc (c *DefaultCtx) getDetectionPath() string {\n\treturn c.detectionPath\n}\n\nfunc (c *DefaultCtx) getPathOriginal() string {\n\treturn c.pathOriginal\n}\n\nfunc (c *DefaultCtx) getValues() *[maxParams]string {\n\treturn &c.values\n}\n\nfunc (c *DefaultCtx) getMatched() bool {\n\treturn c.matched\n}\n\nfunc (c *DefaultCtx) setIndexHandler(handler int) {\n\tc.indexHandler = handler\n}\n\nfunc (c *DefaultCtx) setIndexRoute(route int) {\n\tc.indexRoute = route\n}\n\nfunc (c *DefaultCtx) setMatched(matched bool) {\n\tc.matched = matched\n}\n\nfunc (c *DefaultCtx) setRoute(route *Route) {\n\tc.route = route\n}\n\n// Drop closes the underlying connection without sending any response headers or body.\n// This can be useful for silently terminating client connections, such as in DDoS mitigation\n// or when blocking access to sensitive endpoints.\nfunc (c *DefaultCtx) Drop() error {\n\t//nolint:wrapcheck // error wrapping is avoided to keep the operation lightweight and focused on connection closure.\n\treturn c.RequestCtx().Conn().Close()\n}\n"
        },
        {
          "name": "ctx_interface.go",
          "type": "blob",
          "size": 1.33,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"errors\"\n\n\t\"github.com/valyala/fasthttp\"\n)\n\ntype CustomCtx interface {\n\tCtx\n\n\t// Reset is a method to reset context fields by given request when to use server handlers.\n\tReset(fctx *fasthttp.RequestCtx)\n\n\t// Methods to use with next stack.\n\tgetMethodINT() int\n\tgetIndexRoute() int\n\tgetTreePath() string\n\tgetDetectionPath() string\n\tgetPathOriginal() string\n\tgetValues() *[maxParams]string\n\tgetMatched() bool\n\tsetIndexHandler(handler int)\n\tsetIndexRoute(route int)\n\tsetMatched(matched bool)\n\tsetRoute(route *Route)\n}\n\nfunc NewDefaultCtx(app *App) *DefaultCtx {\n\t// return ctx\n\treturn &DefaultCtx{\n\t\t// Set app reference\n\t\tapp: app,\n\t}\n}\n\nfunc (app *App) newCtx() Ctx {\n\tvar c Ctx\n\n\tif app.newCtxFunc != nil {\n\t\tc = app.newCtxFunc(app)\n\t} else {\n\t\tc = NewDefaultCtx(app)\n\t}\n\n\treturn c\n}\n\n// AcquireCtx retrieves a new Ctx from the pool.\nfunc (app *App) AcquireCtx(fctx *fasthttp.RequestCtx) Ctx {\n\tctx, ok := app.pool.Get().(Ctx)\n\n\tif !ok {\n\t\tpanic(errors.New(\"failed to type-assert to Ctx\"))\n\t}\n\tctx.Reset(fctx)\n\n\treturn ctx\n}\n\n// ReleaseCtx releases the ctx back into the pool.\nfunc (app *App) ReleaseCtx(c Ctx) {\n\tc.release()\n\tapp.pool.Put(c)\n}\n"
        },
        {
          "name": "ctx_interface_gen.go",
          "type": "blob",
          "size": 19.4,
          "content": "// Code generated by ifacemaker; DO NOT EDIT.\n\npackage fiber\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"mime/multipart\"\n\n\t\"github.com/valyala/fasthttp\"\n)\n\n// Ctx represents the Context which hold the HTTP request and response.\\nIt has methods for the request query string, parameters, body, HTTP headers and so on.\ntype Ctx interface {\n\t// Accepts checks if the specified extensions or content types are acceptable.\n\tAccepts(offers ...string) string\n\t// AcceptsCharsets checks if the specified charset is acceptable.\n\tAcceptsCharsets(offers ...string) string\n\t// AcceptsEncodings checks if the specified encoding is acceptable.\n\tAcceptsEncodings(offers ...string) string\n\t// AcceptsLanguages checks if the specified language is acceptable.\n\tAcceptsLanguages(offers ...string) string\n\t// App returns the *App reference to the instance of the Fiber application\n\tApp() *App\n\t// Append the specified value to the HTTP response header field.\n\t// If the header is not already set, it creates the header with the specified value.\n\tAppend(field string, values ...string)\n\t// Attachment sets the HTTP response Content-Disposition header field to attachment.\n\tAttachment(filename ...string)\n\t// BaseURL returns (protocol + host + base path).\n\tBaseURL() string\n\t// BodyRaw contains the raw body submitted in a POST request.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting instead.\n\tBodyRaw() []byte\n\ttryDecodeBodyInOrder(originalBody *[]byte, encodings []string) ([]byte, uint8, error)\n\t// Body contains the raw body submitted in a POST request.\n\t// This method will decompress the body if the 'Content-Encoding' header is provided.\n\t// It returns the original (or decompressed) body data which is valid only within the handler.\n\t// Don't store direct references to the returned data.\n\t// If you need to keep the body's data later, make a copy or use the Immutable option.\n\tBody() []byte\n\t// ClearCookie expires a specific cookie by key on the client side.\n\t// If no key is provided it expires all cookies that came with the request.\n\tClearCookie(key ...string)\n\t// RequestCtx returns *fasthttp.RequestCtx that carries a deadline\n\t// a cancellation signal, and other values across API boundaries.\n\tRequestCtx() *fasthttp.RequestCtx\n\t// Context returns a context implementation that was set by\n\t// user earlier or returns a non-nil, empty context,if it was not set earlier.\n\tContext() context.Context\n\t// SetContext sets a context implementation by user.\n\tSetContext(ctx context.Context)\n\t// Cookie sets a cookie by passing a cookie struct.\n\tCookie(cookie *Cookie)\n\t// Cookies are used for getting a cookie value by key.\n\t// Defaults to the empty string \"\" if the cookie doesn't exist.\n\t// If a default value is given, it will return that value if the cookie doesn't exist.\n\t// The returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting to use the value outside the Handler.\n\tCookies(key string, defaultValue ...string) string\n\t// Download transfers the file from path as an attachment.\n\t// Typically, browsers will prompt the user for download.\n\t// By default, the Content-Disposition header filename= parameter is the filepath (this typically appears in the browser dialog).\n\t// Override this default with the filename parameter.\n\tDownload(file string, filename ...string) error\n\t// Request return the *fasthttp.Request object\n\t// This allows you to use all fasthttp request methods\n\t// https://godoc.org/github.com/valyala/fasthttp#Request\n\tRequest() *fasthttp.Request\n\t// Response return the *fasthttp.Response object\n\t// This allows you to use all fasthttp response methods\n\t// https://godoc.org/github.com/valyala/fasthttp#Response\n\tResponse() *fasthttp.Response\n\t// Format performs content-negotiation on the Accept HTTP header.\n\t// It uses Accepts to select a proper format and calls the matching\n\t// user-provided handler function.\n\t// If no accepted format is found, and a format with MediaType \"default\" is given,\n\t// that default handler is called. If no format is found and no default is given,\n\t// StatusNotAcceptable is sent.\n\tFormat(handlers ...ResFmt) error\n\t// AutoFormat performs content-negotiation on the Accept HTTP header.\n\t// It uses Accepts to select a proper format.\n\t// The supported content types are text/html, text/plain, application/json, and application/xml.\n\t// For more flexible content negotiation, use Format.\n\t// If the header is not specified or there is no proper format, text/plain is used.\n\tAutoFormat(body any) error\n\t// FormFile returns the first file by key from a MultipartForm.\n\tFormFile(key string) (*multipart.FileHeader, error)\n\t// FormValue returns the first value by key from a MultipartForm.\n\t// Search is performed in QueryArgs, PostArgs, MultipartForm and FormFile in this particular order.\n\t// Defaults to the empty string \"\" if the form value doesn't exist.\n\t// If a default value is given, it will return that value if the form value does not exist.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting instead.\n\tFormValue(key string, defaultValue ...string) string\n\t// Fresh returns true when the response is still “fresh” in the client's cache,\n\t// otherwise false is returned to indicate that the client cache is now stale\n\t// and the full response should be sent.\n\t// When a client sends the Cache-Control: no-cache request header to indicate an end-to-end\n\t// reload request, this module will return false to make handling these requests transparent.\n\t// https://github.com/jshttp/fresh/blob/10e0471669dbbfbfd8de65bc6efac2ddd0bfa057/index.js#L33\n\tFresh() bool\n\t// Get returns the HTTP request header specified by field.\n\t// Field names are case-insensitive\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting instead.\n\tGet(key string, defaultValue ...string) string\n\t// GetRespHeader returns the HTTP response header specified by field.\n\t// Field names are case-insensitive\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting instead.\n\tGetRespHeader(key string, defaultValue ...string) string\n\t// GetRespHeaders returns the HTTP response headers.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting instead.\n\tGetRespHeaders() map[string][]string\n\t// GetReqHeaders returns the HTTP request headers.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting instead.\n\tGetReqHeaders() map[string][]string\n\t// Host contains the host derived from the X-Forwarded-Host or Host HTTP header.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// In a network context, `Host` refers to the combination of a hostname and potentially a port number used for connecting,\n\t// while `Hostname` refers specifically to the name assigned to a device on a network, excluding any port information.\n\t// Example: URL: https://example.com:8080 -> Host: example.com:8080\n\t// Make copies or use the Immutable setting instead.\n\t// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\n\tHost() string\n\t// Hostname contains the hostname derived from the X-Forwarded-Host or Host HTTP header using the c.Host() method.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Example: URL: https://example.com:8080 -> Hostname: example.com\n\t// Make copies or use the Immutable setting instead.\n\t// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\n\tHostname() string\n\t// Port returns the remote port of the request.\n\tPort() string\n\t// IP returns the remote IP address of the request.\n\t// If ProxyHeader and IP Validation is configured, it will parse that header and return the first valid IP address.\n\t// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\n\tIP() string\n\t// extractIPsFromHeader will return a slice of IPs it found given a header name in the order they appear.\n\t// When IP validation is enabled, any invalid IPs will be omitted.\n\textractIPsFromHeader(header string) []string\n\t// extractIPFromHeader will attempt to pull the real client IP from the given header when IP validation is enabled.\n\t// currently, it will return the first valid IP address in header.\n\t// when IP validation is disabled, it will simply return the value of the header without any inspection.\n\t// Implementation is almost the same as in extractIPsFromHeader, but without allocation of []string.\n\textractIPFromHeader(header string) string\n\t// IPs returns a string slice of IP addresses specified in the X-Forwarded-For request header.\n\t// When IP validation is enabled, only valid IPs are returned.\n\tIPs() []string\n\t// Is returns the matching content type,\n\t// if the incoming request's Content-Type HTTP header field matches the MIME type specified by the type parameter\n\tIs(extension string) bool\n\t// JSON converts any interface or string to JSON.\n\t// Array and slice values encode as JSON arrays,\n\t// except that []byte encodes as a base64-encoded string,\n\t// and a nil slice encodes as the null JSON value.\n\t// If the ctype parameter is given, this method will set the\n\t// Content-Type header equal to ctype. If ctype is not given,\n\t// The Content-Type header will be set to application/json.\n\tJSON(data any, ctype ...string) error\n\t// CBOR converts any interface or string to CBOR encoded bytes.\n\t// If the ctype parameter is given, this method will set the\n\t// Content-Type header equal to ctype. If ctype is not given,\n\t// The Content-Type header will be set to application/cbor.\n\tCBOR(data any, ctype ...string) error\n\t// JSONP sends a JSON response with JSONP support.\n\t// This method is identical to JSON, except that it opts-in to JSONP callback support.\n\t// By default, the callback name is simply callback.\n\tJSONP(data any, callback ...string) error\n\t// XML converts any interface or string to XML.\n\t// This method also sets the content header to application/xml.\n\tXML(data any) error\n\t// Links joins the links followed by the property to populate the response's Link HTTP header field.\n\tLinks(link ...string)\n\t// Locals makes it possible to pass any values under keys scoped to the request\n\t// and therefore available to all following routes that match the request.\n\t//\n\t// All the values are removed from ctx after returning from the top\n\t// RequestHandler. Additionally, Close method is called on each value\n\t// implementing io.Closer before removing the value from ctx.\n\tLocals(key any, value ...any) any\n\t// Location sets the response Location HTTP header to the specified path parameter.\n\tLocation(path string)\n\t// Method returns the HTTP request method for the context, optionally overridden by the provided argument.\n\t// If no override is given or if the provided override is not a valid HTTP method, it returns the current method from the context.\n\t// Otherwise, it updates the context's method and returns the overridden method as a string.\n\tMethod(override ...string) string\n\t// MultipartForm parse form entries from binary.\n\t// This returns a map[string][]string, so given a key the value will be a string slice.\n\tMultipartForm() (*multipart.Form, error)\n\t// ClientHelloInfo return CHI from context\n\tClientHelloInfo() *tls.ClientHelloInfo\n\t// Next executes the next method in the stack that matches the current route.\n\tNext() error\n\t// RestartRouting instead of going to the next handler. This may be useful after\n\t// changing the request path. Note that handlers might be executed again.\n\tRestartRouting() error\n\t// OriginalURL contains the original request URL.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting to use the value outside the Handler.\n\tOriginalURL() string\n\t// Params is used to get the route parameters.\n\t// Defaults to empty string \"\" if the param doesn't exist.\n\t// If a default value is given, it will return that value if the param doesn't exist.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting to use the value outside the Handler.\n\tParams(key string, defaultValue ...string) string\n\t// Path returns the path part of the request URL.\n\t// Optionally, you could override the path.\n\tPath(override ...string) string\n\t// Scheme contains the request protocol string: http or https for TLS requests.\n\t// Please use Config.TrustProxy to prevent header spoofing, in case when your app is behind the proxy.\n\tScheme() string\n\t// Protocol returns the HTTP protocol of request: HTTP/1.1 and HTTP/2.\n\tProtocol() string\n\t// Query returns the query string parameter in the url.\n\t// Defaults to empty string \"\" if the query doesn't exist.\n\t// If a default value is given, it will return that value if the query doesn't exist.\n\t// Returned value is only valid within the handler. Do not store any references.\n\t// Make copies or use the Immutable setting to use the value outside the Handler.\n\tQuery(key string, defaultValue ...string) string\n\t// Queries returns a map of query parameters and their values.\n\t//\n\t// GET /?name=alex&wanna_cake=2&id=\n\t// Queries()[\"name\"] == \"alex\"\n\t// Queries()[\"wanna_cake\"] == \"2\"\n\t// Queries()[\"id\"] == \"\"\n\t//\n\t// GET /?field1=value1&field1=value2&field2=value3\n\t// Queries()[\"field1\"] == \"value2\"\n\t// Queries()[\"field2\"] == \"value3\"\n\t//\n\t// GET /?list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\n\t// Queries()[\"list_a\"] == \"3\"\n\t// Queries()[\"list_b[]\"] == \"3\"\n\t// Queries()[\"list_c\"] == \"1,2,3\"\n\t//\n\t// GET /api/search?filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\n\t// Queries()[\"filters.author.name\"] == \"John\"\n\t// Queries()[\"filters.category.name\"] == \"Technology\"\n\t// Queries()[\"filters[customer][name]\"] == \"Alice\"\n\t// Queries()[\"filters[status]\"] == \"pending\"\n\tQueries() map[string]string\n\t// Range returns a struct containing the type and a slice of ranges.\n\tRange(size int) (Range, error)\n\t// Redirect returns the Redirect reference.\n\t// Use Redirect().Status() to set custom redirection status code.\n\t// If status is not specified, status defaults to 302 Found.\n\t// You can use Redirect().To(), Redirect().Route() and Redirect().Back() for redirection.\n\tRedirect() *Redirect\n\t// ViewBind Add vars to default view var map binding to template engine.\n\t// Variables are read by the Render method and may be overwritten.\n\tViewBind(vars Map) error\n\t// getLocationFromRoute get URL location from route using parameters\n\tgetLocationFromRoute(route Route, params Map) (string, error)\n\t// GetRouteURL generates URLs to named routes, with parameters. URLs are relative, for example: \"/user/1831\"\n\tGetRouteURL(routeName string, params Map) (string, error)\n\t// Render a template with data and sends a text/html response.\n\t// We support the following engines: https://github.com/gofiber/template\n\tRender(name string, bind any, layouts ...string) error\n\trenderExtensions(bind any)\n\t// Route returns the matched Route struct.\n\tRoute() *Route\n\t// SaveFile saves any multipart file to disk.\n\tSaveFile(fileheader *multipart.FileHeader, path string) error\n\t// SaveFileToStorage saves any multipart file to an external storage system.\n\tSaveFileToStorage(fileheader *multipart.FileHeader, path string, storage Storage) error\n\t// Secure returns whether a secure connection was established.\n\tSecure() bool\n\t// Send sets the HTTP response body without copying it.\n\t// From this point onward the body argument must not be changed.\n\tSend(body []byte) error\n\t// SendFile transfers the file from the specified path.\n\t// By default, the file is not compressed. To enable compression, set SendFile.Compress to true.\n\t// The Content-Type response HTTP header field is set based on the file's extension.\n\t// If the file extension is missing or invalid, the Content-Type is detected from the file's format.\n\tSendFile(file string, config ...SendFile) error\n\t// SendStatus sets the HTTP status code and if the response body is empty,\n\t// it sets the correct status message in the body.\n\tSendStatus(status int) error\n\t// SendString sets the HTTP response body for string types.\n\t// This means no type assertion, recommended for faster performance\n\tSendString(body string) error\n\t// SendStream sets response body stream and optional body size.\n\tSendStream(stream io.Reader, size ...int) error\n\t// SendStreamWriter sets response body stream writer\n\tSendStreamWriter(streamWriter func(*bufio.Writer)) error\n\t// Set sets the response's HTTP header field to the specified key, value.\n\tSet(key, val string)\n\tsetCanonical(key, val string)\n\t// Subdomains returns a string slice of subdomains in the domain name of the request.\n\t// The subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments.\n\tSubdomains(offset ...int) []string\n\t// Stale is not implemented yet, pull requests are welcome!\n\tStale() bool\n\t// Status sets the HTTP status for the response.\n\t// This method is chainable.\n\tStatus(status int) Ctx\n\t// String returns unique string representation of the ctx.\n\t//\n\t// The returned value may be useful for logging.\n\tString() string\n\t// Type sets the Content-Type HTTP header to the MIME type specified by the file extension.\n\tType(extension string, charset ...string) Ctx\n\t// Vary adds the given header field to the Vary response header.\n\t// This will append the header, if not already listed, otherwise leaves it listed in the current location.\n\tVary(fields ...string)\n\t// Write appends p into response body.\n\tWrite(p []byte) (int, error)\n\t// Writef appends f & a into response body writer.\n\tWritef(f string, a ...any) (int, error)\n\t// WriteString appends s to response body.\n\tWriteString(s string) (int, error)\n\t// XHR returns a Boolean property, that is true, if the request's X-Requested-With header field is XMLHttpRequest,\n\t// indicating that the request was issued by a client library (such as jQuery).\n\tXHR() bool\n\t// configDependentPaths set paths for route recognition and prepared paths for the user,\n\t// here the features for caseSensitive, decoded paths, strict paths are evaluated\n\tconfigDependentPaths()\n\t// IsProxyTrusted checks trustworthiness of remote ip.\n\t// If Config.TrustProxy false, it returns true\n\t// IsProxyTrusted can check remote ip by proxy ranges and ip map.\n\tIsProxyTrusted() bool\n\t// IsFromLocal will return true if request came from local.\n\tIsFromLocal() bool\n\t// Bind You can bind body, cookie, headers etc. into the map, map slice, struct easily by using Binding method.\n\t// It gives custom binding support, detailed binding options and more.\n\t// Replacement of: BodyParser, ParamsParser, GetReqHeaders, GetRespHeaders, AllParams, QueryParser, ReqHeaderParser\n\tBind() *Bind\n\t// Reset is a method to reset context fields by given request when to use server handlers.\n\tReset(fctx *fasthttp.RequestCtx)\n\t// Release is a method to reset context fields when to use ReleaseCtx()\n\trelease()\n\tgetBody() []byte\n\t// Methods to use with next stack.\n\tgetMethodINT() int\n\tgetIndexRoute() int\n\tgetTreePath() string\n\tgetDetectionPath() string\n\tgetPathOriginal() string\n\tgetValues() *[maxParams]string\n\tgetMatched() bool\n\tsetIndexHandler(handler int)\n\tsetIndexRoute(route int)\n\tsetMatched(matched bool)\n\tsetRoute(route *Route)\n\t// Drop closes the underlying connection without sending any response headers or body.\n\t// This can be useful for silently terminating client connections, such as in DDoS mitigation\n\t// or when blocking access to sensitive endpoints.\n\tDrop() error\n}\n"
        },
        {
          "name": "ctx_test.go",
          "type": "blob",
          "size": 181.26,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"embed\"\n\t\"encoding/hex\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v3/internal/storage/memory\"\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nconst epsilon = 0.001\n\n// go test -run Test_Ctx_Accepts\nfunc Test_Ctx_Accepts(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAccept, \"text/html,application/xhtml+xml,application/xml;q=0.9\")\n\trequire.Equal(t, \"\", c.Accepts(\"\"))\n\trequire.Equal(t, \"\", c.Accepts())\n\trequire.Equal(t, \".xml\", c.Accepts(\".xml\"))\n\trequire.Equal(t, \"\", c.Accepts(\".john\"))\n\trequire.Equal(t, \"application/xhtml+xml\", c.Accepts(\"application/xml\", \"application/xml+rss\", \"application/yaml\", \"application/xhtml+xml\"), \"must use client-preferred mime type\")\n\n\tc.Request().Header.Set(HeaderAccept, \"application/json, text/plain, */*;q=0\")\n\trequire.Equal(t, \"\", c.Accepts(\"html\"), \"must treat */*;q=0 as not acceptable\")\n\n\tc.Request().Header.Set(HeaderAccept, \"text/*, application/json\")\n\trequire.Equal(t, \"html\", c.Accepts(\"html\"))\n\trequire.Equal(t, \"text/html\", c.Accepts(\"text/html\"))\n\trequire.Equal(t, \"json\", c.Accepts(\"json\", \"text\"))\n\trequire.Equal(t, \"application/json\", c.Accepts(\"application/json\"))\n\trequire.Equal(t, \"\", c.Accepts(\"image/png\"))\n\trequire.Equal(t, \"\", c.Accepts(\"png\"))\n\n\tc.Request().Header.Set(HeaderAccept, \"text/html, application/json\")\n\trequire.Equal(t, \"text/*\", c.Accepts(\"text/*\"))\n\n\tc.Request().Header.Set(HeaderAccept, \"*/*\")\n\trequire.Equal(t, \"html\", c.Accepts(\"html\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Accepts -benchmem -count=4\nfunc Benchmark_Ctx_Accepts(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tacceptHeader := \"text/html,application/xhtml+xml,application/xml;q=0.9\"\n\tc.Request().Header.Set(\"Accept\", acceptHeader)\n\tacceptValues := [][]string{\n\t\t{\".xml\"},\n\t\t{\"json\", \"xml\"},\n\t\t{\"application/json\", \"application/xml\"},\n\t}\n\texpectedResults := []string{\".xml\", \"xml\", \"application/xml\"}\n\n\tfor i := 0; i < len(acceptValues); i++ {\n\t\tb.Run(fmt.Sprintf(\"run-%#v\", acceptValues[i]), func(bb *testing.B) {\n\t\t\tvar res string\n\t\t\tbb.ReportAllocs()\n\t\t\tbb.ResetTimer()\n\n\t\t\tfor n := 0; n < bb.N; n++ {\n\t\t\t\tres = c.Accepts(acceptValues[i]...)\n\t\t\t}\n\t\t\trequire.Equal(bb, expectedResults[i], res)\n\t\t})\n\t}\n}\n\ntype customCtx struct {\n\tDefaultCtx\n}\n\nfunc (c *customCtx) Params(key string, defaultValue ...string) string { //revive:disable-line:unused-parameter // We need defaultValue for some cases\n\treturn \"prefix_\" + c.DefaultCtx.Params(key)\n}\n\n// go test -run Test_Ctx_CustomCtx\nfunc Test_Ctx_CustomCtx(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.NewCtxFunc(func(app *App) CustomCtx {\n\t\treturn &customCtx{\n\t\t\tDefaultCtx: *NewDefaultCtx(app),\n\t\t}\n\t})\n\n\tapp.Get(\"/:id\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"id\"))\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/v3\", &bytes.Buffer{}))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"io.ReadAll(resp.Body)\")\n\trequire.Equal(t, \"prefix_v3\", string(body))\n}\n\n// go test -run Test_Ctx_CustomCtx\nfunc Test_Ctx_CustomCtx_and_Method(t *testing.T) {\n\tt.Parallel()\n\n\t// Create app with custom request methods\n\tmethods := append(DefaultMethods, \"JOHN\") //nolint:gocritic // We want a new slice here\n\tapp := New(Config{\n\t\tRequestMethods: methods,\n\t})\n\n\t// Create custom context\n\tapp.NewCtxFunc(func(app *App) CustomCtx {\n\t\treturn &customCtx{\n\t\t\tDefaultCtx: *NewDefaultCtx(app),\n\t\t}\n\t})\n\n\t// Add route with custom method\n\tapp.Add([]string{\"JOHN\"}, \"/doe\", testEmptyHandler)\n\tresp, err := app.Test(httptest.NewRequest(\"JOHN\", \"/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// Add a new method\n\trequire.Panics(t, func() {\n\t\tapp.Add([]string{\"JANE\"}, \"/jane\", testEmptyHandler)\n\t})\n}\n\n// go test -run Test_Ctx_Accepts_EmptyAccept\nfunc Test_Ctx_Accepts_EmptyAccept(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, \".forwarded\", c.Accepts(\".forwarded\"))\n}\n\n// go test -run Test_Ctx_Accepts_Wildcard\nfunc Test_Ctx_Accepts_Wildcard(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAccept, \"*/*;q=0.9\")\n\trequire.Equal(t, \"html\", c.Accepts(\"html\"))\n\trequire.Equal(t, \"foo\", c.Accepts(\"foo\"))\n\trequire.Equal(t, \".bar\", c.Accepts(\".bar\"))\n\tc.Request().Header.Set(HeaderAccept, \"text/html,application/*;q=0.9\")\n\trequire.Equal(t, \"xml\", c.Accepts(\"xml\"))\n}\n\n// go test -run Test_Ctx_AcceptsCharsets\nfunc Test_Ctx_AcceptsCharsets(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAcceptCharset, \"utf-8, iso-8859-1;q=0.5\")\n\trequire.Equal(t, \"utf-8\", c.AcceptsCharsets(\"utf-8\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsCharsets -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsCharsets(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().Header.Set(\"Accept-Charset\", \"utf-8, iso-8859-1;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsCharsets(\"utf-8\")\n\t}\n\trequire.Equal(b, \"utf-8\", res)\n}\n\n// go test -run Test_Ctx_AcceptsEncodings\nfunc Test_Ctx_AcceptsEncodings(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAcceptEncoding, \"deflate, gzip;q=1.0, *;q=0.5\")\n\trequire.Equal(t, \"gzip\", c.AcceptsEncodings(\"gzip\"))\n\trequire.Equal(t, \"abc\", c.AcceptsEncodings(\"abc\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsEncodings -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsEncodings(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().Header.Set(HeaderAcceptEncoding, \"deflate, gzip;q=1.0, *;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsEncodings(\"gzip\")\n\t}\n\trequire.Equal(b, \"gzip\", res)\n}\n\n// go test -run Test_Ctx_AcceptsLanguages\nfunc Test_Ctx_AcceptsLanguages(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAcceptLanguage, \"fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5\")\n\trequire.Equal(t, \"fr\", c.AcceptsLanguages(\"fr\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AcceptsLanguages -benchmem -count=4\nfunc Benchmark_Ctx_AcceptsLanguages(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().Header.Set(HeaderAcceptLanguage, \"fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.AcceptsLanguages(\"fr\")\n\t}\n\trequire.Equal(b, \"fr\", res)\n}\n\n// go test -run Test_Ctx_App\nfunc Test_Ctx_App(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.BodyLimit = 1000\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, 1000, c.App().config.BodyLimit)\n}\n\n// go test -run Test_Ctx_Append\nfunc Test_Ctx_Append(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Append(\"X-Test\", \"Hello\")\n\tc.Append(\"X-Test\", \"World\")\n\tc.Append(\"X-Test\", \"Hello\", \"World\")\n\t// similar value in the middle\n\tc.Append(\"X2-Test\", \"World\")\n\tc.Append(\"X2-Test\", \"XHello\")\n\tc.Append(\"X2-Test\", \"Hello\", \"World\")\n\t// similar value at the start\n\tc.Append(\"X3-Test\", \"XHello\")\n\tc.Append(\"X3-Test\", \"World\")\n\tc.Append(\"X3-Test\", \"Hello\", \"World\")\n\t// try it with multiple similar values\n\tc.Append(\"X4-Test\", \"XHello\")\n\tc.Append(\"X4-Test\", \"Hello\")\n\tc.Append(\"X4-Test\", \"HelloZ\")\n\tc.Append(\"X4-Test\", \"YHello\")\n\tc.Append(\"X4-Test\", \"Hello\")\n\tc.Append(\"X4-Test\", \"YHello\")\n\tc.Append(\"X4-Test\", \"HelloZ\")\n\tc.Append(\"X4-Test\", \"XHello\")\n\t// without append value\n\tc.Append(\"X-Custom-Header\")\n\n\trequire.Equal(t, \"Hello, World\", string(c.Response().Header.Peek(\"X-Test\")))\n\trequire.Equal(t, \"World, XHello, Hello\", string(c.Response().Header.Peek(\"X2-Test\")))\n\trequire.Equal(t, \"XHello, World, Hello\", string(c.Response().Header.Peek(\"X3-Test\")))\n\trequire.Equal(t, \"XHello, Hello, HelloZ, YHello\", string(c.Response().Header.Peek(\"X4-Test\")))\n\trequire.Equal(t, \"\", string(c.Response().Header.Peek(\"x-custom-header\")))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Append -benchmem -count=4\nfunc Benchmark_Ctx_Append(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Append(\"X-Custom-Header\", \"Hello\")\n\t\tc.Append(\"X-Custom-Header\", \"World\")\n\t\tc.Append(\"X-Custom-Header\", \"Hello\")\n\t}\n\trequire.Equal(b, \"Hello, World\", app.getString(c.Response().Header.Peek(\"X-Custom-Header\")))\n}\n\n// go test -run Test_Ctx_Attachment\nfunc Test_Ctx_Attachment(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// empty\n\tc.Attachment()\n\trequire.Equal(t, `attachment`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\t// real filename\n\tc.Attachment(\"./static/img/logo.png\")\n\trequire.Equal(t, `attachment; filename=\"logo.png\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\trequire.Equal(t, \"image/png\", string(c.Response().Header.Peek(HeaderContentType)))\n\t// check quoting\n\tc.Attachment(\"another document.pdf\\\"\\r\\nBla: \\\"fasel\")\n\trequire.Equal(t, `attachment; filename=\"another+document.pdf%22%0D%0ABla%3A+%22fasel\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Attachment -benchmem -count=4\nfunc Benchmark_Ctx_Attachment(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t// example with quote params\n\t\tc.Attachment(\"another document.pdf\\\"\\r\\nBla: \\\"fasel\")\n\t}\n\trequire.Equal(b, `attachment; filename=\"another+document.pdf%22%0D%0ABla%3A+%22fasel\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -run Test_Ctx_BaseURL\nfunc Test_Ctx_BaseURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\trequire.Equal(t, \"http://google.com\", c.BaseURL())\n\t// Check cache\n\trequire.Equal(t, \"http://google.com\", c.BaseURL())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BaseURL -benchmem\nfunc Benchmark_Ctx_BaseURL(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetHost(\"google.com:1337\")\n\tc.Request().URI().SetPath(\"/haha/oke/lol\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.BaseURL()\n\t}\n\trequire.Equal(b, \"http://google.com:1337\", res)\n}\n\n// go test -run Test_Ctx_Body\nfunc Test_Ctx_Body(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBody([]byte(\"john=doe\"))\n\trequire.Equal(t, []byte(\"john=doe\"), c.Body())\n}\n\n// go test -run Test_Ctx_BodyRaw\nfunc Test_Ctx_BodyRaw(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBodyRaw([]byte(\"john=doe\"))\n\trequire.Equal(t, []byte(\"john=doe\"), c.BodyRaw())\n}\n\n// go test -run Test_Ctx_BodyRaw_Immutable\nfunc Test_Ctx_BodyRaw_Immutable(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{Immutable: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBodyRaw([]byte(\"john=doe\"))\n\trequire.Equal(t, []byte(\"john=doe\"), c.BodyRaw())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Body -benchmem -count=4\nfunc Benchmark_Ctx_Body(b *testing.B) {\n\tconst input = \"john=doe\"\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBody([]byte(input))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.Body()\n\t}\n\n\trequire.Equal(b, []byte(input), c.Body())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyRaw -benchmem -count=4\nfunc Benchmark_Ctx_BodyRaw(b *testing.B) {\n\tconst input = \"john=doe\"\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBodyRaw([]byte(input))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.BodyRaw()\n\t}\n\n\trequire.Equal(b, []byte(input), c.BodyRaw())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_BodyRaw_Immutable -benchmem -count=4\nfunc Benchmark_Ctx_BodyRaw_Immutable(b *testing.B) {\n\tconst input = \"john=doe\"\n\n\tapp := New(Config{Immutable: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBodyRaw([]byte(input))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.BodyRaw()\n\t}\n\n\trequire.Equal(b, []byte(input), c.BodyRaw())\n}\n\n// go test -run Test_Ctx_Body_Immutable\nfunc Test_Ctx_Body_Immutable(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.Immutable = true\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBody([]byte(\"john=doe\"))\n\trequire.Equal(t, []byte(\"john=doe\"), c.Body())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Body_Immutable -benchmem -count=4\nfunc Benchmark_Ctx_Body_Immutable(b *testing.B) {\n\tconst input = \"john=doe\"\n\n\tapp := New()\n\tapp.config.Immutable = true\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Request().SetBody([]byte(input))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = c.Body()\n\t}\n\n\trequire.Equal(b, []byte(input), c.Body())\n}\n\n// go test -run Test_Ctx_Body_With_Compression\nfunc Test_Ctx_Body_With_Compression(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname            string\n\t\tcontentEncoding string\n\t\tbody            []byte\n\t\texpectedBody    []byte\n\t}{\n\t\t{\n\t\t\tname:            \"gzip\",\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tbody:            []byte(\"john=doe\"),\n\t\t\texpectedBody:    []byte(\"john=doe\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"unsupported_encoding\",\n\t\t\tcontentEncoding: \"undefined\",\n\t\t\tbody:            []byte(\"keeps_ORIGINAL\"),\n\t\t\texpectedBody:    []byte(\"keeps_ORIGINAL\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"gzip then unsupported\",\n\t\t\tcontentEncoding: \"gzip, undefined\",\n\t\t\tbody:            []byte(\"Go, be gzipped\"),\n\t\t\texpectedBody:    []byte(\"Go, be gzipped\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"invalid_deflate\",\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tbody:            []byte(\"I'm not correctly compressed\"),\n\t\t\texpectedBody:    []byte(zlib.ErrHeader.Error()),\n\t\t},\n\t}\n\n\tfor _, testObject := range tests {\n\t\ttCase := testObject // Duplicate object to ensure it will be unique across all runs\n\t\tt.Run(tCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tapp := New()\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", tCase.contentEncoding)\n\n\t\t\tif strings.Contains(tCase.contentEncoding, \"gzip\") {\n\t\t\t\tvar b bytes.Buffer\n\t\t\t\tgz := gzip.NewWriter(&b)\n\n\t\t\t\t_, err := gz.Write(tCase.body)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\terr = gz.Flush()\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\terr = gz.Close()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\ttCase.body = b.Bytes()\n\t\t\t}\n\n\t\t\tc.Request().SetBody(tCase.body)\n\t\t\tbody := c.Body()\n\t\t\trequire.Equal(t, tCase.expectedBody, body)\n\n\t\t\t// Check if body raw is the same as previous before decompression\n\t\t\trequire.Equal(\n\t\t\t\tt, tCase.body, c.Request().Body(),\n\t\t\t\t\"Body raw must be the same as set before\",\n\t\t\t)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Body_With_Compression -benchmem -count=4\nfunc Benchmark_Ctx_Body_With_Compression(b *testing.B) {\n\tencodingErr := errors.New(\"failed to encoding data\")\n\n\tvar (\n\t\tcompressGzip = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := gzip.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t\tcompressDeflate = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := zlib.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t)\n\tcompressionTests := []struct {\n\t\tcompressWriter  func([]byte) ([]byte, error)\n\t\tcontentEncoding string\n\t}{\n\t\t{\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,invalid\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"deflate\",\n\t\t\tcompressWriter:  compressDeflate,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tcompressWriter: func(data []byte) ([]byte, error) {\n\t\t\t\tvar (\n\t\t\t\t\tbuf    bytes.Buffer\n\t\t\t\t\twriter interface {\n\t\t\t\t\t\tio.WriteCloser\n\t\t\t\t\t\tFlush() error\n\t\t\t\t\t}\n\t\t\t\t\terr error\n\t\t\t\t)\n\n\t\t\t\t// deflate\n\t\t\t\t{\n\t\t\t\t\twriter = zlib.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata = make([]byte, buf.Len())\n\t\t\t\tcopy(data, buf.Bytes())\n\t\t\t\tbuf.Reset()\n\n\t\t\t\t// gzip\n\t\t\t\t{\n\t\t\t\t\twriter = gzip.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn buf.Bytes(), nil\n\t\t\t},\n\t\t},\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor _, ct := range compressionTests {\n\t\tb.Run(ct.contentEncoding, func(b *testing.B) {\n\t\t\tapp := New()\n\t\t\tconst input = \"john=doe\"\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", ct.contentEncoding)\n\t\t\tcompressedBody, err := ct.compressWriter([]byte(input))\n\t\t\trequire.NoError(b, err)\n\n\t\t\tc.Request().SetBody(compressedBody)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = c.Body()\n\t\t\t}\n\n\t\t\trequire.Equal(b, []byte(input), c.Body())\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Body_With_Compression_Immutable\nfunc Test_Ctx_Body_With_Compression_Immutable(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname            string\n\t\tcontentEncoding string\n\t\tbody            []byte\n\t\texpectedBody    []byte\n\t}{\n\t\t{\n\t\t\tname:            \"gzip\",\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tbody:            []byte(\"john=doe\"),\n\t\t\texpectedBody:    []byte(\"john=doe\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"unsupported_encoding\",\n\t\t\tcontentEncoding: \"undefined\",\n\t\t\tbody:            []byte(\"keeps_ORIGINAL\"),\n\t\t\texpectedBody:    []byte(\"keeps_ORIGINAL\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"gzip then unsupported\",\n\t\t\tcontentEncoding: \"gzip, undefined\",\n\t\t\tbody:            []byte(\"Go, be gzipped\"),\n\t\t\texpectedBody:    []byte(\"Go, be gzipped\"),\n\t\t},\n\t\t{\n\t\t\tname:            \"invalid_deflate\",\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tbody:            []byte(\"I'm not correctly compressed\"),\n\t\t\texpectedBody:    []byte(zlib.ErrHeader.Error()),\n\t\t},\n\t}\n\n\tfor _, testObject := range tests {\n\t\ttCase := testObject // Duplicate object to ensure it will be unique across all runs\n\t\tt.Run(tCase.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tapp := New()\n\t\t\tapp.config.Immutable = true\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", tCase.contentEncoding)\n\n\t\t\tif strings.Contains(tCase.contentEncoding, \"gzip\") {\n\t\t\t\tvar b bytes.Buffer\n\t\t\t\tgz := gzip.NewWriter(&b)\n\n\t\t\t\t_, err := gz.Write(tCase.body)\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\terr = gz.Flush()\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\terr = gz.Close()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\ttCase.body = b.Bytes()\n\t\t\t}\n\n\t\t\tc.Request().SetBody(tCase.body)\n\t\t\tbody := c.Body()\n\t\t\trequire.Equal(t, tCase.expectedBody, body)\n\n\t\t\t// Check if body raw is the same as previous before decompression\n\t\t\trequire.Equal(\n\t\t\t\tt, tCase.body, c.Request().Body(),\n\t\t\t\t\"Body raw must be the same as set before\",\n\t\t\t)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Body_With_Compression_Immutable -benchmem -count=4\nfunc Benchmark_Ctx_Body_With_Compression_Immutable(b *testing.B) {\n\tencodingErr := errors.New(\"failed to encoding data\")\n\n\tvar (\n\t\tcompressGzip = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := gzip.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t\tcompressDeflate = func(data []byte) ([]byte, error) {\n\t\t\tvar buf bytes.Buffer\n\t\t\twriter := zlib.NewWriter(&buf)\n\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Flush(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\treturn nil, encodingErr\n\t\t\t}\n\t\t\treturn buf.Bytes(), nil\n\t\t}\n\t)\n\tcompressionTests := []struct {\n\t\tcompressWriter  func([]byte) ([]byte, error)\n\t\tcontentEncoding string\n\t}{\n\t\t{\n\t\t\tcontentEncoding: \"gzip\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,invalid\",\n\t\t\tcompressWriter:  compressGzip,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"deflate\",\n\t\t\tcompressWriter:  compressDeflate,\n\t\t},\n\t\t{\n\t\t\tcontentEncoding: \"gzip,deflate\",\n\t\t\tcompressWriter: func(data []byte) ([]byte, error) {\n\t\t\t\tvar (\n\t\t\t\t\tbuf    bytes.Buffer\n\t\t\t\t\twriter interface {\n\t\t\t\t\t\tio.WriteCloser\n\t\t\t\t\t\tFlush() error\n\t\t\t\t\t}\n\t\t\t\t\terr error\n\t\t\t\t)\n\n\t\t\t\t// deflate\n\t\t\t\t{\n\t\t\t\t\twriter = zlib.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata = make([]byte, buf.Len())\n\t\t\t\tcopy(data, buf.Bytes())\n\t\t\t\tbuf.Reset()\n\n\t\t\t\t// gzip\n\t\t\t\t{\n\t\t\t\t\twriter = gzip.NewWriter(&buf)\n\t\t\t\t\tif _, err = writer.Write(data); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t\tif err = writer.Close(); err != nil {\n\t\t\t\t\t\treturn nil, encodingErr\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn buf.Bytes(), nil\n\t\t\t},\n\t\t},\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor _, ct := range compressionTests {\n\t\tb.Run(ct.contentEncoding, func(b *testing.B) {\n\t\t\tapp := New()\n\t\t\tapp.config.Immutable = true\n\t\t\tconst input = \"john=doe\"\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\t\tc.Request().Header.Set(\"Content-Encoding\", ct.contentEncoding)\n\t\t\tcompressedBody, err := ct.compressWriter([]byte(input))\n\t\t\trequire.NoError(b, err)\n\n\t\t\tc.Request().SetBody(compressedBody)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = c.Body()\n\t\t\t}\n\n\t\t\trequire.Equal(b, []byte(input), c.Body())\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_RequestCtx\nfunc Test_Ctx_RequestCtx(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, \"*fasthttp.RequestCtx\", fmt.Sprintf(\"%T\", c.RequestCtx()))\n}\n\n// go test -run Test_Ctx_Context\nfunc Test_Ctx_Context(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tt.Run(\"Nil_Context\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tctx := c.Context()\n\t\trequire.Equal(t, ctx, context.Background())\n\t})\n\tt.Run(\"ValueContext\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttestKey := struct{}{}\n\t\ttestValue := \"Test Value\"\n\t\tctx := context.WithValue(context.Background(), testKey, testValue) //nolint: staticcheck // not needed for tests\n\t\trequire.Equal(t, testValue, ctx.Value(testKey))\n\t})\n}\n\n// go test -run Test_Ctx_SetContext\nfunc Test_Ctx_SetContext(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttestKey := struct{}{}\n\ttestValue := \"Test Value\"\n\tctx := context.WithValue(context.Background(), testKey, testValue) //nolint: staticcheck // not needed for tests\n\tc.SetContext(ctx)\n\trequire.Equal(t, testValue, c.Context().Value(testKey))\n}\n\n// go test -run Test_Ctx_Context_Multiple_Requests\nfunc Test_Ctx_Context_Multiple_Requests(t *testing.T) {\n\tt.Parallel()\n\ttestKey := struct{}{}\n\ttestValue := \"foobar-value\"\n\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\tctx := c.Context()\n\n\t\tif ctx.Value(testKey) != nil {\n\t\t\treturn c.SendStatus(StatusInternalServerError)\n\t\t}\n\n\t\tinput := utils.CopyString(Query(c, \"input\", \"NO_VALUE\"))\n\t\tctx = context.WithValue(ctx, testKey, fmt.Sprintf(\"%s_%s\", testValue, input)) //nolint: staticcheck // not needed for tests\n\t\tc.SetContext(ctx)\n\n\t\treturn c.Status(StatusOK).SendString(fmt.Sprintf(\"resp_%s_returned\", input))\n\t})\n\n\t// Consecutive Requests\n\tfor i := 1; i <= 10; i++ {\n\t\tt.Run(fmt.Sprintf(\"request_%d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, fmt.Sprintf(\"/?input=%d\", i), nil))\n\n\t\t\trequire.NoError(t, err, \"Unexpected error from response\")\n\t\t\trequire.Equal(t, StatusOK, resp.StatusCode, \"context.Context returned from c.Context() is reused\")\n\n\t\t\tb, err := io.ReadAll(resp.Body)\n\t\t\trequire.NoError(t, err, \"Unexpected error from reading response body\")\n\t\t\trequire.Equal(t, fmt.Sprintf(\"resp_%d_returned\", i), string(b), \"response text incorrect\")\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Cookie\nfunc Test_Ctx_Cookie(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\texpire := time.Now().Add(24 * time.Hour)\n\tvar dst []byte\n\tdst = expire.In(time.UTC).AppendFormat(dst, time.RFC1123)\n\thttpdate := strings.ReplaceAll(string(dst), \"UTC\", \"GMT\")\n\tcookie := &Cookie{\n\t\tName:    \"username\",\n\t\tValue:   \"john\",\n\t\tExpires: expire,\n\t\t// SameSite: CookieSameSiteStrictMode, // default is \"lax\"\n\t}\n\tc.Cookie(cookie)\n\texpect := \"username=john; expires=\" + httpdate + \"; path=/; SameSite=Lax\"\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/\"\n\tcookie.SameSite = CookieSameSiteDisabled\n\tc.Cookie(cookie)\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/; SameSite=Strict\"\n\tcookie.SameSite = CookieSameSiteStrictMode\n\tc.Cookie(cookie)\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; expires=\" + httpdate + \"; path=/; secure; SameSite=None\"\n\tcookie.Secure = true\n\tcookie.SameSite = CookieSameSiteNoneMode\n\tc.Cookie(cookie)\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None\"\n\t// should remove expires and max-age headers\n\tcookie.SessionOnly = true\n\tcookie.Expires = expire\n\tcookie.MaxAge = 10000\n\tc.Cookie(cookie)\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None\"\n\t// should remove expires and max-age headers when no expire and no MaxAge (default time)\n\tcookie.SessionOnly = false\n\tcookie.Expires = time.Time{}\n\tcookie.MaxAge = 0\n\tc.Cookie(cookie)\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n\n\texpect = \"username=john; path=/; secure; SameSite=None; Partitioned\"\n\tcookie.Partitioned = true\n\tc.Cookie(cookie)\n\trequire.Equal(t, expect, string(c.Response().Header.Peek(HeaderSetCookie)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Cookie -benchmem -count=4\nfunc Benchmark_Ctx_Cookie(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Cookie(&Cookie{\n\t\t\tName:  \"John\",\n\t\t\tValue: \"Doe\",\n\t\t})\n\t}\n\trequire.Equal(b, \"John=Doe; path=/; SameSite=Lax\", app.getString(c.Response().Header.Peek(\"Set-Cookie\")))\n}\n\n// go test -run Test_Ctx_Cookies\nfunc Test_Ctx_Cookies(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"Cookie\", \"john=doe\")\n\trequire.Equal(t, \"doe\", c.Cookies(\"john\"))\n\trequire.Equal(t, \"default\", c.Cookies(\"unknown\", \"default\"))\n}\n\n// go test -run Test_Ctx_Format\nfunc Test_Ctx_Format(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// set `accepted` to whatever media type was chosen by Format\n\tvar accepted string\n\tformatHandlers := func(types ...string) []ResFmt {\n\t\tfmts := []ResFmt{}\n\t\tfor _, t := range types {\n\t\t\tt := utils.CopyString(t)\n\t\t\tfmts = append(fmts, ResFmt{MediaType: t, Handler: func(_ Ctx) error {\n\t\t\t\taccepted = t\n\t\t\t\treturn nil\n\t\t\t}})\n\t\t}\n\t\treturn fmts\n\t}\n\n\tc.Request().Header.Set(HeaderAccept, `text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7`)\n\terr := c.Format(formatHandlers(\"application/xhtml+xml\", \"application/xml\", \"foo/bar\")...)\n\trequire.Equal(t, \"application/xhtml+xml\", accepted)\n\trequire.Equal(t, \"application/xhtml+xml\", c.GetRespHeader(HeaderContentType))\n\trequire.NoError(t, err)\n\trequire.NotEqual(t, StatusNotAcceptable, c.Response().StatusCode())\n\n\terr = c.Format(formatHandlers(\"foo/bar;a=b\")...)\n\trequire.Equal(t, \"foo/bar;a=b\", accepted)\n\trequire.Equal(t, \"foo/bar;a=b\", c.GetRespHeader(HeaderContentType))\n\trequire.NoError(t, err)\n\trequire.NotEqual(t, StatusNotAcceptable, c.Response().StatusCode())\n\n\tmyError := errors.New(\"this is an error\")\n\terr = c.Format(ResFmt{MediaType: \"text/html\", Handler: func(_ Ctx) error { return myError }})\n\trequire.ErrorIs(t, err, myError)\n\n\tc.Request().Header.Set(HeaderAccept, \"application/json\")\n\terr = c.Format(ResFmt{MediaType: \"text/html\", Handler: func(c Ctx) error { return c.SendStatus(StatusOK) }})\n\trequire.Equal(t, StatusNotAcceptable, c.Response().StatusCode())\n\trequire.NoError(t, err)\n\n\terr = c.Format(formatHandlers(\"text/html\", \"default\")...)\n\trequire.Equal(t, \"default\", accepted)\n\trequire.Equal(t, \"text/html\", c.GetRespHeader(HeaderContentType))\n\trequire.NoError(t, err)\n\n\terr = c.Format()\n\trequire.ErrorIs(t, err, ErrNoHandlers)\n}\n\nfunc Benchmark_Ctx_Format(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderAccept, \"application/json,text/plain; format=flowed; q=0.9\")\n\n\tfail := func(_ Ctx) error {\n\t\trequire.FailNow(b, \"Wrong type chosen\")\n\t\treturn errors.New(\"Wrong type chosen\")\n\t}\n\tok := func(_ Ctx) error {\n\t\treturn nil\n\t}\n\n\tvar err error\n\tb.Run(\"with arg allocation\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\terr = c.Format(\n\t\t\t\tResFmt{MediaType: \"application/xml\", Handler: fail},\n\t\t\t\tResFmt{MediaType: \"text/html\", Handler: fail},\n\t\t\t\tResFmt{MediaType: \"text/plain;format=fixed\", Handler: fail},\n\t\t\t\tResFmt{MediaType: \"text/plain;format=flowed\", Handler: ok},\n\t\t\t)\n\t\t}\n\t\trequire.NoError(b, err)\n\t})\n\n\tb.Run(\"pre-allocated args\", func(b *testing.B) {\n\t\toffers := []ResFmt{\n\t\t\t{MediaType: \"application/xml\", Handler: fail},\n\t\t\t{MediaType: \"text/html\", Handler: fail},\n\t\t\t{MediaType: \"text/plain;format=fixed\", Handler: fail},\n\t\t\t{MediaType: \"text/plain;format=flowed\", Handler: ok},\n\t\t}\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\terr = c.Format(offers...)\n\t\t}\n\t\trequire.NoError(b, err)\n\t})\n\n\tc.Request().Header.Set(\"Accept\", \"text/plain\")\n\tb.Run(\"text/plain\", func(b *testing.B) {\n\t\toffers := []ResFmt{\n\t\t\t{MediaType: \"application/xml\", Handler: fail},\n\t\t\t{MediaType: \"text/plain\", Handler: ok},\n\t\t}\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\terr = c.Format(offers...)\n\t\t}\n\t\trequire.NoError(b, err)\n\t})\n\n\tc.Request().Header.Set(\"Accept\", \"json\")\n\tb.Run(\"json\", func(b *testing.B) {\n\t\toffers := []ResFmt{\n\t\t\t{MediaType: \"xml\", Handler: fail},\n\t\t\t{MediaType: \"html\", Handler: fail},\n\t\t\t{MediaType: \"json\", Handler: ok},\n\t\t}\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\terr = c.Format(offers...)\n\t\t}\n\t\trequire.NoError(b, err)\n\t})\n}\n\n// go test -run Test_Ctx_AutoFormat\nfunc Test_Ctx_AutoFormat(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr := c.AutoFormat([]byte(\"Hello, World!\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Hello, World!\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextHTML)\n\terr = c.AutoFormat(\"Hello, World!\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<p>Hello, World!</p>\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationJSON)\n\terr = c.AutoFormat(\"Hello, World!\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, `\"Hello, World!\"`, string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr = c.AutoFormat(complex(1, 1))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"(1+1i)\", string(c.Response().Body()))\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationXML)\n\terr = c.AutoFormat(\"Hello, World!\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, `<string>Hello, World!</string>`, string(c.Response().Body()))\n\n\terr = c.AutoFormat(complex(1, 1))\n\trequire.Error(t, err)\n\n\tc.Request().Header.Set(HeaderAccept, MIMETextPlain)\n\terr = c.AutoFormat(Map{})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"map[]\", string(c.Response().Body()))\n\n\ttype broken string\n\tc.Request().Header.Set(HeaderAccept, \"broken/accept\")\n\trequire.NoError(t, err)\n\terr = c.AutoFormat(broken(\"Hello, World!\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, `Hello, World!`, string(c.Response().Body()))\n}\n\nfunc Test_Ctx_AutoFormat_Struct(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype Message struct {\n\t\tSender     string `xml:\"sender,attr\"`\n\t\tRecipients []string\n\t\tUrgency    int `xml:\"urgency,attr\"`\n\t}\n\tdata := Message{\n\t\tRecipients: []string{\"Alice\", \"Bob\"},\n\t\tSender:     \"Carol\",\n\t\tUrgency:    3,\n\t}\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationJSON)\n\terr := c.AutoFormat(data)\n\trequire.NoError(t, err)\n\trequire.JSONEq(t,\n\t\t`{\"Sender\":\"Carol\",\"Recipients\":[\"Alice\",\"Bob\"],\"Urgency\":3}`,\n\t\tstring(c.Response().Body()),\n\t)\n\n\tc.Request().Header.Set(HeaderAccept, MIMEApplicationXML)\n\terr = c.AutoFormat(data)\n\trequire.NoError(t, err)\n\trequire.Equal(t,\n\t\t`<Message sender=\"Carol\" urgency=\"3\"><Recipients>Alice</Recipients><Recipients>Bob</Recipients></Message>`,\n\t\tstring(c.Response().Body()),\n\t)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AutoFormat -benchmem -count=4\nfunc Benchmark_Ctx_AutoFormat(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"Accept\", \"text/plain\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.AutoFormat(\"Hello, World!\")\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, `Hello, World!`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AutoFormat_HTML -benchmem -count=4\nfunc Benchmark_Ctx_AutoFormat_HTML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"Accept\", \"text/html\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.AutoFormat(\"Hello, World!\")\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"<p>Hello, World!</p>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AutoFormat_JSON -benchmem -count=4\nfunc Benchmark_Ctx_AutoFormat_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"Accept\", \"application/json\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.AutoFormat(\"Hello, World!\")\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, `\"Hello, World!\"`, string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_AutoFormat_XML -benchmem -count=4\nfunc Benchmark_Ctx_AutoFormat_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"Accept\", \"application/xml\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.AutoFormat(\"Hello, World!\")\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, `<string>Hello, World!</string>`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_FormFile\nfunc Test_Ctx_FormFile(t *testing.T) {\n\t// TODO: We should clean this up\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"test\", fh.Filename)\n\n\t\tf, err := fh.Open()\n\t\trequire.NoError(t, err)\n\t\tdefer func() {\n\t\t\trequire.NoError(t, f.Close())\n\t\t}()\n\n\t\tb := new(bytes.Buffer)\n\t\t_, err = io.Copy(b, f)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"hello world\", b.String())\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\trequire.NoError(t, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(HeaderContentType, writer.FormDataContentType())\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_FormValue\nfunc Test_Ctx_FormValue(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, \"john\", c.FormValue(\"name\"))\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\trequire.NoError(t, writer.WriteField(\"name\", \"john\"))\n\trequire.NoError(t, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", \"multipart/form-data; boundary=\"+writer.Boundary())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_StaleEtag -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_StaleEtag(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b, c, d\")\n\t\tc.Request().Header.Set(HeaderCacheControl, \"c\")\n\t\tc.Fresh()\n\n\t\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b, c, d\")\n\t\tc.Request().Header.Set(HeaderCacheControl, \"e\")\n\t\tc.Fresh()\n\t}\n}\n\n// go test -run Test_Ctx_Fresh\nfunc Test_Ctx_Fresh(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"no-cache\")\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \",no-cache,\")\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"aa,no-cache,\")\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \",no-cache,bb\")\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"675af34563dc-tr34\")\n\tc.Request().Header.Set(HeaderCacheControl, \"public\")\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"a, b\")\n\tc.Response().Header.Set(HeaderETag, \"c\")\n\trequire.False(t, c.Fresh())\n\n\tc.Response().Header.Set(HeaderETag, \"a\")\n\trequire.True(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"xxWed, 21 Oct 2015 07:28:00 GMT\")\n\tc.Response().Header.Set(HeaderLastModified, \"xxWed, 21 Oct 2015 07:28:00 GMT\")\n\trequire.False(t, c.Fresh())\n\n\tc.Response().Header.Set(HeaderLastModified, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\trequire.False(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\trequire.True(t, c.Fresh())\n\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"Wed, 21 Oct 2015 07:27:59 GMT\")\n\tc.Response().Header.Set(HeaderLastModified, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\trequire.False(t, c.Fresh())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_WithNoCache -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_WithNoCache(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderIfNoneMatch, \"*\")\n\tc.Request().Header.Set(HeaderCacheControl, \"no-cache\")\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Fresh()\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Fresh_LastModified -benchmem -count=4\nfunc Benchmark_Ctx_Fresh_LastModified(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Response().Header.Set(HeaderLastModified, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\tc.Request().Header.Set(HeaderIfModifiedSince, \"Wed, 21 Oct 2015 07:28:00 GMT\")\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Fresh()\n\t}\n}\n\n// go test -run Test_Ctx_Binders -v\nfunc Test_Ctx_Binders(t *testing.T) {\n\tt.Parallel()\n\t// setup\n\tapp := New(Config{\n\t\tEnableSplittingOnParsers: true,\n\t})\n\n\ttype TestEmbeddedStruct struct {\n\t\tNames []string `query:\"names\"`\n\t}\n\n\ttype TestStruct struct {\n\t\tName            string\n\t\tNameWithDefault string `json:\"name2\" xml:\"Name2\" form:\"name2\" cookie:\"name2\" query:\"name2\" params:\"name2\" header:\"Name2\"`\n\t\tTestEmbeddedStruct\n\t\tClass            int\n\t\tClassWithDefault int `json:\"class2\" xml:\"Class2\" form:\"class2\" cookie:\"class2\" query:\"class2\" params:\"class2\" header:\"Class2\"`\n\t}\n\n\twithValues := func(t *testing.T, actionFn func(c Ctx, testStruct *TestStruct) error) {\n\t\tt.Helper()\n\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\ttestStruct := new(TestStruct)\n\n\t\trequire.NoError(t, actionFn(c, testStruct))\n\t\trequire.Equal(t, \"foo\", testStruct.Name)\n\t\trequire.Equal(t, 111, testStruct.Class)\n\t\trequire.Equal(t, \"bar\", testStruct.NameWithDefault)\n\t\trequire.Equal(t, 222, testStruct.ClassWithDefault)\n\t\trequire.Equal(t, []string{\"foo\", \"bar\", \"test\"}, testStruct.TestEmbeddedStruct.Names)\n\t}\n\n\tt.Run(\"Body:xml\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tc.Request().Header.SetContentType(MIMEApplicationXML)\n\t\t\tc.Request().SetBody([]byte(`<TestStruct><Name>foo</Name><Class>111</Class><Name2>bar</Name2><Class2>222</Class2><Names>foo</Names><Names>bar</Names><Names>test</Names></TestStruct>`))\n\t\t\treturn c.Bind().Body(testStruct)\n\t\t})\n\t})\n\tt.Run(\"Body:form\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tc.Request().Header.SetContentType(MIMEApplicationForm)\n\t\t\tc.Request().SetBody([]byte(`name=foo&class=111&name2=bar&class2=222&names=foo,bar,test`))\n\t\t\treturn c.Bind().Body(testStruct)\n\t\t})\n\t})\n\tt.Run(\"BodyParser:json\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tc.Request().Header.SetContentType(MIMEApplicationJSON)\n\t\t\tc.Request().SetBody([]byte(`{\"name\":\"foo\",\"class\":111,\"name2\":\"bar\",\"class2\":222,\"names\":[\"foo\",\"bar\",\"test\"]}`))\n\t\t\treturn c.Bind().Body(testStruct)\n\t\t})\n\t})\n\tt.Run(\"Body:multiform\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tbody := []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\nfoo\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"class\\\"\\r\\n\\r\\n111\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"name2\\\"\\r\\n\\r\\nbar\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"class2\\\"\\r\\n\\r\\n222\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"names\\\"\\r\\n\\r\\nfoo\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"names\\\"\\r\\n\\r\\nbar\\r\\n--b\\r\\nContent-Disposition: form-data; name=\\\"names\\\"\\r\\n\\r\\ntest\\r\\n--b--\")\n\t\t\tc.Request().SetBody(body)\n\t\t\tc.Request().Header.SetContentType(MIMEMultipartForm + `;boundary=\"b\"`)\n\t\t\tc.Request().Header.SetContentLength(len(body))\n\t\t\treturn c.Bind().Body(testStruct)\n\t\t})\n\t})\n\tt.Run(\"Cookie\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tc.Request().Header.Set(\"Cookie\", \"name=foo;name2=bar;class=111;class2=222;names=foo,bar,test\")\n\t\t\treturn c.Bind().Cookie(testStruct)\n\t\t})\n\t})\n\tt.Run(\"Query\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tc.Request().URI().SetQueryString(\"name=foo&name2=bar&class=111&class2=222&names=foo,bar,test\")\n\t\t\treturn c.Bind().Query(testStruct)\n\t\t})\n\t})\n\tt.Run(\"URI\", func(t *testing.T) {\n\t\tt.Skip(\"URI is not ready for v3\")\n\t\t//nolint:gocritic // TODO: uncomment\n\t\t//t.Parallel()\n\t\t//withValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t//\tc.Route().Params = []string{\"name\", \"name2\", \"class\", \"class2\"}\n\t\t//\tc.Params().value = [30]string{\"foo\", \"bar\", \"111\", \"222\"}\n\t\t//\treturn c.Bind().URI(testStruct)\n\t\t//})\n\t})\n\tt.Run(\"ReqHeader\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twithValues(t, func(c Ctx, testStruct *TestStruct) error {\n\t\t\tc.Request().Header.Add(\"name\", \"foo\")\n\t\t\tc.Request().Header.Add(\"name2\", \"bar\")\n\t\t\tc.Request().Header.Add(\"class\", \"111\")\n\t\t\tc.Request().Header.Add(\"class2\", \"222\")\n\t\t\tc.Request().Header.Add(\"names\", \"foo,bar,test\")\n\t\t\treturn c.Bind().Header(testStruct)\n\t\t})\n\t})\n}\n\n// go test -run Test_Ctx_Get\nfunc Test_Ctx_Get(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderAcceptCharset, \"utf-8, iso-8859-1;q=0.5\")\n\tc.Request().Header.Set(HeaderReferer, \"Monster\")\n\trequire.Equal(t, \"utf-8, iso-8859-1;q=0.5\", c.Get(HeaderAcceptCharset))\n\trequire.Equal(t, \"Monster\", c.Get(HeaderReferer))\n\trequire.Equal(t, \"default\", c.Get(\"unknown\", \"default\"))\n}\n\n// go test -run Test_Ctx_GetReqHeader\nfunc Test_Ctx_GetReqHeader(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"foo\", \"bar\")\n\tc.Request().Header.Set(\"id\", \"123\")\n\trequire.Equal(t, 123, GetReqHeader[int](c, \"id\"))\n\trequire.Equal(t, \"bar\", GetReqHeader[string](c, \"foo\"))\n}\n\n// go test -run Test_Ctx_Host\nfunc Test_Ctx_Host(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\trequire.Equal(t, \"google.com\", c.Host())\n}\n\n// go test -run Test_Ctx_Host_UntrustedProxy\nfunc Test_Ctx_Host_UntrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t// Don't trust any proxy\n\t{\n\t\tapp := New(Config{TrustProxy: true, TrustProxyConfig: TrustProxyConfig{Proxies: []string{}}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\trequire.Equal(t, \"google.com\", c.Host())\n\t\tapp.ReleaseCtx(c)\n\t}\n\t// Trust to specific proxy list\n\t{\n\t\tapp := New(Config{TrustProxy: true, TrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.8.0.0\", \"0.8.0.1\"}}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\trequire.Equal(t, \"google.com\", c.Host())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Host_TrustedProxy\nfunc Test_Ctx_Host_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{TrustProxy: true, TrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0\", \"0.8.0.1\"}}})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\trequire.Equal(t, \"google1.com\", c.Host())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Host_TrustedProxyRange\nfunc Test_Ctx_Host_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{TrustProxy: true, TrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0/30\"}}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\trequire.Equal(t, \"google1.com\", c.Host())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Host_UntrustedProxyRange\nfunc Test_Ctx_Host_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{TrustProxy: true, TrustProxyConfig: TrustProxyConfig{Proxies: []string{\"1.0.0.0/30\"}}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\trequire.Equal(t, \"google.com\", c.Host())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Host -benchmem -count=4\nfunc Benchmark_Ctx_Host(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tvar host string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\thost = c.Host()\n\t}\n\trequire.Equal(b, \"google.com\", host)\n}\n\n// go test -run Test_Ctx_IsProxyTrusted\nfunc Test_Ctx_IsProxyTrusted(t *testing.T) {\n\tt.Parallel()\n\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\trequire.True(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: false,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.True(t, c.IsProxyTrusted())\n\t}\n\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"127.0.0.1\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"127.0.0.1/8\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.0\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.True(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.1/31\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.True(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.1/31junk\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tPrivate: true,\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tLoopback: true,\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tLinkLocal: true,\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\trequire.False(t, c.IsProxyTrusted())\n\t}\n}\n\n// go test -run Test_Ctx_Hostname\nfunc Test_Ctx_Hostname(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\trequire.Equal(t, \"google.com\", c.Hostname())\n\n\tc.Request().SetRequestURI(\"http://google.com:8080/test\")\n\trequire.Equal(t, \"google.com\", c.Hostname())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Hostname -benchmem -count=4\nfunc Benchmark_Ctx_Hostname(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com:8080/test\")\n\tvar hostname string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\thostname = c.Hostname()\n\t}\n\t// Trust to specific proxy list\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy:       true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.8.0.0\", \"0.8.0.1\"}},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\trequire.Equal(b, \"google.com\", hostname)\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_Trusted\nfunc Test_Ctx_Hostname_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy:       true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0\", \"0.8.0.1\"}},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\trequire.Equal(t, \"google1.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_Trusted_Multiple\nfunc Test_Ctx_Hostname_TrustedProxy_Multiple(t *testing.T) {\n\tt.Parallel()\n\t{\n\t\tapp := New(Config{\n\t\t\tTrustProxy:       true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0\", \"0.8.0.1\"}},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com, google2.com\")\n\t\trequire.Equal(t, \"google1.com\", c.Hostname())\n\t\tapp.ReleaseCtx(c)\n\t}\n}\n\n// go test -run Test_Ctx_Hostname_UntrustedProxyRange\nfunc Test_Ctx_Hostname_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0/30\"}},\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\trequire.Equal(t, \"google1.com\", c.Hostname())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Hostname_UntrustedProxyRange\nfunc Test_Ctx_Hostname_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"1.0.0.0/30\"}},\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().SetRequestURI(\"http://google.com/test\")\n\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\trequire.Equal(t, \"google.com\", c.Hostname())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -run Test_Ctx_Port\nfunc Test_Ctx_Port(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, \"0\", c.Port())\n}\n\n// go test -run Test_Ctx_PortInHandler\nfunc Test_Ctx_PortInHandler(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/port\", func(c Ctx) error {\n\t\treturn c.SendString(c.Port())\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/port\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"0\", string(body))\n}\n\n// go test -run Test_Ctx_IP\nfunc Test_Ctx_IP(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// default behavior will return the remote IP from the stack\n\trequire.Equal(t, \"0.0.0.0\", c.IP())\n\n\t// X-Forwarded-For is set, but it is ignored because proxyHeader is not set\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\trequire.Equal(t, \"0.0.0.0\", c.IP())\n}\n\n// go test -run Test_Ctx_IP_ProxyHeader\nfunc Test_Ctx_IP_ProxyHeader(t *testing.T) {\n\tt.Parallel()\n\n\t// make sure that the same behavior exists for different proxy header names\n\tproxyHeaderNames := []string{\"Real-Ip\", HeaderXForwardedFor}\n\n\tfor _, proxyHeaderName := range proxyHeaderNames {\n\t\tapp := New(Config{ProxyHeader: proxyHeaderName})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1\")\n\t\trequire.Equal(t, \"0.0.0.1\", c.IP())\n\n\t\t// without IP validation we return the full string\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1, 0.0.0.2\")\n\t\trequire.Equal(t, \"0.0.0.1, 0.0.0.2\", c.IP())\n\n\t\t// without IP validation we return invalid IPs\n\t\tc.Request().Header.Set(proxyHeaderName, \"invalid, 0.0.0.2, 0.0.0.3\")\n\t\trequire.Equal(t, \"invalid, 0.0.0.2, 0.0.0.3\", c.IP())\n\n\t\t// when proxy header is enabled but the value is empty, without IP validation we return an empty string\n\t\tc.Request().Header.Set(proxyHeaderName, \"\")\n\t\trequire.Equal(t, \"\", c.IP())\n\n\t\t// without IP validation we return an invalid IP\n\t\tc.Request().Header.Set(proxyHeaderName, \"not-valid-ip\")\n\t\trequire.Equal(t, \"not-valid-ip\", c.IP())\n\t}\n}\n\n// go test -run Test_Ctx_IP_ProxyHeader\nfunc Test_Ctx_IP_ProxyHeader_With_IP_Validation(t *testing.T) {\n\tt.Parallel()\n\n\t// make sure that the same behavior exists for different proxy header names\n\tproxyHeaderNames := []string{\"Real-Ip\", HeaderXForwardedFor}\n\n\tfor _, proxyHeaderName := range proxyHeaderNames {\n\t\tapp := New(Config{EnableIPValidation: true, ProxyHeader: proxyHeaderName})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\t// when proxy header & validation is enabled and the value is a valid IP, we return it\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1\")\n\t\trequire.Equal(t, \"0.0.0.1\", c.IP())\n\n\t\t// when proxy header & validation is enabled and the value is a list of IPs, we return the first valid IP\n\t\tc.Request().Header.Set(proxyHeaderName, \"0.0.0.1, 0.0.0.2\")\n\t\trequire.Equal(t, \"0.0.0.1\", c.IP())\n\n\t\tc.Request().Header.Set(proxyHeaderName, \"invalid, 0.0.0.2, 0.0.0.3\")\n\t\trequire.Equal(t, \"0.0.0.2\", c.IP())\n\n\t\t// when proxy header & validation is enabled but the value is empty, we will ignore the header\n\t\tc.Request().Header.Set(proxyHeaderName, \"\")\n\t\trequire.Equal(t, \"0.0.0.0\", c.IP())\n\n\t\t// when proxy header & validation is enabled but the value is not an IP, we will ignore the header\n\t\t// and return the IP of the caller\n\t\tc.Request().Header.Set(proxyHeaderName, \"not-valid-ip\")\n\t\trequire.Equal(t, \"0.0.0.0\", c.IP())\n\t}\n}\n\n// go test -run Test_Ctx_IP_UntrustedProxy\nfunc Test_Ctx_IP_UntrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.8.0.1\"}},\n\t\tProxyHeader:      HeaderXForwardedFor,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\trequire.Equal(t, \"0.0.0.0\", c.IP())\n}\n\n// go test -run Test_Ctx_IP_TrustedProxy\nfunc Test_Ctx_IP_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0\"}},\n\t\tProxyHeader:      HeaderXForwardedFor,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"0.0.0.1\")\n\trequire.Equal(t, \"0.0.0.1\", c.IP())\n}\n\n// go test -run Test_Ctx_IPs  -parallel\nfunc Test_Ctx_IPs(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// normal happy path test case\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, 127.0.0.2, 127.0.0.3\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// inconsistent space formatting\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1,127.0.0.2  ,127.0.0.3\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// invalid IPs are allowed to be returned\n\tc.Request().Header.Set(HeaderXForwardedFor, \"invalid, 127.0.0.1, 127.0.0.2\")\n\trequire.Equal(t, []string{\"invalid\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.2\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"invalid\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure that the ordering of IPs in the header is maintained\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.3, 127.0.0.1, 127.0.0.2\")\n\trequire.Equal(t, []string{\"127.0.0.3\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure for IPv6\n\tc.Request().Header.Set(HeaderXForwardedFor, \"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\trequire.Equal(t, []string{\"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\", \"invalid\", \"2345:0425:2CA1::0567:5673:23b5\"}, c.IPs())\n\n\t// empty header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"\")\n\trequire.Empty(t, c.IPs())\n\n\t// missing header\n\tc.Request()\n\trequire.Empty(t, c.IPs())\n}\n\nfunc Test_Ctx_IPs_With_IP_Validation(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// normal happy path test case\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, 127.0.0.2, 127.0.0.3\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// inconsistent space formatting\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1,127.0.0.2  ,127.0.0.3\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"127.0.0.2\", \"127.0.0.3\"}, c.IPs())\n\n\t// invalid IPs are in the header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"invalid, 127.0.0.1, 127.0.0.2\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.2\")\n\trequire.Equal(t, []string{\"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure that the ordering of IPs in the header is maintained\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.3, 127.0.0.1, 127.0.0.2\")\n\trequire.Equal(t, []string{\"127.0.0.3\", \"127.0.0.1\", \"127.0.0.2\"}, c.IPs())\n\n\t// ensure for IPv6\n\tc.Request().Header.Set(HeaderXForwardedFor, \"f037:825e:eadb:1b7b:1667:6f0a:5356:f604, invalid, 9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\")\n\trequire.Equal(t, []string{\"f037:825e:eadb:1b7b:1667:6f0a:5356:f604\", \"9396:9549:b4f7:8ed0:4791:1330:8c06:e62d\"}, c.IPs())\n\n\t// empty header\n\tc.Request().Header.Set(HeaderXForwardedFor, \"\")\n\trequire.Empty(t, c.IPs())\n\n\t// missing header\n\tc.Request()\n\trequire.Empty(t, c.IPs())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_IPs -benchmem -count=4\nfunc Benchmark_Ctx_IPs(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.1\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\trequire.Equal(b, []string{\"127.0.0.1\", \"invalid\", \"127.0.0.1\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_v6(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"f037:825e:eadb:1b7b:1667:6f0a:5356:f604, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\trequire.Equal(b, []string{\"f037:825e:eadb:1b7b:1667:6f0a:5356:f604\", \"invalid\", \"2345:0425:2CA1::0567:5673:23b5\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_With_IP_Validation(b *testing.B) {\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1, invalid, 127.0.0.1\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\trequire.Equal(b, []string{\"127.0.0.1\", \"127.0.0.1\"}, res)\n}\n\nfunc Benchmark_Ctx_IPs_v6_With_IP_Validation(b *testing.B) {\n\tapp := New(Config{EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\tc.Request().Header.Set(HeaderXForwardedFor, \"2345:0425:2CA1:0000:0000:0567:5673:23b5, invalid, 2345:0425:2CA1::0567:5673:23b5\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IPs()\n\t}\n\trequire.Equal(b, []string{\"2345:0425:2CA1:0000:0000:0567:5673:23b5\", \"2345:0425:2CA1::0567:5673:23b5\"}, res)\n}\n\nfunc Benchmark_Ctx_IP_With_ProxyHeader(b *testing.B) {\n\tapp := New(Config{ProxyHeader: HeaderXForwardedFor})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\trequire.Equal(b, \"127.0.0.1\", res)\n}\n\nfunc Benchmark_Ctx_IP_With_ProxyHeader_and_IP_Validation(b *testing.B) {\n\tapp := New(Config{ProxyHeader: HeaderXForwardedFor, EnableIPValidation: true})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\trequire.Equal(b, \"127.0.0.1\", res)\n}\n\nfunc Benchmark_Ctx_IP(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request()\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.IP()\n\t}\n\trequire.Equal(b, \"0.0.0.0\", res)\n}\n\n// go test -run Test_Ctx_Is\nfunc Test_Ctx_Is(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderContentType, MIMETextHTML+\"; boundary=something\")\n\trequire.True(t, c.Is(\".html\"))\n\trequire.True(t, c.Is(\"html\"))\n\trequire.False(t, c.Is(\"json\"))\n\trequire.False(t, c.Is(\".json\"))\n\trequire.False(t, c.Is(\"\"))\n\trequire.False(t, c.Is(\".foooo\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationJSONCharsetUTF8)\n\trequire.False(t, c.Is(\"html\"))\n\trequire.True(t, c.Is(\"json\"))\n\trequire.True(t, c.Is(\".json\"))\n\n\tc.Request().Header.Set(HeaderContentType, \" application/json;charset=UTF-8\")\n\trequire.False(t, c.Is(\"html\"))\n\trequire.True(t, c.Is(\"json\"))\n\trequire.True(t, c.Is(\".json\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationXMLCharsetUTF8)\n\trequire.False(t, c.Is(\"html\"))\n\trequire.True(t, c.Is(\"xml\"))\n\trequire.True(t, c.Is(\".xml\"))\n\n\tc.Request().Header.Set(HeaderContentType, MIMETextPlain)\n\trequire.False(t, c.Is(\"html\"))\n\trequire.True(t, c.Is(\"txt\"))\n\trequire.True(t, c.Is(\".txt\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Is -benchmem -count=4\nfunc Benchmark_Ctx_Is(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderContentType, MIMEApplicationJSON)\n\tvar res bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.Is(\".json\")\n\t\tres = c.Is(\"json\")\n\t}\n\trequire.True(b, res)\n}\n\n// go test -run Test_Ctx_Locals\nfunc Test_Ctx_Locals(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\tc.Locals(\"john\", \"doe\")\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, \"doe\", c.Locals(\"john\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Locals_Generic\nfunc Test_Ctx_Locals_Generic(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\tLocals[string](c, \"john\", \"doe\")\n\t\tLocals[int](c, \"age\", 18)\n\t\tLocals[bool](c, \"isHuman\", true)\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, \"doe\", Locals[string](c, \"john\"))\n\t\trequire.Equal(t, 18, Locals[int](c, \"age\"))\n\t\trequire.True(t, Locals[bool](c, \"isHuman\"))\n\t\trequire.Equal(t, 0, Locals[int](c, \"isHuman\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Locals_GenericCustomStruct\nfunc Test_Ctx_Locals_GenericCustomStruct(t *testing.T) {\n\tt.Parallel()\n\n\ttype User struct {\n\t\tname string\n\t\tage  int\n\t}\n\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\tLocals[User](c, \"user\", User{name: \"john\", age: 18})\n\t\treturn c.Next()\n\t})\n\tapp.Use(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, User{name: \"john\", age: 18}, Locals[User](c, \"user\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Method\nfunc Test_Ctx_Method(t *testing.T) {\n\tt.Parallel()\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(MethodGet)\n\tapp := New()\n\tc := app.AcquireCtx(fctx)\n\n\trequire.Equal(t, MethodGet, c.Method())\n\tc.Method(MethodPost)\n\trequire.Equal(t, MethodPost, c.Method())\n\n\tc.Method(\"MethodInvalid\")\n\trequire.Equal(t, MethodPost, c.Method())\n}\n\n// go test -run Test_Ctx_ClientHelloInfo\nfunc Test_Ctx_ClientHelloInfo(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/ServerName\", func(c Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.SendString(result.ServerName)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\tapp.Get(\"/SignatureSchemes\", func(c Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.JSON(result.SignatureSchemes)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\tapp.Get(\"/SupportedVersions\", func(c Ctx) error {\n\t\tresult := c.ClientHelloInfo()\n\t\tif result != nil {\n\t\t\treturn c.JSON(result.SupportedVersions)\n\t\t}\n\n\t\treturn c.SendString(\"ClientHelloInfo is nil\")\n\t})\n\n\t// Test without TLS handler\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/ServerName\", nil))\n\trequire.NoError(t, err)\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"ClientHelloInfo is nil\"), body)\n\n\t// Test with TLS Handler\n\tconst (\n\t\tpssWithSHA256 = 0x0804\n\t\tversionTLS13  = 0x0304\n\t)\n\tapp.tlsHandler = &TLSHandler{clientHelloInfo: &tls.ClientHelloInfo{\n\t\tServerName:        \"example.golang\",\n\t\tSignatureSchemes:  []tls.SignatureScheme{pssWithSHA256},\n\t\tSupportedVersions: []uint16{versionTLS13},\n\t}}\n\n\t// Test ServerName\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/ServerName\", nil))\n\trequire.NoError(t, err)\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"example.golang\"), body)\n\n\t// Test SignatureSchemes\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/SignatureSchemes\", nil))\n\trequire.NoError(t, err)\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"[\"+strconv.Itoa(pssWithSHA256)+\"]\", string(body))\n\n\t// Test SupportedVersions\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/SupportedVersions\", nil))\n\trequire.NoError(t, err)\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"[\"+strconv.Itoa(versionTLS13)+\"]\", string(body))\n}\n\n// go test -run Test_Ctx_InvalidMethod\nfunc Test_Ctx_InvalidMethod(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn nil\n\t})\n\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(\"InvalidMethod\")\n\tfctx.Request.SetRequestURI(\"/\")\n\n\tapp.Handler()(fctx)\n\n\trequire.Equal(t, 501, fctx.Response.StatusCode())\n\trequire.Equal(t, []byte(\"Not Implemented\"), fctx.Response.Body())\n}\n\n// go test -run Test_Ctx_MultipartForm\nfunc Test_Ctx_MultipartForm(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c Ctx) error {\n\t\tresult, err := c.MultipartForm()\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"john\", result.Value[\"name\"][0])\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\trequire.NoError(t, writer.WriteField(\"name\", \"john\"))\n\trequire.NoError(t, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(HeaderContentType, \"multipart/form-data; boundary=\"+writer.Boundary())\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_MultipartForm -benchmem -count=4\nfunc Benchmark_Ctx_MultipartForm(b *testing.B) {\n\tapp := New()\n\n\tapp.Post(\"/\", func(c Ctx) error {\n\t\t_, err := c.MultipartForm()\n\t\treturn err\n\t})\n\n\tc := &fasthttp.RequestCtx{}\n\n\tbody := []byte(\"--b\\r\\nContent-Disposition: form-data; name=\\\"name\\\"\\r\\n\\r\\njohn\\r\\n--b--\")\n\tc.Request.SetBody(body)\n\tc.Request.Header.SetContentType(MIMEMultipartForm + `;boundary=\"b\"`)\n\tc.Request.Header.SetContentLength(len(body))\n\n\th := app.Handler()\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(c)\n\t}\n}\n\n// go test -run Test_Ctx_OriginalURL\nfunc Test_Ctx_OriginalURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.SetRequestURI(\"http://google.com/test?search=demo\")\n\trequire.Equal(t, \"http://google.com/test?search=demo\", c.OriginalURL())\n}\n\n// go test -race -run Test_Ctx_Params\nfunc Test_Ctx_Params(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test/:user\", func(c Ctx) error {\n\t\trequire.Equal(t, \"john\", c.Params(\"user\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/*\", func(c Ctx) error {\n\t\trequire.Equal(t, \"im/a/cookie\", c.Params(\"*\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test3/*/blafasel/*\", func(c Ctx) error {\n\t\trequire.Equal(t, \"1111\", c.Params(\"*1\"))\n\t\trequire.Equal(t, 1111, Params(c, \"*1\", 0))\n\t\trequire.Equal(t, \"2222\", c.Params(\"*2\"))\n\t\trequire.Equal(t, 2222, Params(c, \"*2\", 0))\n\t\trequire.Equal(t, \"1111\", c.Params(\"*\"))\n\t\trequire.Equal(t, 1111, Params(c, \"*\", 0))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test4/:optional?\", func(c Ctx) error {\n\t\trequire.Equal(t, \"\", c.Params(\"optional\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test5/:id/:Id\", func(c Ctx) error {\n\t\trequire.Equal(t, \"first\", c.Params(\"id\"))\n\t\trequire.Equal(t, \"first\", c.Params(\"Id\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/im/a/cookie\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test3/1111/blafasel/2222\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test4\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test5/first/second\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_Ctx_Params_ErrorHandler_Panic_Issue_2832(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{\n\t\tErrorHandler: func(c Ctx, _ error) error {\n\t\t\treturn c.SendString(c.Params(\"user\"))\n\t\t},\n\t\tBodyLimit: 1 * 1024,\n\t})\n\n\tapp.Get(\"/test/:user\", func(_ Ctx) error {\n\t\treturn NewError(StatusInternalServerError, \"error\")\n\t})\n\n\tlargeBody := make([]byte, 2*1024)\n\t_, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", bytes.NewReader(largeBody)))\n\trequire.ErrorIs(t, err, fasthttp.ErrBodyTooLarge, \"app.Test(req)\")\n}\n\nfunc Test_Ctx_Params_Case_Sensitive(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{CaseSensitive: true})\n\tapp.Get(\"/test/:User\", func(c Ctx) error {\n\t\trequire.Equal(t, \"john\", c.Params(\"User\"))\n\t\trequire.Equal(t, \"\", c.Params(\"user\"))\n\t\treturn nil\n\t})\n\tapp.Get(\"/test2/:id/:Id\", func(c Ctx) error {\n\t\trequire.Equal(t, \"first\", c.Params(\"id\"))\n\t\trequire.Equal(t, \"second\", c.Params(\"Id\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test/john\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test2/first/second\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Params -benchmem -count=4\nfunc Benchmark_Ctx_Params(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.route = &Route{\n\t\tParams: []string{\n\t\t\t\"param1\", \"param2\", \"param3\", \"param4\",\n\t\t},\n\t}\n\tc.values = [maxParams]string{\n\t\t\"john\", \"doe\", \"is\", \"awesome\",\n\t}\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = c.Params(\"param1\")\n\t\t_ = c.Params(\"param2\")\n\t\t_ = c.Params(\"param3\")\n\t\tres = c.Params(\"param4\")\n\t}\n\trequire.Equal(b, \"awesome\", res)\n}\n\n// go test -run Test_Ctx_Path\nfunc Test_Ctx_Path(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{UnescapePath: true})\n\tapp.Get(\"/test/:user\", func(c Ctx) error {\n\t\trequire.Equal(t, \"/Test/John\", c.Path())\n\t\t// not strict && case insensitive\n\t\trequire.Equal(t, \"/ABC/\", c.Path(\"/ABC/\"))\n\t\trequire.Equal(t, \"/test/john/\", c.Path(\"/test/john/\"))\n\t\treturn nil\n\t})\n\n\t// test with special chars\n\tapp.Get(\"/specialChars/:name\", func(c Ctx) error {\n\t\trequire.Equal(t, \"/specialChars/créer\", c.Path())\n\t\t// unescape is also working if you set the path afterwards\n\t\trequire.Equal(t, \"/اختبار/\", c.Path(\"/%D8%A7%D8%AE%D8%AA%D8%A8%D8%A7%D8%B1/\"))\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/specialChars/cr%C3%A9er\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Protocol\nfunc Test_Ctx_Protocol(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, \"HTTP/1.1\", c.Protocol())\n\n\tc.Request().Header.SetProtocol(\"HTTP/2\")\n\trequire.Equal(t, \"HTTP/2\", c.Protocol())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Protocol -benchmem -count=4\nfunc Benchmark_Ctx_Protocol(b *testing.B) {\n\tapp := New()\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Protocol()\n\t}\n\n\trequire.Equal(b, \"HTTP/1.1\", res)\n}\n\n// go test -run Test_Ctx_Scheme\nfunc Test_Ctx_Scheme(t *testing.T) {\n\tapp := New()\n\n\tfreq := &fasthttp.RequestCtx{}\n\tfreq.Request.Header.Set(\"X-Forwarded\", \"invalid\")\n\n\tc := app.AcquireCtx(freq)\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProto, \"https, http\")\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, \"https, http\")\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Scheme -benchmem -count=4\nfunc Benchmark_Ctx_Scheme(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Scheme()\n\t}\n\trequire.Equal(b, \"http\", res)\n}\n\n// go test -run Test_Ctx_Scheme_TrustedProxy\nfunc Test_Ctx_Scheme_TrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{TrustProxy: true, TrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0\"}}})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n}\n\n// go test -run Test_Ctx_Scheme_TrustedProxyRange\nfunc Test_Ctx_Scheme_TrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.0.0.0/30\"}},\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\trequire.Equal(t, schemeHTTPS, c.Scheme())\n\tc.Request().Header.Reset()\n\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n}\n\n// go test -run Test_Ctx_Scheme_UntrustedProxyRange\nfunc Test_Ctx_Scheme_UntrustedProxyRange(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"1.1.1.1/30\"}},\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n}\n\n// go test -run Test_Ctx_Scheme_UnTrustedProxy\nfunc Test_Ctx_Scheme_UnTrustedProxy(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tTrustProxy:       true,\n\t\tTrustProxyConfig: TrustProxyConfig{Proxies: []string{\"0.8.0.1\"}},\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderXForwardedProto, schemeHTTPS)\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedProtocol, schemeHTTPS)\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXForwardedSsl, \"on\")\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\tc.Request().Header.Set(HeaderXUrlScheme, schemeHTTPS)\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n\tc.Request().Header.Reset()\n\n\trequire.Equal(t, schemeHTTP, c.Scheme())\n}\n\n// go test -run Test_Ctx_Query\nfunc Test_Ctx_Query(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().URI().SetQueryString(\"search=john&age=20\")\n\trequire.Equal(t, \"john\", c.Query(\"search\"))\n\trequire.Equal(t, \"20\", c.Query(\"age\"))\n\trequire.Equal(t, \"default\", c.Query(\"unknown\", \"default\"))\n\n\t// test with generic\n\trequire.Equal(t, \"john\", Query[string](c, \"search\"))\n\trequire.Equal(t, \"20\", Query[string](c, \"age\"))\n\trequire.Equal(t, \"default\", Query[string](c, \"unknown\", \"default\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Query -benchmem -count=4\nfunc Benchmark_Ctx_Query(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().URI().SetQueryString(\"search=john&age=8\")\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = Query[string](c, \"search\")\n\t}\n\trequire.Equal(b, \"john\", res)\n}\n\n// go test -run Test_Ctx_Range\nfunc Test_Ctx_Range(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttestRange := func(header string, ranges ...RangeSet) {\n\t\tc.Request().Header.Set(HeaderRange, header)\n\t\tresult, err := c.Range(1000)\n\t\tif len(ranges) == 0 {\n\t\t\trequire.Error(t, err)\n\t\t} else {\n\t\t\trequire.Equal(t, \"bytes\", result.Type)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t\trequire.Equal(t, len(ranges), len(result.Ranges))\n\t\tfor i := range ranges {\n\t\t\trequire.Equal(t, ranges[i], result.Ranges[i])\n\t\t}\n\t}\n\n\ttestRange(\"bytes=500\")\n\ttestRange(\"bytes=\")\n\ttestRange(\"bytes=500=\")\n\ttestRange(\"bytes=500-300\")\n\ttestRange(\"bytes=a-700\", RangeSet{Start: 300, End: 999})\n\ttestRange(\"bytes=500-b\", RangeSet{Start: 500, End: 999})\n\ttestRange(\"bytes=500-1000\", RangeSet{Start: 500, End: 999})\n\ttestRange(\"bytes=500-700\", RangeSet{Start: 500, End: 700})\n\ttestRange(\"bytes=0-0,2-1000\", RangeSet{Start: 0, End: 0}, RangeSet{Start: 2, End: 999})\n\ttestRange(\"bytes=0-99,450-549,-100\", RangeSet{Start: 0, End: 99}, RangeSet{Start: 450, End: 549}, RangeSet{Start: 900, End: 999})\n\ttestRange(\"bytes=500-700,601-999\", RangeSet{Start: 500, End: 700}, RangeSet{Start: 601, End: 999})\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Range -benchmem -count=4\nfunc Benchmark_Ctx_Range(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tdefer app.ReleaseCtx(c)\n\n\ttestCases := []struct {\n\t\tstr   string\n\t\tstart int\n\t\tend   int\n\t}{\n\t\t{str: \"bytes=-700\", start: 300, end: 999},\n\t\t{str: \"bytes=500-\", start: 500, end: 999},\n\t\t{str: \"bytes=500-1000\", start: 500, end: 999},\n\t\t{str: \"bytes=0-700,800-1000\", start: 0, end: 700},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tb.Run(tc.str, func(b *testing.B) {\n\t\t\tc.Request().Header.Set(HeaderRange, tc.str)\n\t\t\tvar (\n\t\t\t\tresult Range\n\t\t\t\terr    error\n\t\t\t)\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tresult, err = c.Range(1000)\n\t\t\t}\n\t\t\trequire.NoError(b, err)\n\t\t\trequire.Equal(b, \"bytes\", result.Type)\n\t\t\trequire.Equal(b, tc.start, result.Ranges[0].Start)\n\t\t\trequire.Equal(b, tc.end, result.Ranges[0].End)\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Route\nfunc Test_Ctx_Route(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, \"/test\", c.Route().Path)\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, \"/\", c.Route().Path)\n\trequire.Equal(t, MethodGet, c.Route().Method)\n\trequire.Empty(t, c.Route().Handlers)\n}\n\n// go test -run Test_Ctx_RouteNormalized\nfunc Test_Ctx_RouteNormalized(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\trequire.Equal(t, \"/test\", c.Route().Path)\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"//test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_SaveFile\nfunc Test_Ctx_SaveFile(t *testing.T) {\n\t// TODO We should clean this up\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Post(\"/test\", func(c Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\trequire.NoError(t, err)\n\n\t\ttempFile, err := os.CreateTemp(os.TempDir(), \"test-\")\n\t\trequire.NoError(t, err)\n\n\t\tdefer func(file *os.File) {\n\t\t\terr := file.Close()\n\t\t\trequire.NoError(t, err)\n\t\t\terr = os.Remove(file.Name())\n\t\t\trequire.NoError(t, err)\n\t\t}(tempFile)\n\t\terr = c.SaveFile(fh, tempFile.Name())\n\t\trequire.NoError(t, err)\n\n\t\tbs, err := os.ReadFile(tempFile.Name())\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"hello world\", string(bs))\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\trequire.NoError(t, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_SaveFileToStorage\nfunc Test_Ctx_SaveFileToStorage(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tstorage := memory.New()\n\n\tapp.Post(\"/test\", func(c Ctx) error {\n\t\tfh, err := c.FormFile(\"file\")\n\t\trequire.NoError(t, err)\n\n\t\terr = c.SaveFileToStorage(fh, \"test\", storage)\n\t\trequire.NoError(t, err)\n\n\t\tfile, err := storage.Get(\"test\")\n\t\trequire.Equal(t, []byte(\"hello world\"), file)\n\t\trequire.NoError(t, err)\n\n\t\terr = storage.Delete(\"test\")\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\n\tioWriter, err := writer.CreateFormFile(\"file\", \"test\")\n\trequire.NoError(t, err)\n\n\t_, err = ioWriter.Write([]byte(\"hello world\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, writer.Close())\n\n\treq := httptest.NewRequest(MethodPost, \"/test\", body)\n\treq.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(body.Bytes())))\n\n\tresp, err := app.Test(req)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Secure\nfunc Test_Ctx_Secure(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t// TODO Add TLS conn\n\trequire.False(t, c.Secure())\n}\n\n// go test -run Test_Ctx_Stale\nfunc Test_Ctx_Stale(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.True(t, c.Stale())\n}\n\n// go test -run Test_Ctx_Subdomains\nfunc Test_Ctx_Subdomains(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().URI().SetHost(\"john.doe.is.awesome.google.com\")\n\trequire.Equal(t, []string{\"john\", \"doe\"}, c.Subdomains(4))\n\n\tc.Request().URI().SetHost(\"localhost:3000\")\n\trequire.Equal(t, []string{\"localhost:3000\"}, c.Subdomains())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Subdomains -benchmem -count=4\nfunc Benchmark_Ctx_Subdomains(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetRequestURI(\"http://john.doe.google.com\")\n\tvar res []string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tres = c.Subdomains()\n\t}\n\trequire.Equal(b, []string{\"john\", \"doe\"}, res)\n}\n\n// go test -run Test_Ctx_ClearCookie\nfunc Test_Ctx_ClearCookie(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderCookie, \"john=doe\")\n\tc.ClearCookie(\"john\")\n\trequire.True(t, strings.HasPrefix(string(c.Response().Header.Peek(HeaderSetCookie)), \"john=; expires=\"))\n\n\tc.Request().Header.Set(HeaderCookie, \"test1=dummy\")\n\tc.Request().Header.Set(HeaderCookie, \"test2=dummy\")\n\tc.ClearCookie()\n\trequire.Contains(t, string(c.Response().Header.Peek(HeaderSetCookie)), \"test1=; expires=\")\n\trequire.Contains(t, string(c.Response().Header.Peek(HeaderSetCookie)), \"test2=; expires=\")\n}\n\n// go test -race -run Test_Ctx_Download\nfunc Test_Ctx_Download(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.NoError(t, c.Download(\"ctx.go\", \"Awesome File!\"))\n\n\tf, err := os.Open(\"./ctx.go\")\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\trequire.NoError(t, f.Close())\n\t}()\n\n\texpect, err := io.ReadAll(f)\n\trequire.NoError(t, err)\n\trequire.Equal(t, expect, c.Response().Body())\n\trequire.Equal(t, `attachment; filename=\"Awesome+File%21\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n\n\trequire.NoError(t, c.Download(\"ctx.go\"))\n\trequire.Equal(t, `attachment; filename=\"ctx.go\"`, string(c.Response().Header.Peek(HeaderContentDisposition)))\n}\n\n// go test -race -run Test_Ctx_SendFile\nfunc Test_Ctx_SendFile(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// fetch file content\n\tf, err := os.Open(\"./ctx.go\")\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\trequire.NoError(t, f.Close())\n\t}()\n\texpectFileContent, err := io.ReadAll(f)\n\trequire.NoError(t, err)\n\t// fetch file info for the not modified test case\n\tfI, err := os.Stat(\"./ctx.go\")\n\trequire.NoError(t, err)\n\n\t// simple test case\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"ctx.go\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectFileContent, c.Response().Body())\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n\n\t// test with custom error code\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.Status(StatusInternalServerError).SendFile(\"ctx.go\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectFileContent, c.Response().Body())\n\trequire.Equal(t, StatusInternalServerError, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n\n\t// test not modified\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(HeaderIfModifiedSince, fI.ModTime().Format(time.RFC1123))\n\terr = c.SendFile(\"ctx.go\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusNotModified, c.Response().StatusCode())\n\trequire.Equal(t, []byte(nil), c.Response().Body())\n\tapp.ReleaseCtx(c)\n}\n\n// go test -race -run Test_Ctx_SendFile_ContentType\nfunc Test_Ctx_SendFile_ContentType(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// 1) simple case\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr := c.SendFile(\"./.github/testdata/fs/img/fiber.png\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\trequire.Equal(t, \"image/png\", string(c.Response().Header.Peek(HeaderContentType)))\n\tapp.ReleaseCtx(c)\n\n\t// 2) set by valid file extension, not file header\n\t// see: https://github.com/valyala/fasthttp/blob/d795f13985f16622a949ea9fc3459cf54dc78b3e/fs.go#L1638\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"./.github/testdata/fs/img/fiberpng.jpeg\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\trequire.Equal(t, \"image/jpeg\", string(c.Response().Header.Peek(HeaderContentType)))\n\tapp.ReleaseCtx(c)\n\n\t// 3) set by file header if extension is invalid\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"./.github/testdata/fs/img/fiberpng.notvalidext\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\trequire.Equal(t, \"image/png\", string(c.Response().Header.Peek(HeaderContentType)))\n\tapp.ReleaseCtx(c)\n\n\t// 4) set by file header if extension is missing\n\tc = app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"./.github/testdata/fs/img/fiberpng\")\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\trequire.Equal(t, \"image/png\", string(c.Response().Header.Peek(HeaderContentType)))\n\tapp.ReleaseCtx(c)\n}\n\nfunc Test_Ctx_SendFile_Download(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// fetch file content\n\tf, err := os.Open(\"./ctx.go\")\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\trequire.NoError(t, f.Close())\n\t}()\n\texpectFileContent, err := io.ReadAll(f)\n\trequire.NoError(t, err)\n\t// fetch file info for the not modified test case\n\t_, err = os.Stat(\"./ctx.go\")\n\trequire.NoError(t, err)\n\n\t// simple test case\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"ctx.go\", SendFile{\n\t\tDownload: true,\n\t})\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectFileContent, c.Response().Body())\n\trequire.Equal(t, \"attachment\", string(c.Response().Header.Peek(HeaderContentDisposition)))\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n}\n\nfunc Test_Ctx_SendFile_MaxAge(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// fetch file content\n\tf, err := os.Open(\"./ctx.go\")\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\trequire.NoError(t, f.Close())\n\t}()\n\texpectFileContent, err := io.ReadAll(f)\n\trequire.NoError(t, err)\n\n\t// fetch file info for the not modified test case\n\t_, err = os.Stat(\"./ctx.go\")\n\trequire.NoError(t, err)\n\n\t// simple test case\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\terr = c.SendFile(\"ctx.go\", SendFile{\n\t\tMaxAge: 100,\n\t})\n\n\t// check expectation\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectFileContent, c.Response().Body())\n\trequire.Equal(t, \"public, max-age=100\", string(c.RequestCtx().Response.Header.Peek(HeaderCacheControl)), \"CacheControl Control\")\n\trequire.Equal(t, StatusOK, c.Response().StatusCode())\n\tapp.ReleaseCtx(c)\n}\n\nfunc Test_Static_Compress(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/file\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx.go\", SendFile{\n\t\t\tCompress: true,\n\t\t})\n\t})\n\n\t// Note: deflate is not supported by fasthttp.FS\n\talgorithms := []string{\"zstd\", \"gzip\", \"br\"}\n\tfor _, algo := range algorithms {\n\t\tt.Run(algo+\"_compression\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\treq := httptest.NewRequest(MethodGet, \"/file\", nil)\n\t\t\treq.Header.Set(\"Accept-Encoding\", algo)\n\t\t\tresp, err := app.Test(req, TestConfig{\n\t\t\t\tTimeout:       10 * time.Second,\n\t\t\t\tFailOnTimeout: true,\n\t\t\t})\n\n\t\t\trequire.NoError(t, err, \"app.Test(req)\")\n\t\t\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\t\t\trequire.NotEqual(t, \"58726\", resp.Header.Get(HeaderContentLength))\n\t\t})\n\t}\n}\n\nfunc Test_Ctx_SendFile_Compress_CheckCompressed(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\t// fetch file content\n\tf, err := os.Open(\"./ctx.go\")\n\trequire.NoError(t, err)\n\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, f.Close())\n\t})\n\n\texpectedFileContent, err := io.ReadAll(f)\n\trequire.NoError(t, err)\n\n\tsendFileBodyReader := func(compression string) ([]byte, error) {\n\t\tt.Helper()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tc.Request().Header.Add(HeaderAcceptEncoding, compression)\n\n\t\terr := c.SendFile(\"./ctx.go\", SendFile{\n\t\t\tCompress: true,\n\t\t})\n\n\t\treturn c.Response().Body(), err\n\t}\n\n\tt.Run(\"gzip\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tb, err := sendFileBodyReader(\"gzip\")\n\t\trequire.NoError(t, err)\n\t\tbody, err := fasthttp.AppendGunzipBytes(nil, b)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Equal(t, expectedFileContent, body)\n\t})\n\n\tt.Run(\"zstd\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tb, err := sendFileBodyReader(\"zstd\")\n\t\trequire.NoError(t, err)\n\t\tbody, err := fasthttp.AppendUnzstdBytes(nil, b)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Equal(t, expectedFileContent, body)\n\t})\n\n\tt.Run(\"br\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tb, err := sendFileBodyReader(\"br\")\n\t\trequire.NoError(t, err)\n\t\tbody, err := fasthttp.AppendUnbrotliBytes(nil, b)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Equal(t, expectedFileContent, body)\n\t})\n}\n\n//go:embed ctx.go\nvar embedFile embed.FS\n\nfunc Test_Ctx_SendFile_EmbedFS(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tf, err := os.Open(\"./ctx.go\")\n\trequire.NoError(t, err)\n\n\tdefer func() {\n\t\trequire.NoError(t, f.Close())\n\t}()\n\n\texpectFileContent, err := io.ReadAll(f)\n\trequire.NoError(t, err)\n\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx.go\", SendFile{\n\t\t\tFS: embedFile,\n\t\t})\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, resp.StatusCode)\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, expectFileContent, body)\n}\n\n// go test -race -run Test_Ctx_SendFile_404\nfunc Test_Ctx_SendFile_404(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx12.go\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusNotFound, resp.StatusCode)\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"sendfile: file ctx12.go not found\", string(body))\n}\n\nfunc Test_Ctx_SendFile_Multiple(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\tswitch c.Query(\"file\") {\n\t\tcase \"1\":\n\t\t\treturn c.SendFile(\"ctx.go\")\n\t\tcase \"2\":\n\t\t\treturn c.SendFile(\"app.go\")\n\t\tcase \"3\":\n\t\t\treturn c.SendFile(\"ctx.go\", SendFile{\n\t\t\t\tDownload: true,\n\t\t\t})\n\t\tcase \"4\":\n\t\t\treturn c.SendFile(\"app_test.go\", SendFile{\n\t\t\t\tFS: os.DirFS(\".\"),\n\t\t\t})\n\t\tdefault:\n\t\t\treturn c.SendStatus(StatusNotFound)\n\t\t}\n\t})\n\n\tapp.Get(\"/test2\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx.go\", SendFile{\n\t\t\tDownload: true,\n\t\t})\n\t})\n\n\ttestCases := []struct {\n\t\turl                string\n\t\tbody               string\n\t\tcontentDisposition string\n\t}{\n\t\t{url: \"/test?file=1\", body: \"type DefaultCtx struct\", contentDisposition: \"\"},\n\t\t{url: \"/test?file=2\", body: \"type App struct\", contentDisposition: \"\"},\n\t\t{url: \"/test?file=3\", body: \"type DefaultCtx struct\", contentDisposition: \"attachment\"},\n\t\t{url: \"/test?file=4\", body: \"Test_App_MethodNotAllowed\", contentDisposition: \"\"},\n\t\t{url: \"/test2\", body: \"type DefaultCtx struct\", contentDisposition: \"attachment\"},\n\t\t{url: \"/test2\", body: \"type DefaultCtx struct\", contentDisposition: \"attachment\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, tc.url, nil))\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, StatusOK, resp.StatusCode)\n\t\trequire.Equal(t, tc.contentDisposition, resp.Header.Get(HeaderContentDisposition))\n\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\trequire.NoError(t, err)\n\t\trequire.Contains(t, string(body), tc.body)\n\t}\n\n\tapp.sendfilesMutex.RLock()\n\tdefer app.sendfilesMutex.RUnlock()\n\trequire.Len(t, app.sendfiles, 3)\n}\n\n// go test -race -run Test_Ctx_SendFile_Immutable\nfunc Test_Ctx_SendFile_Immutable(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tvar endpointsForTest []string\n\taddEndpoint := func(file, endpoint string) {\n\t\tendpointsForTest = append(endpointsForTest, endpoint)\n\t\tapp.Get(endpoint, func(c Ctx) error {\n\t\t\tif err := c.SendFile(file); err != nil {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn c.SendStatus(200)\n\t\t})\n\t}\n\n\t// relative paths\n\taddEndpoint(\"./.github/index.html\", \"/relativeWithDot\")\n\taddEndpoint(filepath.FromSlash(\"./.github/index.html\"), \"/relativeOSWithDot\")\n\taddEndpoint(\".github/index.html\", \"/relative\")\n\taddEndpoint(filepath.FromSlash(\".github/index.html\"), \"/relativeOS\")\n\n\t// absolute paths\n\tif path, err := filepath.Abs(\".github/index.html\"); err != nil {\n\t\trequire.NoError(t, err)\n\t} else {\n\t\taddEndpoint(path, \"/absolute\")\n\t\taddEndpoint(filepath.FromSlash(path), \"/absoluteOS\") // os related\n\t}\n\n\tfor _, endpoint := range endpointsForTest {\n\t\tt.Run(endpoint, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// 1st try\n\t\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, endpoint, nil))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, StatusOK, resp.StatusCode)\n\t\t\t// 2nd try\n\t\t\tresp, err = app.Test(httptest.NewRequest(MethodGet, endpoint, nil))\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, StatusOK, resp.StatusCode)\n\t\t})\n\t}\n}\n\n// go test -race -run Test_Ctx_SendFile_RestoreOriginalURL\nfunc Test_Ctx_SendFile_RestoreOriginalURL(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\toriginalURL := utils.CopyString(c.OriginalURL())\n\t\terr := c.SendFile(\"ctx.go\")\n\t\trequire.Equal(t, originalURL, c.OriginalURL())\n\t\treturn err\n\t})\n\n\t_, err1 := app.Test(httptest.NewRequest(MethodGet, \"/?test=true\", nil))\n\t// second request required to confirm with zero allocation\n\t_, err2 := app.Test(httptest.NewRequest(MethodGet, \"/?test=true\", nil))\n\n\trequire.NoError(t, err1)\n\trequire.NoError(t, err2)\n}\n\nfunc Test_SendFile_withRoutes(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/file\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx.go\")\n\t})\n\n\tapp.Get(\"/file/download\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx.go\", SendFile{\n\t\t\tDownload: true,\n\t\t})\n\t})\n\n\tapp.Get(\"/file/fs\", func(c Ctx) error {\n\t\treturn c.SendFile(\"ctx.go\", SendFile{\n\t\t\tFS: os.DirFS(\".\"),\n\t\t})\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/file\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, resp.StatusCode)\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/file/download\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, resp.StatusCode)\n\trequire.Equal(t, \"attachment\", resp.Header.Get(HeaderContentDisposition))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/file/fs\", nil))\n\trequire.NoError(t, err)\n\trequire.Equal(t, StatusOK, resp.StatusCode)\n}\n\nfunc Benchmark_Ctx_SendFile(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.SendFile(\"ctx.go\")\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Contains(b, string(c.Response().Body()), \"type DefaultCtx struct\")\n}\n\n// go test -run Test_Ctx_JSON\nfunc Test_Ctx_JSON(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Error(t, c.JSON(complex(1, 1)))\n\n\t// Test without ctype\n\terr := c.JSON(Map{ // map has no order\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t})\n\trequire.NoError(t, err)\n\trequire.JSONEq(t, `{\"Age\":20,\"Name\":\"Grame\"}`, string(c.Response().Body()))\n\trequire.Equal(t, \"application/json\", string(c.Response().Header.Peek(\"content-type\")))\n\n\t// Test with ctype\n\terr = c.JSON(Map{ // map has no order\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t}, \"application/problem+json\")\n\trequire.NoError(t, err)\n\trequire.JSONEq(t, `{\"Age\":20,\"Name\":\"Grame\"}`, string(c.Response().Body()))\n\trequire.Equal(t, \"application/problem+json\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v any, r string) {\n\t\terr := c.JSON(v)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, r, string(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"null\")\n\ttestEmpty(\"\", `\"\"`)\n\ttestEmpty(0, \"0\")\n\ttestEmpty([]int{}, \"[]\")\n\n\tt.Run(\"custom json encoder\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New(Config{\n\t\t\tJSONEncoder: func(_ any) ([]byte, error) {\n\t\t\t\treturn []byte(`[\"custom\",\"json\"]`), nil\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\terr := c.JSON(Map{ // map has no order\n\t\t\t\"Name\": \"Grame\",\n\t\t\t\"Age\":  20,\n\t\t})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, `[\"custom\",\"json\"]`, string(c.Response().Body()))\n\t\trequire.Equal(t, \"application/json\", string(c.Response().Header.Peek(\"content-type\")))\n\t})\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_JSON -benchmem -count=4\nfunc Benchmark_Ctx_JSON(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSON(data)\n\t}\n\trequire.NoError(b, err)\n\trequire.JSONEq(b, `{\"Name\":\"Grame\",\"Age\":20}`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_CBOR\nfunc Test_Ctx_CBOR(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Error(t, c.CBOR(complex(1, 1)))\n\n\ttype dummyStruct struct {\n\t\tName string\n\t\tAge  int\n\t}\n\n\t// Test without ctype\n\terr := c.CBOR(dummyStruct{ // map has no order\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, `a2644e616d65654772616d656341676514`, hex.EncodeToString(c.Response().Body()))\n\trequire.Equal(t, \"application/cbor\", string(c.Response().Header.Peek(\"content-type\")))\n\n\t// Test with ctype\n\terr = c.CBOR(dummyStruct{ // map has no order\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}, \"application/problem+cbor\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, `a2644e616d65654772616d656341676514`, hex.EncodeToString(c.Response().Body()))\n\trequire.Equal(t, \"application/problem+cbor\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v any, r string) {\n\t\terr := c.CBOR(v)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, r, hex.EncodeToString(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"f6\")\n\ttestEmpty(\"\", `60`)\n\ttestEmpty(0, \"00\")\n\ttestEmpty([]int{}, \"80\")\n\n\t// Test invalid types\n\terr = c.CBOR(make(chan int))\n\trequire.Error(t, err)\n\n\terr = c.CBOR(func() {})\n\trequire.Error(t, err)\n\n\tt.Run(\"custom cbor encoder\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New(Config{\n\t\t\tCBOREncoder: func(_ any) ([]byte, error) {\n\t\t\t\treturn []byte(hex.EncodeToString([]byte(\"random\"))), nil\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\terr := c.CBOR(Map{ // map has no order\n\t\t\t\"Name\": \"Grame\",\n\t\t\t\"Age\":  20,\n\t\t})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, `72616e646f6d`, string(c.Response().Body()))\n\t\trequire.Equal(t, \"application/cbor\", string(c.Response().Header.Peek(\"content-type\")))\n\t})\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_CBOR -benchmem -count=4\nfunc Benchmark_Ctx_CBOR(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.CBOR(data)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, `a2644e616d65654772616d656341676514`, hex.EncodeToString(c.Response().Body()))\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_JSON_Ctype -benchmem -count=4\nfunc Benchmark_Ctx_JSON_Ctype(b *testing.B) {\n\tapp := New()\n\t// TODO: Check extra allocs because of the interface stuff\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSON(data, \"application/problem+json\")\n\t}\n\trequire.NoError(b, err)\n\trequire.JSONEq(b, `{\"Name\":\"Grame\",\"Age\":20}`, string(c.Response().Body()))\n\trequire.Equal(b, \"application/problem+json\", string(c.Response().Header.Peek(\"content-type\")))\n}\n\n// go test -run Test_Ctx_JSONP\nfunc Test_Ctx_JSONP(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Error(t, c.JSONP(complex(1, 1)))\n\n\terr := c.JSONP(Map{\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, `callback({\"Age\":20,\"Name\":\"Grame\"});`, string(c.Response().Body()))\n\trequire.Equal(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n\n\terr = c.JSONP(Map{\n\t\t\"Name\": \"Grame\",\n\t\t\"Age\":  20,\n\t}, \"john\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, `john({\"Age\":20,\"Name\":\"Grame\"});`, string(c.Response().Body()))\n\trequire.Equal(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n\n\tt.Run(\"custom json encoder\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New(Config{\n\t\t\tJSONEncoder: func(_ any) ([]byte, error) {\n\t\t\t\treturn []byte(`[\"custom\",\"json\"]`), nil\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\terr := c.JSONP(Map{ // map has no order\n\t\t\t\"Name\": \"Grame\",\n\t\t\t\"Age\":  20,\n\t\t})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, `callback([\"custom\",\"json\"]);`, string(c.Response().Body()))\n\t\trequire.Equal(t, \"text/javascript; charset=utf-8\", string(c.Response().Header.Peek(\"content-type\")))\n\t})\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_JSONP -benchmem -count=4\nfunc Benchmark_Ctx_JSONP(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\ttype SomeStruct struct {\n\t\tName string\n\t\tAge  uint8\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tcallback := \"emit\"\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.JSONP(data, callback)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, `emit({\"Name\":\"Grame\",\"Age\":20});`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_XML\nfunc Test_Ctx_XML(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\trequire.Error(t, c.JSON(complex(1, 1)))\n\n\ttype xmlResult struct {\n\t\tXMLName xml.Name `xml:\"Users\"`\n\t\tNames   []string `xml:\"Names\"`\n\t\tAges    []int    `xml:\"Ages\"`\n\t}\n\n\terr := c.XML(xmlResult{\n\t\tNames: []string{\"Grame\", \"John\"},\n\t\tAges:  []int{1, 12, 20},\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, `<Users><Names>Grame</Names><Names>John</Names><Ages>1</Ages><Ages>12</Ages><Ages>20</Ages></Users>`, string(c.Response().Body()))\n\trequire.Equal(t, \"application/xml\", string(c.Response().Header.Peek(\"content-type\")))\n\n\ttestEmpty := func(v any, r string) {\n\t\terr := c.XML(v)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, r, string(c.Response().Body()))\n\t}\n\n\ttestEmpty(nil, \"\")\n\ttestEmpty(\"\", `<string></string>`)\n\ttestEmpty(0, \"<int>0</int>\")\n\ttestEmpty([]int{}, \"\")\n\n\tt.Run(\"custom xml encoder\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New(Config{\n\t\t\tXMLEncoder: func(_ any) ([]byte, error) {\n\t\t\t\treturn []byte(`<custom>xml</custom>`), nil\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\ttype xmlResult struct {\n\t\t\tXMLName xml.Name `xml:\"Users\"`\n\t\t\tNames   []string `xml:\"Names\"`\n\t\t\tAges    []int    `xml:\"Ages\"`\n\t\t}\n\n\t\terr := c.XML(xmlResult{\n\t\t\tNames: []string{\"Grame\", \"John\"},\n\t\t\tAges:  []int{1, 12, 20},\n\t\t})\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, `<custom>xml</custom>`, string(c.Response().Body()))\n\t\trequire.Equal(t, \"application/xml\", string(c.Response().Header.Peek(\"content-type\")))\n\t})\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_XML -benchmem -count=4\nfunc Benchmark_Ctx_XML(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\ttype SomeStruct struct {\n\t\tName string `xml:\"Name\"`\n\t\tAge  uint8  `xml:\"Age\"`\n\t}\n\tdata := SomeStruct{\n\t\tName: \"Grame\",\n\t\tAge:  20,\n\t}\n\tvar err error\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.XML(data)\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, `<SomeStruct><Name>Grame</Name><Age>20</Age></SomeStruct>`, string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Links\nfunc Test_Ctx_Links(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Links()\n\trequire.Equal(t, \"\", string(c.Response().Header.Peek(HeaderLink)))\n\n\tc.Links(\n\t\t\"http://api.example.com/users?page=2\", \"next\",\n\t\t\"http://api.example.com/users?page=5\", \"last\",\n\t)\n\trequire.Equal(t, `<http://api.example.com/users?page=2>; rel=\"next\",<http://api.example.com/users?page=5>; rel=\"last\"`, string(c.Response().Header.Peek(HeaderLink)))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Links -benchmem -count=4\nfunc Benchmark_Ctx_Links(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Links(\n\t\t\t\"http://api.example.com/users?page=2\", \"next\",\n\t\t\t\"http://api.example.com/users?page=5\", \"last\",\n\t\t)\n\t}\n}\n\n// go test -run Test_Ctx_Location\nfunc Test_Ctx_Location(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Location(\"http://example.com\")\n\trequire.Equal(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Ctx_Next\nfunc Test_Ctx_Next(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(\"/\", func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\tc.Set(\"X-Next-Result\", \"Works\")\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.Equal(t, \"Works\", resp.Header.Get(\"X-Next-Result\"))\n}\n\n// go test -run Test_Ctx_Next_Error\nfunc Test_Ctx_Next_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(\"/\", func(c Ctx) error {\n\t\tc.Set(\"X-Next-Result\", \"Works\")\n\t\treturn ErrNotFound\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n\trequire.Equal(t, \"Works\", resp.Header.Get(\"X-Next-Result\"))\n}\n\n// go test -run Test_Ctx_Render\nfunc Test_Ctx_Render(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n\n\terr = c.Render(\"./.github/testdata/template-non-exists.html\", nil)\n\trequire.Error(t, err)\n\n\terr = c.Render(\"./.github/testdata/template-invalid.html\", nil)\n\trequire.Error(t, err)\n}\n\nfunc Test_Ctx_RenderWithoutLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: false,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\n\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1><no value></h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\n\tt.Run(\"EmptyBind\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\tc.Locals(\"Title\", \"Hello, World!\")\n\t\terr := c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n\t})\n\n\tt.Run(\"NilBind\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t\tc.Locals(\"Title\", \"Hello, World!\")\n\t\terr := c.Render(\"./.github/testdata/index.tmpl\", nil)\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n\t})\n}\n\nfunc Test_Ctx_RenderWithViewBind(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.ViewBind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(t, err)\n\n\terr = c.Render(\"./.github/testdata/index.tmpl\", Map{})\n\trequire.NoError(t, err)\n\tbuf := bytebufferpool.Get()\n\tbuf.WriteString(\"overwrite\")\n\tdefer bytebufferpool.Put(buf)\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithOverwrittenViewBind(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.ViewBind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(t, err)\n\n\terr = c.Render(\"./.github/testdata/index.tmpl\", Map{\n\t\t\"Title\": \"Hello from Fiber!\",\n\t})\n\trequire.NoError(t, err)\n\n\tbuf := bytebufferpool.Get()\n\tbuf.WriteString(\"overwrite\")\n\tdefer bytebufferpool.Put(buf)\n\n\trequire.Equal(t, \"<h1>Hello from Fiber!</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithViewBindLocals(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.ViewBind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(t, err)\n\n\tc.Locals(\"Summary\", \"Test\")\n\n\terr = c.Render(\"./.github/testdata/template.tmpl\", Map{})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n\n\trequire.Equal(t, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n}\n\nfunc Test_Ctx_RenderWithLocalsAndBinding(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(t, err)\n\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t\tViews:             engine,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"This is a test.\")\n\n\terr = c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderWithLocalsAndViewBind(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(b, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t\tViews:             engine,\n\t})\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.ViewBind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(b, err)\n\tc.Locals(\"Summary\", \"Test\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"template.tmpl\", Map{})\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"<h1>Hello, World! Test</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderLocals(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(b, err)\n\tapp := New(Config{\n\t\tPassLocalsToViews: true,\n\t})\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Locals(\"Title\", \"Hello, World!\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{})\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\nfunc Benchmark_Ctx_RenderViewBind(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(b, err)\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.ViewBind(Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(b, err)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{})\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_RestartRouting\nfunc Test_Ctx_RestartRouting(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tcalls := 0\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\tcalls++\n\t\tif calls < 3 {\n\t\t\treturn c.RestartRouting()\n\t\t}\n\t\treturn nil\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.Equal(t, 3, calls, \"Number of calls\")\n}\n\n// go test -run Test_Ctx_RestartRoutingWithChangedPath\nfunc Test_Ctx_RestartRoutingWithChangedPath(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tvar executedOldHandler, executedNewHandler bool\n\n\tapp.Get(\"/old\", func(c Ctx) error {\n\t\tc.Path(\"/new\")\n\t\treturn c.RestartRouting()\n\t})\n\tapp.Get(\"/old\", func(_ Ctx) error {\n\t\texecutedOldHandler = true\n\t\treturn nil\n\t})\n\tapp.Get(\"/new\", func(_ Ctx) error {\n\t\texecutedNewHandler = true\n\t\treturn nil\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/old\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.False(t, executedOldHandler, \"Executed old handler\")\n\trequire.True(t, executedNewHandler, \"Executed new handler\")\n}\n\n// go test -run Test_Ctx_RestartRoutingWithChangedPathAnd404\nfunc Test_Ctx_RestartRoutingWithChangedPathAndCatchAll(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/new\", func(_ Ctx) error {\n\t\treturn nil\n\t})\n\tapp.Use(func(c Ctx) error {\n\t\tc.Path(\"/new\")\n\t\t// c.Next() would fail this test as a 404 is returned from the next handler\n\t\treturn c.RestartRouting()\n\t})\n\tapp.Use(func(_ Ctx) error {\n\t\treturn ErrNotFound\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"http://example.com/old\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\ntype testTemplateEngine struct {\n\ttemplates *template.Template\n\tpath      string\n}\n\nfunc (t *testTemplateEngine) Render(w io.Writer, name string, bind any, layout ...string) error {\n\tif len(layout) == 0 {\n\t\tif err := t.templates.ExecuteTemplate(w, name, bind); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute template without layout: %w\", err)\n\t\t}\n\t\treturn nil\n\t}\n\tif err := t.templates.ExecuteTemplate(w, name, bind); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template: %w\", err)\n\t}\n\tif err := t.templates.ExecuteTemplate(w, layout[0], bind); err != nil {\n\t\treturn fmt.Errorf(\"failed to execute template with layout: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (t *testTemplateEngine) Load() error {\n\tif t.path == \"\" {\n\t\tt.path = \"testdata\"\n\t}\n\tt.templates = template.Must(template.ParseGlob(\"./.github/\" + t.path + \"/*.tmpl\"))\n\treturn nil\n}\n\n// go test -run Test_Ctx_Render_Engine\nfunc Test_Ctx_Render_Engine(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\trequire.NoError(t, engine.Load())\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Render_Engine_With_View_Layout\nfunc Test_Ctx_Render_Engine_With_View_Layout(t *testing.T) {\n\tt.Parallel()\n\tengine := &testTemplateEngine{}\n\trequire.NoError(t, engine.Load())\n\tapp := New(Config{ViewsLayout: \"main.tmpl\"})\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Render(\"index.tmpl\", Map{\n\t\t\"Title\": \"Hello, World!\",\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello, World!</h1><h1>I'm main</h1>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Render_Engine -benchmem -count=4\nfunc Benchmark_Ctx_Render_Engine(b *testing.B) {\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(b, err)\n\tapp := New()\n\tapp.config.Views = engine\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Render(\"index.tmpl\", Map{\n\t\t\t\"Title\": \"Hello, World!\",\n\t\t})\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"<h1>Hello, World!</h1>\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Get_Location_From_Route -benchmem -count=4\nfunc Benchmark_Ctx_Get_Location_From_Route(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"name\"))\n\t}).Name(\"User\")\n\n\tvar err error\n\tvar location string\n\tfor n := 0; n < b.N; n++ {\n\t\tlocation, err = c.getLocationFromRoute(app.GetRoute(\"User\"), Map{\"name\": \"fiber\"})\n\t}\n\n\trequire.Equal(b, \"/user/fiber\", location)\n\trequire.NoError(b, err)\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name\nfunc Test_Ctx_Get_Location_From_Route_name(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"case insensitive\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\t\treturn c.SendString(c.Params(\"name\"))\n\t\t}).Name(\"User\")\n\n\t\tlocation, err := c.GetRouteURL(\"User\", Map{\"name\": \"fiber\"})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"/user/fiber\", location)\n\n\t\tlocation, err = c.GetRouteURL(\"User\", Map{\"Name\": \"fiber\"})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"/user/fiber\", location)\n\t})\n\n\tt.Run(\"case sensitive\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tapp := New(Config{CaseSensitive: true})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tdefer app.ReleaseCtx(c)\n\t\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\t\treturn c.SendString(c.Params(\"name\"))\n\t\t}).Name(\"User\")\n\n\t\tlocation, err := c.GetRouteURL(\"User\", Map{\"name\": \"fiber\"})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"/user/fiber\", location)\n\n\t\tlocation, err = c.GetRouteURL(\"User\", Map{\"Name\": \"fiber\"})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"/user/\", location)\n\t})\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name_Optional_greedy\nfunc Test_Ctx_Get_Location_From_Route_name_Optional_greedy(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tapp.Get(\"/:phone/*/send/*\", func(c Ctx) error {\n\t\treturn c.SendString(\"Phone: \" + c.Params(\"phone\") + \"\\nFirst Param: \" + c.Params(\"*1\") + \"\\nSecond Param: \" + c.Params(\"*2\"))\n\t}).Name(\"SendSms\")\n\n\tlocation, err := c.GetRouteURL(\"SendSms\", Map{\n\t\t\"phone\": \"23456789\",\n\t\t\"*1\":    \"sms\",\n\t\t\"*2\":    \"test-msg\",\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"/23456789/sms/send/test-msg\", location)\n}\n\n// go test -run Test_Ctx_Get_Location_From_Route_name_Optional_greedy_one_param\nfunc Test_Ctx_Get_Location_From_Route_name_Optional_greedy_one_param(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tapp.Get(\"/:phone/*/send\", func(c Ctx) error {\n\t\treturn c.SendString(\"Phone: \" + c.Params(\"phone\") + \"\\nFirst Param: \" + c.Params(\"*1\"))\n\t}).Name(\"SendSms\")\n\n\tlocation, err := c.GetRouteURL(\"SendSms\", Map{\n\t\t\"phone\": \"23456789\",\n\t\t\"*\":     \"sms\",\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"/23456789/sms/send\", location)\n}\n\ntype errorTemplateEngine struct{}\n\nfunc (errorTemplateEngine) Render(_ io.Writer, _ string, _ any, _ ...string) error {\n\treturn errors.New(\"errorTemplateEngine\")\n}\n\nfunc (errorTemplateEngine) Load() error { return nil }\n\n// go test -run Test_Ctx_Render_Engine_Error\nfunc Test_Ctx_Render_Engine_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.config.Views = errorTemplateEngine{}\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Render(\"index.tmpl\", nil)\n\trequire.Error(t, err)\n}\n\n// go test -run Test_Ctx_Render_Go_Template\nfunc Test_Ctx_Render_Go_Template(t *testing.T) {\n\tt.Parallel()\n\tfile, err := os.CreateTemp(os.TempDir(), \"fiber\")\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\terr := os.Remove(file.Name())\n\t\trequire.NoError(t, err)\n\t}()\n\n\t_, err = file.WriteString(\"template\")\n\trequire.NoError(t, err)\n\n\terr = file.Close()\n\trequire.NoError(t, err)\n\n\tapp := New()\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr = c.Render(file.Name(), nil)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"template\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Send\nfunc Test_Ctx_Send(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.NoError(t, c.Send([]byte(\"Hello, World\")))\n\trequire.NoError(t, c.Send([]byte(\"Don't crash please\")))\n\trequire.NoError(t, c.Send([]byte(\"1337\")))\n\trequire.Equal(t, \"1337\", string(c.Response().Body()))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Send -benchmem -count=4\nfunc Benchmark_Ctx_Send(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tbyt := []byte(\"Hello, World!\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Send(byt)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStatus\nfunc Test_Ctx_SendStatus(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.SendStatus(415)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 415, c.Response().StatusCode())\n\trequire.Equal(t, \"Unsupported Media Type\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendString\nfunc Test_Ctx_SendString(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.SendString(\"Don't crash please\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Don't crash please\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStream\nfunc Test_Ctx_SendStream(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.SendStream(bytes.NewReader([]byte(\"Don't crash please\")))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStream(bytes.NewReader([]byte(\"Don't crash please\")), len([]byte(\"Don't crash please\")))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStream(bufio.NewReader(bytes.NewReader([]byte(\"Hello bufio\"))))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Hello bufio\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_SendStreamWriter\nfunc Test_Ctx_SendStreamWriter(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.SendStreamWriter(func(w *bufio.Writer) {\n\t\tw.WriteString(\"Don't crash please\") //nolint:errcheck, revive // It is fine to ignore the error\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Don't crash please\", string(c.Response().Body()))\n\n\terr = c.SendStreamWriter(func(w *bufio.Writer) {\n\t\tfor lineNum := 1; lineNum <= 5; lineNum++ {\n\t\t\tfmt.Fprintf(w, \"Line %d\\n\", lineNum) //nolint:errcheck, revive // It is fine to ignore the error\n\t\t\tif err := w.Flush(); err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\", string(c.Response().Body()))\n\n\terr = c.SendStreamWriter(func(_ *bufio.Writer) {})\n\trequire.NoError(t, err)\n\trequire.Empty(t, c.Response().Body())\n}\n\n// go test -run Test_Ctx_SendStreamWriter_Interrupted\nfunc Test_Ctx_SendStreamWriter_Interrupted(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendStreamWriter(func(w *bufio.Writer) {\n\t\t\tfor lineNum := 1; lineNum <= 5; lineNum++ {\n\t\t\t\tfmt.Fprintf(w, \"Line %d\\n\", lineNum) //nolint:errcheck // It is fine to ignore the error\n\n\t\t\t\tif err := w.Flush(); err != nil {\n\t\t\t\t\tif lineNum < 3 {\n\t\t\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(400 * time.Millisecond)\n\t\t\t}\n\t\t})\n\t})\n\n\treq := httptest.NewRequest(MethodGet, \"/\", nil)\n\ttestConfig := TestConfig{\n\t\tTimeout:       1 * time.Second,\n\t\tFailOnTimeout: false,\n\t}\n\tresp, err := app.Test(req, testConfig)\n\trequire.NoError(t, err)\n\n\tbody, err := io.ReadAll(resp.Body)\n\tt.Logf(\"%v\", err)\n\trequire.EqualError(t, err, \"unexpected EOF\")\n\n\trequire.Equal(t, \"Line 1\\nLine 2\\nLine 3\\n\", string(body))\n}\n\n// go test -run Test_Ctx_Set\nfunc Test_Ctx_Set(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Set(\"X-1\", \"1\")\n\tc.Set(\"X-2\", \"2\")\n\tc.Set(\"X-3\", \"3\")\n\tc.Set(\"X-3\", \"1337\")\n\trequire.Equal(t, \"1\", string(c.Response().Header.Peek(\"x-1\")))\n\trequire.Equal(t, \"2\", string(c.Response().Header.Peek(\"x-2\")))\n\trequire.Equal(t, \"1337\", string(c.Response().Header.Peek(\"x-3\")))\n}\n\n// go test -run Test_Ctx_Set_Splitter\nfunc Test_Ctx_Set_Splitter(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Set(\"Location\", \"foo\\r\\nSet-Cookie:%20SESSIONID=MaliciousValue\\r\\n\")\n\th := string(c.Response().Header.Peek(\"Location\"))\n\trequire.NotContains(t, h, \"\\r\\n\")\n\n\tc.Set(\"Location\", \"foo\\nSet-Cookie:%20SESSIONID=MaliciousValue\\n\")\n\th = string(c.Response().Header.Peek(\"Location\"))\n\trequire.NotContains(t, h, \"\\n\")\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Set -benchmem -count=4\nfunc Benchmark_Ctx_Set(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tval := \"1431-15132-3423\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Set(HeaderXRequestID, val)\n\t}\n}\n\n// go test -run Test_Ctx_Status\nfunc Test_Ctx_Status(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Status(400)\n\trequire.Equal(t, 400, c.Response().StatusCode())\n\terr := c.Status(415).Send([]byte(\"Hello, World\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 415, c.Response().StatusCode())\n\trequire.Equal(t, \"Hello, World\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_Type\nfunc Test_Ctx_Type(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Type(\".json\")\n\trequire.Equal(t, \"application/json\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\"json\", \"utf-8\")\n\trequire.Equal(t, \"application/json; charset=utf-8\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\".html\")\n\trequire.Equal(t, \"text/html\", string(c.Response().Header.Peek(\"Content-Type\")))\n\n\tc.Type(\"html\", \"utf-8\")\n\trequire.Equal(t, \"text/html; charset=utf-8\", string(c.Response().Header.Peek(\"Content-Type\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Type -benchmem -count=4\nfunc Benchmark_Ctx_Type(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Type(\".json\")\n\t\tc.Type(\"json\")\n\t}\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Type_Charset -benchmem -count=4\nfunc Benchmark_Ctx_Type_Charset(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Type(\".json\", \"utf-8\")\n\t\tc.Type(\"json\", \"utf-8\")\n\t}\n}\n\n// go test -run Test_Ctx_Vary\nfunc Test_Ctx_Vary(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Vary(\"Origin\")\n\tc.Vary(\"User-Agent\")\n\tc.Vary(\"Accept-Encoding\", \"Accept\")\n\trequire.Equal(t, \"Origin, User-Agent, Accept-Encoding, Accept\", string(c.Response().Header.Peek(\"Vary\")))\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Vary -benchmem -count=4\nfunc Benchmark_Ctx_Vary(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Vary(\"Origin\", \"User-Agent\")\n\t}\n}\n\n// go test -run Test_Ctx_Write\nfunc Test_Ctx_Write(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t_, err := c.Write([]byte(\"Hello, \"))\n\trequire.NoError(t, err)\n\t_, err = c.Write([]byte(\"World!\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Write -benchmem -count=4\nfunc Benchmark_Ctx_Write(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tbyt := []byte(\"Hello, World!\")\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\t_, err = c.Write(byt)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -run Test_Ctx_Writef\nfunc Test_Ctx_Writef(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tworld := \"World!\"\n\t_, err := c.Writef(\"Hello, %s\", world)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_Writef -benchmem -count=4\nfunc Benchmark_Ctx_Writef(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tworld := \"World!\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\t_, err = c.Writef(\"Hello, %s\", world)\n\t}\n\trequire.NoError(b, err)\n}\n\n// go test -run Test_Ctx_WriteString\nfunc Test_Ctx_WriteString(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\t_, err := c.WriteString(\"Hello, \")\n\trequire.NoError(t, err)\n\t_, err = c.WriteString(\"World!\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Hello, World!\", string(c.Response().Body()))\n}\n\n// go test -run Test_Ctx_XHR\nfunc Test_Ctx_XHR(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderXRequestedWith, \"XMLHttpRequest\")\n\trequire.True(t, c.XHR())\n}\n\n// go test -run=^$ -bench=Benchmark_Ctx_XHR -benchmem -count=4\nfunc Benchmark_Ctx_XHR(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderXRequestedWith, \"XMLHttpRequest\")\n\tvar equal bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tequal = c.XHR()\n\t}\n\trequire.True(b, equal)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_SendString_B -benchmem -count=4\nfunc Benchmark_Ctx_SendString_B(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tbody := \"Hello, world!\"\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.SendString(body)\n\t}\n\trequire.NoError(b, err)\n\trequire.Equal(b, []byte(\"Hello, world!\"), c.Response().Body())\n}\n\n// go test -run Test_Ctx_Queries -v\nfunc Test_Ctx_Queries(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().SetBody([]byte(``))\n\tc.Request().Header.SetContentType(\"\")\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1&field1=value1&field1=value2&field2=value3&list_a=1&list_a=2&list_a=3&list_b[]=1&list_b[]=2&list_b[]=3&list_c=1,2,3\")\n\n\tqueries := c.Queries()\n\trequire.Equal(t, \"1\", queries[\"id\"])\n\trequire.Equal(t, \"tom\", queries[\"name\"])\n\trequire.Equal(t, \"basketball,football\", queries[\"hobby\"])\n\trequire.Equal(t, \"milo,coke,pepsi\", queries[\"favouriteDrinks\"])\n\trequire.Equal(t, \"\", queries[\"alloc\"])\n\trequire.Equal(t, \"1\", queries[\"no\"])\n\trequire.Equal(t, \"value2\", queries[\"field1\"])\n\trequire.Equal(t, \"value3\", queries[\"field2\"])\n\trequire.Equal(t, \"3\", queries[\"list_a\"])\n\trequire.Equal(t, \"3\", queries[\"list_b[]\"])\n\trequire.Equal(t, \"1,2,3\", queries[\"list_c\"])\n\n\tc.Request().URI().SetQueryString(\"filters.author.name=John&filters.category.name=Technology&filters[customer][name]=Alice&filters[status]=pending\")\n\n\tqueries = c.Queries()\n\trequire.Equal(t, \"John\", queries[\"filters.author.name\"])\n\trequire.Equal(t, \"Technology\", queries[\"filters.category.name\"])\n\trequire.Equal(t, \"Alice\", queries[\"filters[customer][name]\"])\n\trequire.Equal(t, \"pending\", queries[\"filters[status]\"])\n\n\tc.Request().URI().SetQueryString(\"tags=apple,orange,banana&filters[tags]=apple,orange,banana&filters[category][name]=fruits&filters.tags=apple,orange,banana&filters.category.name=fruits\")\n\n\tqueries = c.Queries()\n\trequire.Equal(t, \"apple,orange,banana\", queries[\"tags\"])\n\trequire.Equal(t, \"apple,orange,banana\", queries[\"filters[tags]\"])\n\trequire.Equal(t, \"fruits\", queries[\"filters[category][name]\"])\n\trequire.Equal(t, \"apple,orange,banana\", queries[\"filters.tags\"])\n\trequire.Equal(t, \"fruits\", queries[\"filters.category.name\"])\n\n\tc.Request().URI().SetQueryString(\"filters[tags][0]=apple&filters[tags][1]=orange&filters[tags][2]=banana&filters[category][name]=fruits\")\n\n\tqueries = c.Queries()\n\trequire.Equal(t, \"apple\", queries[\"filters[tags][0]\"])\n\trequire.Equal(t, \"orange\", queries[\"filters[tags][1]\"])\n\trequire.Equal(t, \"banana\", queries[\"filters[tags][2]\"])\n\trequire.Equal(t, \"fruits\", queries[\"filters[category][name]\"])\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_Queries -benchmem -count=4\nfunc Benchmark_Ctx_Queries(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tc.Request().URI().SetQueryString(\"id=1&name=tom&hobby=basketball,football&favouriteDrinks=milo,coke,pepsi&alloc=&no=1\")\n\n\tvar queries map[string]string\n\tfor n := 0; n < b.N; n++ {\n\t\tqueries = c.Queries()\n\t}\n\n\trequire.Equal(b, \"1\", queries[\"id\"])\n\trequire.Equal(b, \"tom\", queries[\"name\"])\n\trequire.Equal(b, \"basketball,football\", queries[\"hobby\"])\n\trequire.Equal(b, \"milo,coke,pepsi\", queries[\"favouriteDrinks\"])\n\trequire.Equal(b, \"\", queries[\"alloc\"])\n\trequire.Equal(b, \"1\", queries[\"no\"])\n}\n\n// go test -run Test_Ctx_BodyStreamWriter\nfunc Test_Ctx_BodyStreamWriter(t *testing.T) {\n\tt.Parallel()\n\tctx := &fasthttp.RequestCtx{}\n\n\tctx.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\tfmt.Fprintf(w, \"body writer line 1\\n\") //nolint: errcheck // It is fine to ignore the error\n\t\tif err := w.Flush(); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t}\n\t\tfmt.Fprintf(w, \"body writer line 2\\n\") //nolint: errcheck // It is fine to ignore the error\n\t})\n\n\trequire.True(t, ctx.IsBodyStream())\n\n\ts := ctx.Response.String()\n\tbr := bufio.NewReader(bytes.NewBufferString(s))\n\tvar resp fasthttp.Response\n\trequire.NoError(t, resp.Read(br))\n\n\tbody := string(resp.Body())\n\texpectedBody := \"body writer line 1\\nbody writer line 2\\n\"\n\trequire.Equal(t, expectedBody, body)\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_BodyStreamWriter -benchmem -count=4\nfunc Benchmark_Ctx_BodyStreamWriter(b *testing.B) {\n\tctx := &fasthttp.RequestCtx{}\n\tuser := []byte(`{\"name\":\"john\"}`)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\tctx.ResetBody()\n\t\tctx.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t_, err = w.Write(user)\n\t\t\t\tif err := w.Flush(); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\trequire.NoError(b, err)\n}\n\nfunc Test_Ctx_String(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\trequire.Equal(t, \"#0000000000000000 - 0.0.0.0:0 <-> 0.0.0.0:0 - GET http:///\", c.String())\n}\n\n// go test -v  -run=^$ -bench=Benchmark_Ctx_String -benchmem -count=4\nfunc Benchmark_Ctx_String(b *testing.B) {\n\tvar str string\n\tapp := New()\n\tctx := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tstr = ctx.String()\n\t}\n\trequire.Equal(b, \"#0000000000000000 - 0.0.0.0:0 <-> 0.0.0.0:0 - GET http:///\", str)\n}\n\n// go test -run Test_Ctx_IsFromLocal_X_Forwarded\nfunc Test_Ctx_IsFromLocal_X_Forwarded(t *testing.T) {\n\tt.Parallel()\n\t// Test unset X-Forwarded-For header.\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t// fasthttp returns \"0.0.0.0\" as IP as there is no remote address.\n\t\trequire.Equal(t, \"0.0.0.0\", c.IP())\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n\t// Test when setting X-Forwarded-For header to localhost \"127.0.0.1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"127.0.0.1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n\t// Test when setting X-Forwarded-For header to localhost \"::1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"::1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n\t// Test when setting X-Forwarded-For to full localhost IPv6 address \"0:0:0:0:0:0:0:1\"\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"0:0:0:0:0:0:0:1\")\n\t\tdefer app.ReleaseCtx(c)\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n\t// Test for a random IP address.\n\t{\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().Header.Set(HeaderXForwardedFor, \"93.46.8.90\")\n\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n}\n\n// go test -run Test_Ctx_IsFromLocal_RemoteAddr\nfunc Test_Ctx_IsFromLocal_RemoteAddr(t *testing.T) {\n\tt.Parallel()\n\n\tlocalIPv4 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\")})\n\tlocalIPv6 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"::1\")})\n\tlocalIPv6long := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"0:0:0:0:0:0:0:1\")})\n\n\tzeroIPv4 := net.Addr(&net.TCPAddr{IP: net.IPv4zero})\n\n\tsomeIPv4 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"93.46.8.90\")})\n\tsomeIPv6 := net.Addr(&net.TCPAddr{IP: net.ParseIP(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")})\n\n\t// Test for the case fasthttp remoteAddr is set to \"127.0.0.1\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(localIPv4)\n\t\tc := app.AcquireCtx(fastCtx)\n\n\t\trequire.Equal(t, \"127.0.0.1\", c.IP())\n\t\trequire.True(t, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"::1\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(localIPv6)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\trequire.Equal(t, \"::1\", c.IP())\n\t\trequire.True(t, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"0:0:0:0:0:0:0:1\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(localIPv6long)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\t// fasthttp should return \"::1\" for \"0:0:0:0:0:0:0:1\".\n\t\t// otherwise IsFromLocal() will break.\n\t\trequire.Equal(t, \"::1\", c.IP())\n\t\trequire.True(t, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"0.0.0.0\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(zeroIPv4)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\trequire.Equal(t, \"0.0.0.0\", c.IP())\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"93.46.8.90\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(someIPv4)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\trequire.Equal(t, \"93.46.8.90\", c.IP())\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n\t// Test for the case fasthttp remoteAddr is set to \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\".\n\t{\n\t\tapp := New()\n\t\tfastCtx := &fasthttp.RequestCtx{}\n\t\tfastCtx.SetRemoteAddr(someIPv6)\n\t\tc := app.AcquireCtx(fastCtx)\n\t\trequire.Equal(t, \"2001:db8:85a3::8a2e:370:7334\", c.IP())\n\t\trequire.False(t, c.IsFromLocal())\n\t}\n}\n\n// go test -run Test_Ctx_extractIPsFromHeader -v\nfunc Test_Ctx_extractIPsFromHeader(t *testing.T) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(\"x-forwarded-for\", \"1.1.1.1,8.8.8.8 , /n, \\n,1.1, a.c, 6.,6., , a,,42.118.81.169,10.0.137.108\")\n\tips := c.IPs()\n\tres := ips[len(ips)-2]\n\trequire.Equal(t, \"42.118.81.169\", res)\n}\n\n// go test -run Test_Ctx_extractIPsFromHeader -v\nfunc Test_Ctx_extractIPsFromHeader_EnableValidateIp(t *testing.T) {\n\tapp := New()\n\tapp.config.EnableIPValidation = true\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\tc.Request().Header.Set(\"x-forwarded-for\", \"1.1.1.1,8.8.8.8 , /n, \\n,1.1, a.c, 6.,6., , a,,42.118.81.169,10.0.137.108\")\n\tips := c.IPs()\n\tres := ips[len(ips)-2]\n\trequire.Equal(t, \"42.118.81.169\", res)\n}\n\n// go test -run Test_Ctx_GetRespHeaders\nfunc Test_Ctx_GetRespHeaders(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Set(\"test\", \"Hello, World 👋!\")\n\tc.Set(\"foo\", \"bar\")\n\tc.Response().Header.Set(\"multi\", \"one\")\n\tc.Response().Header.Add(\"multi\", \"two\")\n\tc.Response().Header.Set(HeaderContentType, \"application/json\")\n\n\trequire.Equal(t, map[string][]string{\n\t\t\"Content-Type\": {\"application/json\"},\n\t\t\"Foo\":          {\"bar\"},\n\t\t\"Multi\":        {\"one\", \"two\"},\n\t\t\"Test\":         {\"Hello, World 👋!\"},\n\t}, c.GetRespHeaders())\n}\n\nfunc Benchmark_Ctx_GetRespHeaders(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Response().Header.Set(\"test\", \"Hello, World 👋!\")\n\tc.Response().Header.Set(\"foo\", \"bar\")\n\tc.Response().Header.Set(HeaderContentType, \"application/json\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar headers map[string][]string\n\tfor n := 0; n < b.N; n++ {\n\t\theaders = c.GetRespHeaders()\n\t}\n\n\trequire.Equal(b, map[string][]string{\n\t\t\"Content-Type\": {\"application/json\"},\n\t\t\"Foo\":          {\"bar\"},\n\t\t\"Test\":         {\"Hello, World 👋!\"},\n\t}, headers)\n}\n\n// go test -run Test_Ctx_GetReqHeaders\nfunc Test_Ctx_GetReqHeaders(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"test\", \"Hello, World 👋!\")\n\tc.Request().Header.Set(\"foo\", \"bar\")\n\tc.Request().Header.Set(\"multi\", \"one\")\n\tc.Request().Header.Add(\"multi\", \"two\")\n\tc.Request().Header.Set(HeaderContentType, \"application/json\")\n\n\trequire.Equal(t, map[string][]string{\n\t\t\"Content-Type\": {\"application/json\"},\n\t\t\"Foo\":          {\"bar\"},\n\t\t\"Test\":         {\"Hello, World 👋!\"},\n\t\t\"Multi\":        {\"one\", \"two\"},\n\t}, c.GetReqHeaders())\n}\n\nfunc Benchmark_Ctx_GetReqHeaders(b *testing.B) {\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(\"test\", \"Hello, World 👋!\")\n\tc.Request().Header.Set(\"foo\", \"bar\")\n\tc.Request().Header.Set(HeaderContentType, \"application/json\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar headers map[string][]string\n\tfor n := 0; n < b.N; n++ {\n\t\theaders = c.GetReqHeaders()\n\t}\n\n\trequire.Equal(b, map[string][]string{\n\t\t\"Content-Type\": {\"application/json\"},\n\t\t\"Foo\":          {\"bar\"},\n\t\t\"Test\":         {\"Hello, World 👋!\"},\n\t}, headers)\n}\n\n// go test -run Test_GenericParseTypeInts\nfunc Test_GenericParseTypeInts(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tints := []genericTypes[int]{\n\t\t{\n\t\t\tvalue: 0,\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: 1,\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: 2,\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: 3,\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: 4,\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: 2147483647,\n\t\t\tstr:   \"2147483647\",\n\t\t},\n\t\t{\n\t\t\tvalue: -2147483648,\n\t\t\tstr:   \"-2147483648\",\n\t\t},\n\t\t{\n\t\t\tvalue: -1,\n\t\t\tstr:   \"-1\",\n\t\t},\n\t}\n\n\tfor _, test := range ints {\n\t\tvar v int\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeInts\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[int](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeInt8s\nfunc Test_GenericParseTypeInt8s(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tint8s := []genericTypes[int8]{\n\t\t{\n\t\t\tvalue: int8(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(math.MaxInt8),\n\t\t\tstr:   strconv.Itoa(math.MaxInt8),\n\t\t},\n\t\t{\n\t\t\tvalue: int8(math.MinInt8),\n\t\t\tstr:   strconv.Itoa(math.MinInt8),\n\t\t},\n\t}\n\n\tfor _, test := range int8s {\n\t\tvar v int8\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeInt8s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[int8](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeInt16s\nfunc Test_GenericParseTypeInt16s(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tint16s := []genericTypes[int16]{\n\t\t{\n\t\t\tvalue: int16(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(math.MaxInt16),\n\t\t\tstr:   strconv.Itoa(math.MaxInt16),\n\t\t},\n\t\t{\n\t\t\tvalue: int16(math.MinInt16),\n\t\t\tstr:   strconv.Itoa(math.MinInt16),\n\t\t},\n\t}\n\n\tfor _, test := range int16s {\n\t\tvar v int16\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeInt16s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[int16](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeInt32s\nfunc Test_GenericParseTypeInt32s(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tint32s := []genericTypes[int32]{\n\t\t{\n\t\t\tvalue: int32(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(math.MaxInt32),\n\t\t\tstr:   strconv.Itoa(math.MaxInt32),\n\t\t},\n\t\t{\n\t\t\tvalue: int32(math.MinInt32),\n\t\t\tstr:   strconv.Itoa(math.MinInt32),\n\t\t},\n\t}\n\n\tfor _, test := range int32s {\n\t\tvar v int32\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeInt32s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[int32](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeInt64s\nfunc Test_GenericParseTypeInt64s(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tint64s := []genericTypes[int64]{\n\t\t{\n\t\t\tvalue: int64(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(math.MaxInt64),\n\t\t\tstr:   strconv.Itoa(math.MaxInt64),\n\t\t},\n\t\t{\n\t\t\tvalue: int64(math.MinInt64),\n\t\t\tstr:   strconv.Itoa(math.MinInt64),\n\t\t},\n\t}\n\n\tfor _, test := range int64s {\n\t\tvar v int64\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeInt64s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[int64](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeUints\nfunc Test_GenericParseTypeUints(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tuints := []genericTypes[uint]{\n\t\t{\n\t\t\tvalue: uint(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tfor _, test := range uints {\n\t\tvar v uint\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeUints\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[uint](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeUints\nfunc Test_GenericParseTypeUint8s(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tuint8s := []genericTypes[uint8]{\n\t\t{\n\t\t\tvalue: uint8(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(math.MaxUint8),\n\t\t\tstr:   strconv.Itoa(math.MaxUint8),\n\t\t},\n\t}\n\n\tfor _, test := range uint8s {\n\t\tvar v uint8\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeUint8s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[uint8](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeUint16s\nfunc Test_GenericParseTypeUint16s(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tuint16s := []genericTypes[uint16]{\n\t\t{\n\t\t\tvalue: uint16(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(math.MaxUint16),\n\t\t\tstr:   strconv.Itoa(math.MaxUint16),\n\t\t},\n\t}\n\n\tfor _, test := range uint16s {\n\t\tvar v uint16\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeUint16s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[uint16](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeUint32s\nfunc Test_GenericParseTypeUint32s(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tuint32s := []genericTypes[uint32]{\n\t\t{\n\t\t\tvalue: uint32(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(math.MaxUint32),\n\t\t\tstr:   strconv.Itoa(math.MaxUint32),\n\t\t},\n\t}\n\n\tfor _, test := range uint32s {\n\t\tvar v uint32\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeUint32s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[uint32](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeUint64s\nfunc Test_GenericParseTypeUint64s(t *testing.T) {\n\tt.Parallel()\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tuint64s := []genericTypes[uint64]{\n\t\t{\n\t\t\tvalue: uint64(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tfor _, test := range uint64s {\n\t\tvar v uint64\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeUint64s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v))\n\t\t\trequire.Equal(t, tt.value, genericParseType[uint64](tt.str, v))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeFloat32s\nfunc Test_GenericParseTypeFloat32s(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tfloat32s := []genericTypes[float32]{\n\t\t{\n\t\t\tvalue: float32(3.1415),\n\t\t\tstr:   \"3.1415\",\n\t\t},\n\t\t{\n\t\t\tvalue: float32(1.234),\n\t\t\tstr:   \"1.234\",\n\t\t},\n\t\t{\n\t\t\tvalue: float32(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: float32(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t}\n\n\tfor _, test := range float32s {\n\t\tvar v float32\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeFloat32s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.InEpsilon(t, tt.value, genericParseType(tt.str, v), epsilon)\n\t\t\trequire.InEpsilon(t, tt.value, genericParseType[float32](tt.str, v), epsilon)\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeFloat64s\nfunc Test_GenericParseTypeFloat64s(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tfloat64s := []genericTypes[float64]{\n\t\t{\n\t\t\tvalue: float64(3.1415),\n\t\t\tstr:   \"3.1415\",\n\t\t},\n\t\t{\n\t\t\tvalue: float64(1.234),\n\t\t\tstr:   \"1.234\",\n\t\t},\n\t\t{\n\t\t\tvalue: float64(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: float64(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t}\n\n\tfor _, test := range float64s {\n\t\tvar v float64\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeFloat64s\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.InEpsilon(t, tt.value, genericParseType(tt.str, v), epsilon)\n\t\t\trequire.InEpsilon(t, tt.value, genericParseType[float64](tt.str, v), epsilon)\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeArrayBytes\nfunc Test_GenericParseTypeArrayBytes(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tarrBytes := []genericTypes[[]byte]{\n\t\t{\n\t\t\tvalue: []byte(\"alex\"),\n\t\t\tstr:   \"alex\",\n\t\t},\n\t\t{\n\t\t\tvalue: []byte(\"32.23\"),\n\t\t\tstr:   \"32.23\",\n\t\t},\n\t\t{\n\t\t\tvalue: []byte(nil),\n\t\t\tstr:   \"\",\n\t\t},\n\t\t{\n\t\t\tvalue: []byte(\"john\"),\n\t\t\tstr:   \"john\",\n\t\t},\n\t}\n\n\tfor _, test := range arrBytes {\n\t\tvar v []byte\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeArrayBytes\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt.value, genericParseType(tt.str, v, []byte(nil)))\n\t\t\trequire.Equal(t, tt.value, genericParseType[[]byte](tt.str, v, []byte(nil)))\n\t\t})\n\t}\n}\n\n// go test -run Test_GenericParseTypeBoolean\nfunc Test_GenericParseTypeBoolean(t *testing.T) {\n\tt.Parallel()\n\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tbools := []genericTypes[bool]{\n\t\t{\n\t\t\tstr:   \"True\",\n\t\t\tvalue: true,\n\t\t},\n\t\t{\n\t\t\tstr:   \"False\",\n\t\t\tvalue: false,\n\t\t},\n\t\t{\n\t\t\tstr:   \"true\",\n\t\t\tvalue: true,\n\t\t},\n\t\t{\n\t\t\tstr:   \"false\",\n\t\t\tvalue: false,\n\t\t},\n\t}\n\n\tfor _, test := range bools {\n\t\tvar v bool\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeBoolean\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tif tt.value {\n\t\t\t\trequire.True(t, genericParseType(tt.str, v))\n\t\t\t\trequire.True(t, genericParseType[bool](tt.str, v))\n\t\t\t} else {\n\t\t\t\trequire.False(t, genericParseType(tt.str, v))\n\t\t\t\trequire.False(t, genericParseType[bool](tt.str, v))\n\t\t\t}\n\t\t})\n\t}\n}\n\n// go test -run Test_Ctx_Drop -v\nfunc Test_Ctx_Drop(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\t// Handler that calls Drop\n\tapp.Get(\"/block-me\", func(c Ctx) error {\n\t\treturn c.Drop()\n\t})\n\n\t// Additional handler that just calls return\n\tapp.Get(\"/no-response\", func(_ Ctx) error {\n\t\treturn nil\n\t})\n\n\t// Test the Drop method\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/block-me\", nil))\n\trequire.Error(t, err)\n\trequire.Nil(t, resp)\n\n\t// Test the no-response handler\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/no-response\", nil))\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, StatusOK, resp.StatusCode)\n\trequire.Equal(t, \"0\", resp.Header.Get(\"Content-Length\"))\n}\n\n// go test -run Test_Ctx_DropWithMiddleware -v\nfunc Test_Ctx_DropWithMiddleware(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\t// Middleware that calls Drop\n\tapp.Use(func(c Ctx) error {\n\t\terr := c.Next()\n\t\tc.Set(\"X-Test\", \"test\")\n\t\treturn err\n\t})\n\n\t// Handler that calls Drop\n\tapp.Get(\"/block-me\", func(c Ctx) error {\n\t\treturn c.Drop()\n\t})\n\n\t// Test the Drop method\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/block-me\", nil))\n\trequire.Error(t, err)\n\trequire.Nil(t, resp)\n}\n\n// go test -run Test_GenericParseTypeString\nfunc Test_GenericParseTypeString(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []string{\"john\", \"doe\", \"hello\", \"fiber\"}\n\n\tfor _, test := range tests {\n\t\tvar v string\n\t\ttt := test\n\t\tt.Run(\"test_genericParseTypeString\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, tt, genericParseType(tt, v))\n\t\t\trequire.Equal(t, tt, genericParseType[string](tt, v))\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_GenericParseTypeInts -benchmem -count=4\nfunc Benchmark_GenericParseTypeInts(b *testing.B) {\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tints := []genericTypes[int]{\n\t\t{\n\t\t\tvalue: 0,\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: 1,\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: 2,\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: 3,\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: 4,\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tint8s := []genericTypes[int8]{\n\t\t{\n\t\t\tvalue: int8(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int8(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tint16s := []genericTypes[int16]{\n\t\t{\n\t\t\tvalue: int16(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int16(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tint32s := []genericTypes[int32]{\n\t\t{\n\t\t\tvalue: int32(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int32(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tint64s := []genericTypes[int64]{\n\t\t{\n\t\t\tvalue: int64(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: int64(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tfor _, test := range ints {\n\t\tb.Run(\"bench_genericParseTypeInts\", func(b *testing.B) {\n\t\t\tvar res int\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range int8s {\n\t\tb.Run(\"benchmark_genericParseTypeInt8s\", func(b *testing.B) {\n\t\t\tvar res int8\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range int16s {\n\t\tb.Run(\"benchmark_genericParseTypeInt16s\", func(b *testing.B) {\n\t\t\tvar res int16\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range int32s {\n\t\tb.Run(\"benchmark_genericParseType32Ints\", func(b *testing.B) {\n\t\t\tvar res int32\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range int64s {\n\t\tb.Run(\"benchmark_genericParseTypeInt64s\", func(b *testing.B) {\n\t\t\tvar res int64\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_GenericParseTypeUints -benchmem -count=4\nfunc Benchmark_GenericParseTypeUints(b *testing.B) {\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tuints := []genericTypes[uint]{\n\t\t{\n\t\t\tvalue: uint(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tuint8s := []genericTypes[uint8]{\n\t\t{\n\t\t\tvalue: uint8(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint8(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tuint16s := []genericTypes[uint16]{\n\t\t{\n\t\t\tvalue: uint16(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint16(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tuint32s := []genericTypes[uint32]{\n\t\t{\n\t\t\tvalue: uint32(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint32(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tuint64s := []genericTypes[uint64]{\n\t\t{\n\t\t\tvalue: uint64(0),\n\t\t\tstr:   \"0\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(1),\n\t\t\tstr:   \"1\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t\t{\n\t\t\tvalue: uint64(4),\n\t\t\tstr:   \"4\",\n\t\t},\n\t}\n\n\tfor _, test := range uints {\n\t\tb.Run(\"benchamark_genericParseTypeUints\", func(b *testing.B) {\n\t\t\tvar res uint\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range uint8s {\n\t\tb.Run(\"benchamark_genericParseTypeUint8s\", func(b *testing.B) {\n\t\t\tvar res uint8\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range uint16s {\n\t\tb.Run(\"benchamark_genericParseTypeUint16s\", func(b *testing.B) {\n\t\t\tvar res uint16\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range uint32s {\n\t\tb.Run(\"benchamark_genericParseTypeUint32s\", func(b *testing.B) {\n\t\t\tvar res uint32\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n\n\tfor _, test := range uint64s {\n\t\tb.Run(\"benchamark_genericParseTypeUint64s\", func(b *testing.B) {\n\t\t\tvar res uint64\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_GenericParseTypeFloats -benchmem -count=4\nfunc Benchmark_GenericParseTypeFloats(b *testing.B) {\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tfloat32s := []genericTypes[float32]{\n\t\t{\n\t\t\tvalue: float32(3.1415),\n\t\t\tstr:   \"3.1415\",\n\t\t},\n\t\t{\n\t\t\tvalue: float32(1.234),\n\t\t\tstr:   \"1.234\",\n\t\t},\n\t\t{\n\t\t\tvalue: float32(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: float32(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t}\n\n\tfloat64s := []genericTypes[float64]{\n\t\t{\n\t\t\tvalue: float64(3.1415),\n\t\t\tstr:   \"3.1415\",\n\t\t},\n\t\t{\n\t\t\tvalue: float64(1.234),\n\t\t\tstr:   \"1.234\",\n\t\t},\n\t\t{\n\t\t\tvalue: float64(2),\n\t\t\tstr:   \"2\",\n\t\t},\n\t\t{\n\t\t\tvalue: float64(3),\n\t\t\tstr:   \"3\",\n\t\t},\n\t}\n\n\tfor _, test := range float32s {\n\t\tb.Run(\"benchmark_genericParseTypeFloat32s\", func(b *testing.B) {\n\t\t\tvar res float32\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.InEpsilon(b, test.value, res, epsilon)\n\t\t})\n\t}\n\n\tfor _, test := range float64s {\n\t\tb.Run(\"benchmark_genericParseTypeFloat32s\", func(b *testing.B) {\n\t\t\tvar res float64\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\trequire.InEpsilon(b, test.value, res, epsilon)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_GenericParseTypeArrayBytes -benchmem -count=4\nfunc Benchmark_GenericParseTypeArrayBytes(b *testing.B) {\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tarrBytes := []genericTypes[[]byte]{\n\t\t{\n\t\t\tvalue: []byte(\"alex\"),\n\t\t\tstr:   \"alex\",\n\t\t},\n\t\t{\n\t\t\tvalue: []byte(\"32.23\"),\n\t\t\tstr:   \"32.23\",\n\t\t},\n\t\t{\n\t\t\tvalue: []byte(nil),\n\t\t\tstr:   \"\",\n\t\t},\n\t\t{\n\t\t\tvalue: []byte(\"john\"),\n\t\t\tstr:   \"john\",\n\t\t},\n\t}\n\n\tfor _, test := range arrBytes {\n\t\tb.Run(\"Benchmark_GenericParseTypeArrayBytes\", func(b *testing.B) {\n\t\t\tvar res []byte\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res, []byte(nil))\n\t\t\t}\n\t\t\trequire.Equal(b, test.value, res)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_GenericParseTypeBoolean -benchmem -count=4\nfunc Benchmark_GenericParseTypeBoolean(b *testing.B) {\n\ttype genericTypes[v GenericType] struct {\n\t\tvalue v\n\t\tstr   string\n\t}\n\n\tbools := []genericTypes[bool]{\n\t\t{\n\t\t\tstr:   \"True\",\n\t\t\tvalue: true,\n\t\t},\n\t\t{\n\t\t\tstr:   \"False\",\n\t\t\tvalue: false,\n\t\t},\n\t\t{\n\t\t\tstr:   \"true\",\n\t\t\tvalue: true,\n\t\t},\n\t\t{\n\t\t\tstr:   \"false\",\n\t\t\tvalue: false,\n\t\t},\n\t}\n\n\tfor _, test := range bools {\n\t\tb.Run(\"Benchmark_GenericParseTypeBoolean\", func(b *testing.B) {\n\t\t\tvar res bool\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test.str, res)\n\t\t\t}\n\t\t\tif test.value {\n\t\t\t\trequire.True(b, res)\n\t\t\t} else {\n\t\t\t\trequire.False(b, res)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_GenericParseTypeString -benchmem -count=4\nfunc Benchmark_GenericParseTypeString(b *testing.B) {\n\ttests := []string{\"john\", \"doe\", \"hello\", \"fiber\"}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor _, test := range tests {\n\t\tb.Run(\"benchmark_genericParseTypeString\", func(b *testing.B) {\n\t\t\tvar res string\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tres = genericParseType(test, res)\n\t\t\t}\n\n\t\t\trequire.Equal(b, test, res)\n\t\t})\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Ctx_IsProxyTrusted -benchmem -count=4\nfunc Benchmark_Ctx_IsProxyTrusted(b *testing.B) {\n\t// Scenario without trusted proxy check\n\tb.Run(\"NoProxyCheck\", func(b *testing.B) {\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com:8080/test\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario without trusted proxy check in parallel\n\tb.Run(\"NoProxyCheckParallel\", func(b *testing.B) {\n\t\tapp := New()\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com:8080/test\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check simple\n\tb.Run(\"WithProxyCheckSimple\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check simple in parallel\n\tb.Run(\"WithProxyCheckSimpleParallel\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check\n\tb.Run(\"WithProxyCheck\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.0\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check in parallel\n\tb.Run(\"WithProxyCheckParallel\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.0\"},\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check allow private\n\tb.Run(\"WithProxyCheckAllowPrivate\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tPrivate: true,\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check allow private in parallel\n\tb.Run(\"WithProxyCheckAllowPrivateParallel\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tPrivate: true,\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check allow private as subnets\n\tb.Run(\"WithProxyCheckAllowPrivateAsSubnets\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\", \"fc00::/7\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check allow private as subnets in parallel\n\tb.Run(\"WithProxyCheckAllowPrivateAsSubnetsParallel\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\", \"fc00::/7\"},\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check allow private, loopback, and link-local\n\tb.Run(\"WithProxyCheckAllowAll\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tPrivate:   true,\n\t\t\t\tLoopback:  true,\n\t\t\t\tLinkLocal: true,\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check allow private, loopback, and link-local in parallel\n\tb.Run(\"WithProxyCheckAllowAllParallel\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tPrivate:   true,\n\t\t\t\tLoopback:  true,\n\t\t\t\tLinkLocal: true,\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check allow private, loopback, and link-local as subnets\n\tb.Run(\"WithProxyCheckAllowAllowAllAsSubnets\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\n\t\t\t\t\t// Link-local\n\t\t\t\t\t\"169.254.0.0/16\",\n\t\t\t\t\t\"fe80::/10\",\n\t\t\t\t\t// Loopback\n\t\t\t\t\t\"127.0.0.0/8\",\n\t\t\t\t\t\"::1/128\",\n\t\t\t\t\t// Private\n\t\t\t\t\t\"10.0.0.0/8\",\n\t\t\t\t\t\"172.16.0.0/12\",\n\t\t\t\t\t\"192.168.0.0/16\",\n\t\t\t\t\t\"fc00::/7\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check allow private, loopback, and link-local as subnets in parallel\n\tb.Run(\"WithProxyCheckAllowAllowAllAsSubnetsParallel\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\n\t\t\t\t\t// Link-local\n\t\t\t\t\t\"169.254.0.0/16\",\n\t\t\t\t\t\"fe80::/10\",\n\t\t\t\t\t// Loopback\n\t\t\t\t\t\"127.0.0.0/8\",\n\t\t\t\t\t\"::1/128\",\n\t\t\t\t\t// Private\n\t\t\t\t\t\"10.0.0.0/8\",\n\t\t\t\t\t\"172.16.0.0/12\",\n\t\t\t\t\t\"192.168.0.0/16\",\n\t\t\t\t\t\"fc00::/7\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check with subnet\n\tb.Run(\"WithProxyCheckSubnet\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.0/8\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check with subnet in parallel\n\tb.Run(\"WithProxyCheckParallelSubnet\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"0.0.0.0/8\"},\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check with multiple subnet\n\tb.Run(\"WithProxyCheckMultipleSubnet\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"192.168.0.0/24\", \"10.0.0.0/16\", \"0.0.0.0/8\"},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check with multiple subnet in parallel\n\tb.Run(\"WithProxyCheckParallelMultipleSubnet\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\"192.168.0.0/24\", \"10.0.0.0/16\", \"0.0.0.0/8\"},\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with trusted proxy check with all subnets\n\tb.Run(\"WithProxyCheckAllSubnets\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\n\t\t\t\t\t\"127.0.0.0/8\",     // Loopback addresses\n\t\t\t\t\t\"169.254.0.0/16\",  // Link-Local addresses\n\t\t\t\t\t\"fe80::/10\",       // Link-Local addresses\n\t\t\t\t\t\"192.168.0.0/16\",  // Private Network addresses\n\t\t\t\t\t\"172.16.0.0/12\",   // Private Network addresses\n\t\t\t\t\t\"10.0.0.0/8\",      // Private Network addresses\n\t\t\t\t\t\"fc00::/7\",        // Unique Local addresses\n\t\t\t\t\t\"173.245.48.0/20\", // My custom range\n\t\t\t\t\t\"0.0.0.0/8\",       // All IPv4 addresses\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com/test\")\n\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsProxyTrusted()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with trusted proxy check with all subnets in parallel\n\tb.Run(\"WithProxyCheckParallelAllSubnets\", func(b *testing.B) {\n\t\tapp := New(Config{\n\t\t\tTrustProxy: true,\n\t\t\tTrustProxyConfig: TrustProxyConfig{\n\t\t\t\tProxies: []string{\n\t\t\t\t\t\"127.0.0.0/8\",     // Loopback addresses\n\t\t\t\t\t\"169.254.0.0/16\",  // Link-Local addresses\n\t\t\t\t\t\"fe80::/10\",       // Link-Local addresses\n\t\t\t\t\t\"192.168.0.0/16\",  // Private Network addresses\n\t\t\t\t\t\"172.16.0.0/12\",   // Private Network addresses\n\t\t\t\t\t\"10.0.0.0/8\",      // Private Network addresses\n\t\t\t\t\t\"fc00::/7\",        // Unique Local addresses\n\t\t\t\t\t\"173.245.48.0/20\", // My custom range\n\t\t\t\t\t\"0.0.0.0/8\",       // All IPv4 addresses\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com/\")\n\t\t\tc.Request().Header.Set(HeaderXForwardedHost, \"google1.com\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsProxyTrusted()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n}\n\nfunc Benchmark_Ctx_IsFromLocalhost(b *testing.B) {\n\t// Scenario without localhost check\n\tb.Run(\"Non_Localhost\", func(b *testing.B) {\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://google.com:8080/test\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsFromLocal()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario without localhost check in parallel\n\tb.Run(\"Non_Localhost_Parallel\", func(b *testing.B) {\n\t\tapp := New()\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://google.com:8080/test\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsFromLocal()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n\n\t// Scenario with localhost check\n\tb.Run(\"Localhost\", func(b *testing.B) {\n\t\tapp := New()\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\tc.Request().SetRequestURI(\"http://localhost:8080/test\")\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.IsFromLocal()\n\t\t}\n\t\tapp.ReleaseCtx(c)\n\t})\n\n\t// Scenario with localhost check in parallel\n\tb.Run(\"Localhost_Parallel\", func(b *testing.B) {\n\t\tapp := New()\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\t\t\tc.Request().SetRequestURI(\"http://localhost:8080/test\")\n\t\t\tfor pb.Next() {\n\t\t\t\tc.IsFromLocal()\n\t\t\t}\n\t\t\tapp.ReleaseCtx(c)\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 2.76,
          "content": "package fiber\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\n\t\"github.com/gofiber/schema\"\n)\n\n// Wrap and return this for unreachable code if panicking is undesirable (i.e., in a handler).\n// Unexported because users will hopefully never need to see it.\nvar errUnreachable = errors.New(\"fiber: unreachable code, please create an issue at github.com/gofiber/fiber\")\n\n// General errors\nvar (\n\tErrGracefulTimeout = errors.New(\"shutdown: graceful timeout has been reached, exiting\")\n\t// ErrNotRunning indicates that a Shutdown method was called when the server was not running.\n\tErrNotRunning = errors.New(\"shutdown: server is not running\")\n\t// ErrHandlerExited is returned by App.Test if a handler panics or calls runtime.Goexit().\n\tErrHandlerExited = errors.New(\"runtime.Goexit() called in handler or server panic\")\n)\n\n// Fiber redirection errors\nvar (\n\tErrRedirectBackNoFallback = NewError(StatusInternalServerError, \"Referer not found, you have to enter fallback URL for redirection.\")\n)\n\n// Range errors\nvar (\n\tErrRangeMalformed     = errors.New(\"range: malformed range header string\")\n\tErrRangeUnsatisfiable = errors.New(\"range: unsatisfiable range\")\n)\n\n// Binder errors\nvar ErrCustomBinderNotFound = errors.New(\"binder: custom binder not found, please be sure to enter the right name\")\n\n// Format errors\nvar (\n\t// ErrNoHandlers is returned when c.Format is called with no arguments.\n\tErrNoHandlers = errors.New(\"format: at least one handler is required, but none were set\")\n)\n\n// gorilla/schema errors\ntype (\n\t// ConversionError Conversion error exposes the internal schema.ConversionError for public use.\n\tConversionError = schema.ConversionError\n\t// UnknownKeyError error exposes the internal schema.UnknownKeyError for public use.\n\tUnknownKeyError = schema.UnknownKeyError\n\t// EmptyFieldError error exposes the internal schema.EmptyFieldError for public use.\n\tEmptyFieldError = schema.EmptyFieldError\n\t// MultiError error exposes the internal schema.MultiError for public use.\n\tMultiError = schema.MultiError\n)\n\n// encoding/json errors\ntype (\n\t// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\n\t// (The argument to Unmarshal must be a non-nil pointer.)\n\tInvalidUnmarshalError = json.InvalidUnmarshalError\n\n\t// A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.\n\tMarshalerError = json.MarshalerError\n\n\t// A SyntaxError is a description of a JSON syntax error.\n\tSyntaxError = json.SyntaxError\n\n\t// An UnmarshalTypeError describes a JSON value that was\n\t// not appropriate for a value of a specific Go type.\n\tUnmarshalTypeError = json.UnmarshalTypeError\n\n\t// An UnsupportedTypeError is returned by Marshal when attempting\n\t// to encode an unsupported value type.\n\tUnsupportedTypeError = json.UnsupportedTypeError\n\n\tUnsupportedValueError = json.UnsupportedValueError\n)\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 1.6,
          "content": "package fiber\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/gofiber/schema\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc Test_ConversionError(t *testing.T) {\n\tt.Parallel()\n\tok := errors.As(ConversionError{}, &schema.ConversionError{})\n\trequire.True(t, ok)\n}\n\nfunc Test_UnknownKeyError(t *testing.T) {\n\tt.Parallel()\n\tok := errors.As(UnknownKeyError{}, &schema.UnknownKeyError{})\n\trequire.True(t, ok)\n}\n\nfunc Test_EmptyFieldError(t *testing.T) {\n\tt.Parallel()\n\tok := errors.As(EmptyFieldError{}, &schema.EmptyFieldError{})\n\trequire.True(t, ok)\n}\n\nfunc Test_MultiError(t *testing.T) {\n\tt.Parallel()\n\tok := errors.As(MultiError{}, &schema.MultiError{})\n\trequire.True(t, ok)\n}\n\nfunc Test_InvalidUnmarshalError(t *testing.T) {\n\tt.Parallel()\n\tvar e *json.InvalidUnmarshalError\n\tok := errors.As(&InvalidUnmarshalError{}, &e)\n\trequire.True(t, ok)\n}\n\nfunc Test_MarshalerError(t *testing.T) {\n\tt.Parallel()\n\tvar e *json.MarshalerError\n\tok := errors.As(&MarshalerError{}, &e)\n\trequire.True(t, ok)\n}\n\nfunc Test_SyntaxError(t *testing.T) {\n\tt.Parallel()\n\tvar e *json.SyntaxError\n\tok := errors.As(&SyntaxError{}, &e)\n\trequire.True(t, ok)\n}\n\nfunc Test_UnmarshalTypeError(t *testing.T) {\n\tt.Parallel()\n\tvar e *json.UnmarshalTypeError\n\tok := errors.As(&UnmarshalTypeError{}, &e)\n\trequire.True(t, ok)\n}\n\nfunc Test_UnsupportedTypeError(t *testing.T) {\n\tt.Parallel()\n\tvar e *json.UnsupportedTypeError\n\tok := errors.As(&UnsupportedTypeError{}, &e)\n\trequire.True(t, ok)\n}\n\nfunc Test_UnsupportedValeError(t *testing.T) {\n\tt.Parallel()\n\tvar e *json.UnsupportedValueError\n\tok := errors.As(&UnsupportedValueError{}, &e)\n\trequire.True(t, ok)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.97,
          "content": "module github.com/gofiber/fiber/v3\n\ngo 1.23\n\nrequire (\n\tgithub.com/gofiber/schema v1.2.0\n\tgithub.com/gofiber/utils/v2 v2.0.0-beta.7\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/tinylib/msgp v1.2.5\n\tgithub.com/valyala/bytebufferpool v1.0.0\n\tgithub.com/valyala/fasthttp v1.58.0\n\tgolang.org/x/crypto v0.32.0\n)\n\nrequire (\n\tgithub.com/andybalholm/brotli v1.1.1 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/fxamacker/cbor/v2 v2.7.0 // direct\n\tgithub.com/klauspost/compress v1.17.11 // indirect\n\tgithub.com/philhofer/fwd v1.1.3-0.20240916144458-20a13a1f6b7c // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/valyala/tcplisten v1.0.0 // indirect\n\tgithub.com/x448/float16 v0.8.4 // indirect\n\tgolang.org/x/net v0.31.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.35,
          "content": "github.com/andybalholm/brotli v1.1.1 h1:PR2pgnyFznKEugtsUo0xLdDop5SKXd5Qf5ysW+7XdTA=\ngithub.com/andybalholm/brotli v1.1.1/go.mod h1:05ib4cKhjx3OQYUY22hTVd34Bc8upXjOLL2rKwwZBoA=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fxamacker/cbor/v2 v2.7.0 h1:iM5WgngdRBanHcxugY4JySA0nk1wZorNOpTgCMedv5E=\ngithub.com/fxamacker/cbor/v2 v2.7.0/go.mod h1:pxXPTn3joSm21Gbwsv0w9OSA2y1HFR9qXEeXQVeNoDQ=\ngithub.com/gofiber/schema v1.2.0 h1:j+ZRrNnUa/0ZuWrn/6kAtAufEr4jCJ+JuTURAMxNSZg=\ngithub.com/gofiber/schema v1.2.0/go.mod h1:YYwj01w3hVfaNjhtJzaqetymL56VW642YS3qZPhuE6c=\ngithub.com/gofiber/utils/v2 v2.0.0-beta.7 h1:NnHFrRHvhrufPABdWajcKZejz9HnCWmT/asoxRsiEbQ=\ngithub.com/gofiber/utils/v2 v2.0.0-beta.7/go.mod h1:J/M03s+HMdZdvhAeyh76xT72IfVqBzuz/OJkrMa7cwU=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=\ngithub.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/philhofer/fwd v1.1.3-0.20240916144458-20a13a1f6b7c h1:dAMKvw0MlJT1GshSTtih8C2gDs04w8dReiOGXrGLNoY=\ngithub.com/philhofer/fwd v1.1.3-0.20240916144458-20a13a1f6b7c/go.mod h1:RqIHx9QI14HlwKwm98g9Re5prTQ6LdeRQn+gXJFxsJM=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/tinylib/msgp v1.2.5 h1:WeQg1whrXRFiZusidTQqzETkRpGjFjcIhW6uqWH09po=\ngithub.com/tinylib/msgp v1.2.5/go.mod h1:ykjzy2wzgrlvpDCRc4LA8UXy6D8bzMSuAF3WD57Gok0=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasthttp v1.58.0 h1:GGB2dWxSbEprU9j0iMJHgdKYJVDyjrOwF9RE59PbRuE=\ngithub.com/valyala/fasthttp v1.58.0/go.mod h1:SYXvHHaFp7QZHGKSHmoMipInhrI5StHrhDTYVEjK/Kw=\ngithub.com/valyala/tcplisten v1.0.0 h1:rBHj/Xf+E1tRGZyWIWwJDiRY0zc1Js+CV5DqwacVSA8=\ngithub.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=\ngithub.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=\ngithub.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=\ngithub.com/xyproto/randomstring v1.0.5 h1:YtlWPoRdgMu3NZtP45drfy1GKoojuR7hmRcnhZqKjWU=\ngithub.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=\ngolang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=\ngolang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 6.48,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Group struct\ntype Group struct {\n\tapp         *App\n\tparentGroup *Group\n\tname        string\n\n\tPrefix          string\n\tanyRouteDefined bool\n}\n\n// Name Assign name to specific route or group itself.\n//\n// If this method is used before any route added to group, it'll set group name and OnGroupNameHook will be used.\n// Otherwise, it'll set route name and OnName hook will be used.\nfunc (grp *Group) Name(name string) Router {\n\tif grp.anyRouteDefined {\n\t\tgrp.app.Name(name)\n\n\t\treturn grp\n\t}\n\n\tgrp.app.mutex.Lock()\n\tif grp.parentGroup != nil {\n\t\tgrp.name = grp.parentGroup.name + name\n\t} else {\n\t\tgrp.name = name\n\t}\n\n\tif err := grp.app.hooks.executeOnGroupNameHooks(*grp); err != nil {\n\t\tpanic(err)\n\t}\n\tgrp.app.mutex.Unlock()\n\n\treturn grp\n}\n\n// Use registers a middleware route that will match requests\n// with the provided prefix (which is optional and defaults to \"/\").\n// Also, you can pass another app instance as a sub-router along a routing path.\n// It's very useful to split up a large API as many independent routers and\n// compose them as a single service using Use. The fiber's error handler and\n// any of the fiber's sub apps are added to the application's error handlers\n// to be invoked on errors that happen within the prefix route.\n//\n//\t\tapp.Use(func(c fiber.Ctx) error {\n//\t\t     return c.Next()\n//\t\t})\n//\t\tapp.Use(\"/api\", func(c fiber.Ctx) error {\n//\t\t     return c.Next()\n//\t\t})\n//\t\tapp.Use(\"/api\", handler, func(c fiber.Ctx) error {\n//\t\t     return c.Next()\n//\t\t})\n//\t \tsubApp := fiber.New()\n//\t\tapp.Use(\"/mounted-path\", subApp)\n//\n// This method will match all HTTP verbs: GET, POST, PUT, HEAD etc...\nfunc (grp *Group) Use(args ...any) Router {\n\tvar subApp *App\n\tvar prefix string\n\tvar prefixes []string\n\tvar handlers []Handler\n\n\tfor i := 0; i < len(args); i++ {\n\t\tswitch arg := args[i].(type) {\n\t\tcase string:\n\t\t\tprefix = arg\n\t\tcase *App:\n\t\t\tsubApp = arg\n\t\tcase []string:\n\t\t\tprefixes = arg\n\t\tcase Handler:\n\t\t\thandlers = append(handlers, arg)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"use: invalid handler %v\\n\", reflect.TypeOf(arg)))\n\t\t}\n\t}\n\n\tif len(prefixes) == 0 {\n\t\tprefixes = append(prefixes, prefix)\n\t}\n\n\tfor _, prefix := range prefixes {\n\t\tif subApp != nil {\n\t\t\tgrp.mount(prefix, subApp)\n\t\t\treturn grp\n\t\t}\n\n\t\tgrp.app.register([]string{methodUse}, getGroupPath(grp.Prefix, prefix), grp, nil, handlers...)\n\t}\n\n\tif !grp.anyRouteDefined {\n\t\tgrp.anyRouteDefined = true\n\t}\n\n\treturn grp\n}\n\n// Get registers a route for GET methods that requests a representation\n// of the specified resource. Requests using GET should only retrieve data.\nfunc (grp *Group) Get(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodGet}, path, handler, middleware...)\n}\n\n// Head registers a route for HEAD methods that asks for a response identical\n// to that of a GET request, but without the response body.\nfunc (grp *Group) Head(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodHead}, path, handler, middleware...)\n}\n\n// Post registers a route for POST methods that is used to submit an entity to the\n// specified resource, often causing a change in state or side effects on the server.\nfunc (grp *Group) Post(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodPost}, path, handler, middleware...)\n}\n\n// Put registers a route for PUT methods that replaces all current representations\n// of the target resource with the request payload.\nfunc (grp *Group) Put(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodPut}, path, handler, middleware...)\n}\n\n// Delete registers a route for DELETE methods that deletes the specified resource.\nfunc (grp *Group) Delete(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodDelete}, path, handler, middleware...)\n}\n\n// Connect registers a route for CONNECT methods that establishes a tunnel to the\n// server identified by the target resource.\nfunc (grp *Group) Connect(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodConnect}, path, handler, middleware...)\n}\n\n// Options registers a route for OPTIONS methods that is used to describe the\n// communication options for the target resource.\nfunc (grp *Group) Options(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodOptions}, path, handler, middleware...)\n}\n\n// Trace registers a route for TRACE methods that performs a message loop-back\n// test along the path to the target resource.\nfunc (grp *Group) Trace(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodTrace}, path, handler, middleware...)\n}\n\n// Patch registers a route for PATCH methods that is used to apply partial\n// modifications to a resource.\nfunc (grp *Group) Patch(path string, handler Handler, middleware ...Handler) Router {\n\treturn grp.Add([]string{MethodPatch}, path, handler, middleware...)\n}\n\n// Add allows you to specify multiple HTTP methods to register a route.\nfunc (grp *Group) Add(methods []string, path string, handler Handler, middleware ...Handler) Router {\n\tgrp.app.register(methods, getGroupPath(grp.Prefix, path), grp, handler, middleware...)\n\tif !grp.anyRouteDefined {\n\t\tgrp.anyRouteDefined = true\n\t}\n\n\treturn grp\n}\n\n// All will register the handler on all HTTP methods\nfunc (grp *Group) All(path string, handler Handler, middleware ...Handler) Router {\n\t_ = grp.Add(grp.app.config.RequestMethods, path, handler, middleware...)\n\treturn grp\n}\n\n// Group is used for Routes with common prefix to define a new sub-router with optional middleware.\n//\n//\tapi := app.Group(\"/api\")\n//\tapi.Get(\"/users\", handler)\nfunc (grp *Group) Group(prefix string, handlers ...Handler) Router {\n\tprefix = getGroupPath(grp.Prefix, prefix)\n\tif len(handlers) > 0 {\n\t\tgrp.app.register([]string{methodUse}, prefix, grp, nil, handlers...)\n\t}\n\n\t// Create new group\n\tnewGrp := &Group{Prefix: prefix, app: grp.app, parentGroup: grp}\n\tif err := grp.app.hooks.executeOnGroupHooks(*newGrp); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn newGrp\n}\n\n// Route is used to define routes with a common prefix inside the common function.\n// Uses Group method to define new sub-router.\nfunc (grp *Group) Route(path string) Register {\n\t// Create new group\n\tregister := &Registering{app: grp.app, path: getGroupPath(grp.Prefix, path)}\n\n\treturn register\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 22.87,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/gofiber/fiber/v3/log\"\n\t\"github.com/gofiber/utils/v2\"\n\n\t\"github.com/valyala/bytebufferpool\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// acceptedType is a struct that holds the parsed value of an Accept header\n// along with quality, specificity, parameters, and order.\n// Used for sorting accept headers.\ntype acceptedType struct {\n\tparams      headerParams\n\tspec        string\n\tquality     float64\n\tspecificity int\n\torder       int\n}\n\ntype headerParams map[string][]byte\n\n// getTLSConfig returns a net listener's tls config\nfunc getTLSConfig(ln net.Listener) *tls.Config {\n\t// Get listener type\n\tpointer := reflect.ValueOf(ln)\n\n\t// Is it a tls.listener?\n\tif pointer.String() != \"<*tls.listener Value>\" {\n\t\treturn nil\n\t}\n\n\t// Copy value from pointer\n\tif val := reflect.Indirect(pointer); val.Type() != nil {\n\t\t// Get private field from value\n\t\tif field := val.FieldByName(\"config\"); field.Type() != nil {\n\t\t\t// Copy value from pointer field (unsafe)\n\t\t\tnewval := reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())) //nolint:gosec // Probably the only way to extract the *tls.Config from a net.Listener. TODO: Verify there really is no easier way without using unsafe.\n\t\t\tif newval.Type() == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Get element from pointer\n\t\t\tif elem := newval.Elem(); elem.Type() != nil {\n\t\t\t\t// Cast value to *tls.Config\n\t\t\t\tc, ok := elem.Interface().(*tls.Config)\n\t\t\t\tif !ok {\n\t\t\t\t\tpanic(errors.New(\"failed to type-assert to *tls.Config\"))\n\t\t\t\t}\n\t\t\t\treturn c\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// readContent opens a named file and read content from it\nfunc readContent(rf io.ReaderFrom, name string) (int64, error) {\n\t// Read file\n\tf, err := os.Open(filepath.Clean(name))\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to open: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err = f.Close(); err != nil {\n\t\t\tlog.Errorf(\"Error closing file: %s\", err)\n\t\t}\n\t}()\n\tif n, err := rf.ReadFrom(f); err != nil {\n\t\treturn n, fmt.Errorf(\"failed to read: %w\", err)\n\t}\n\treturn 0, nil\n}\n\n// quoteString escape special characters in a given string\nfunc (app *App) quoteString(raw string) string {\n\tbb := bytebufferpool.Get()\n\tquoted := app.getString(fasthttp.AppendQuotedArg(bb.B, app.getBytes(raw)))\n\tbytebufferpool.Put(bb)\n\treturn quoted\n}\n\n// Scan stack if other methods match the request\nfunc (app *App) methodExist(c *DefaultCtx) bool {\n\tvar exists bool\n\n\tmethods := app.config.RequestMethods\n\tfor i := 0; i < len(methods); i++ {\n\t\t// Skip original method\n\t\tif c.getMethodINT() == i {\n\t\t\tcontinue\n\t\t}\n\t\t// Reset stack index\n\t\tc.setIndexRoute(-1)\n\n\t\ttree, ok := c.App().treeStack[i][c.getTreePath()]\n\t\tif !ok {\n\t\t\ttree = c.App().treeStack[i][\"\"]\n\t\t}\n\t\t// Get stack length\n\t\tlenr := len(tree) - 1\n\t\t// Loop over the route stack starting from previous index\n\t\tfor c.getIndexRoute() < lenr {\n\t\t\t// Increment route index\n\t\t\tc.setIndexRoute(c.getIndexRoute() + 1)\n\t\t\t// Get *Route\n\t\t\troute := tree[c.getIndexRoute()]\n\t\t\t// Skip use routes\n\t\t\tif route.use {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Check if it matches the request path\n\t\t\tmatch := route.match(c.getDetectionPath(), c.Path(), c.getValues())\n\t\t\t// No match, next route\n\t\t\tif match {\n\t\t\t\t// We matched\n\t\t\t\texists = true\n\t\t\t\t// Add method to Allow header\n\t\t\t\tc.Append(HeaderAllow, methods[i])\n\t\t\t\t// Break stack loop\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn exists\n}\n\n// Scan stack if other methods match the request\nfunc (app *App) methodExistCustom(c CustomCtx) bool {\n\tvar exists bool\n\tmethods := app.config.RequestMethods\n\tfor i := 0; i < len(methods); i++ {\n\t\t// Skip original method\n\t\tif c.getMethodINT() == i {\n\t\t\tcontinue\n\t\t}\n\t\t// Reset stack index\n\t\tc.setIndexRoute(-1)\n\n\t\ttree, ok := c.App().treeStack[i][c.getTreePath()]\n\t\tif !ok {\n\t\t\ttree = c.App().treeStack[i][\"\"]\n\t\t}\n\t\t// Get stack length\n\t\tlenr := len(tree) - 1\n\t\t// Loop over the route stack starting from previous index\n\t\tfor c.getIndexRoute() < lenr {\n\t\t\t// Increment route index\n\t\t\tc.setIndexRoute(c.getIndexRoute() + 1)\n\t\t\t// Get *Route\n\t\t\troute := tree[c.getIndexRoute()]\n\t\t\t// Skip use routes\n\t\t\tif route.use {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Check if it matches the request path\n\t\t\tmatch := route.match(c.getDetectionPath(), c.Path(), c.getValues())\n\t\t\t// No match, next route\n\t\t\tif match {\n\t\t\t\t// We matched\n\t\t\t\texists = true\n\t\t\t\t// Add method to Allow header\n\t\t\t\tc.Append(HeaderAllow, methods[i])\n\t\t\t\t// Break stack loop\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn exists\n}\n\n// uniqueRouteStack drop all not unique routes from the slice\nfunc uniqueRouteStack(stack []*Route) []*Route {\n\tvar unique []*Route\n\tm := make(map[*Route]int)\n\tfor _, v := range stack {\n\t\tif _, ok := m[v]; !ok {\n\t\t\t// Unique key found. Record position and collect\n\t\t\t// in result.\n\t\t\tm[v] = len(unique)\n\t\t\tunique = append(unique, v)\n\t\t}\n\t}\n\n\treturn unique\n}\n\n// defaultString returns the value or a default value if it is set\nfunc defaultString(value string, defaultValue []string) string {\n\tif len(value) == 0 && len(defaultValue) > 0 {\n\t\treturn defaultValue[0]\n\t}\n\treturn value\n}\n\nfunc getGroupPath(prefix, path string) string {\n\tif len(path) == 0 {\n\t\treturn prefix\n\t}\n\n\tif path[0] != '/' {\n\t\tpath = \"/\" + path\n\t}\n\n\treturn utils.TrimRight(prefix, '/') + path\n}\n\n// acceptsOffer This function determines if an offer matches a given specification.\n// It checks if the specification ends with a '*' or if the offer has the prefix of the specification.\n// Returns true if the offer matches the specification, false otherwise.\nfunc acceptsOffer(spec, offer string, _ headerParams) bool {\n\tif len(spec) >= 1 && spec[len(spec)-1] == '*' {\n\t\treturn true\n\t} else if strings.HasPrefix(spec, offer) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// acceptsOfferType This function determines if an offer type matches a given specification.\n// It checks if the specification is equal to */* (i.e., all types are accepted).\n// It gets the MIME type of the offer (either from the offer itself or by its file extension).\n// It checks if the offer MIME type matches the specification MIME type or if the specification is of the form <MIME_type>/* and the offer MIME type has the same MIME type.\n// It checks if the offer contains every parameter present in the specification.\n// Returns true if the offer type matches the specification, false otherwise.\nfunc acceptsOfferType(spec, offerType string, specParams headerParams) bool {\n\tvar offerMime, offerParams string\n\n\tif i := strings.IndexByte(offerType, ';'); i == -1 {\n\t\tofferMime = offerType\n\t} else {\n\t\tofferMime = offerType[:i]\n\t\tofferParams = offerType[i:]\n\t}\n\n\t// Accept: */*\n\tif spec == \"*/*\" {\n\t\treturn paramsMatch(specParams, offerParams)\n\t}\n\n\tvar mimetype string\n\tif strings.IndexByte(offerMime, '/') != -1 {\n\t\tmimetype = offerMime // MIME type\n\t} else {\n\t\tmimetype = utils.GetMIME(offerMime) // extension\n\t}\n\n\tif spec == mimetype {\n\t\t// Accept: <MIME_type>/<MIME_subtype>\n\t\treturn paramsMatch(specParams, offerParams)\n\t}\n\n\ts := strings.IndexByte(mimetype, '/')\n\t// Accept: <MIME_type>/*\n\tif strings.HasPrefix(spec, mimetype[:s]) && (spec[s:] == \"/*\" || mimetype[s:] == \"/*\") {\n\t\treturn paramsMatch(specParams, offerParams)\n\t}\n\n\treturn false\n}\n\n// paramsMatch returns whether offerParams contains all parameters present in specParams.\n// Matching is case insensitive, and surrounding quotes are stripped.\n// To align with the behavior of res.format from Express, the order of parameters is\n// ignored, and if a parameter is specified twice in the incoming Accept, the last\n// provided value is given precedence.\n// In the case of quoted values, RFC 9110 says that we must treat any character escaped\n// by a backslash as equivalent to the character itself (e.g., \"a\\aa\" is equivalent to \"aaa\").\n// For the sake of simplicity, we forgo this and compare the value as-is. Besides, it would\n// be highly unusual for a client to escape something other than a double quote or backslash.\n// See https://www.rfc-editor.org/rfc/rfc9110#name-parameters\nfunc paramsMatch(specParamStr headerParams, offerParams string) bool {\n\tif len(specParamStr) == 0 {\n\t\treturn true\n\t}\n\n\tallSpecParamsMatch := true\n\tfor specParam, specVal := range specParamStr {\n\t\tfoundParam := false\n\t\tfasthttp.VisitHeaderParams(utils.UnsafeBytes(offerParams), func(key, value []byte) bool {\n\t\t\tif utils.EqualFold(specParam, utils.UnsafeString(key)) {\n\t\t\t\tfoundParam = true\n\t\t\t\tallSpecParamsMatch = utils.EqualFold(specVal, value)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tif !foundParam || !allSpecParamsMatch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn allSpecParamsMatch\n}\n\n// getSplicedStrList function takes a string and a string slice as an argument, divides the string into different\n// elements divided by ',' and stores these elements in the string slice.\n// It returns the populated string slice as an output.\n//\n// If the given slice hasn't enough space, it will allocate more and return.\nfunc getSplicedStrList(headerValue string, dst []string) []string {\n\tif headerValue == \"\" {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\tindex             int\n\t\tcharacter         rune\n\t\tlastElementEndsAt int\n\t\tinsertIndex       int\n\t)\n\tfor index, character = range headerValue + \"$\" {\n\t\tif character == ',' || index == len(headerValue) {\n\t\t\tif insertIndex >= len(dst) {\n\t\t\t\toldSlice := dst\n\t\t\t\tdst = make([]string, len(dst)+(len(dst)>>1)+2)\n\t\t\t\tcopy(dst, oldSlice)\n\t\t\t}\n\t\t\tdst[insertIndex] = utils.TrimLeft(headerValue[lastElementEndsAt:index], ' ')\n\t\t\tlastElementEndsAt = index + 1\n\t\t\tinsertIndex++\n\t\t}\n\t}\n\n\tif len(dst) > insertIndex {\n\t\tdst = dst[:insertIndex]\n\t}\n\treturn dst\n}\n\n// forEachMediaRange parses an Accept or Content-Type header, calling functor\n// on each media range.\n// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\nfunc forEachMediaRange(header []byte, functor func([]byte)) {\n\thasDQuote := bytes.IndexByte(header, '\"') != -1\n\n\tfor len(header) > 0 {\n\t\tn := 0\n\t\theader = utils.TrimLeft(header, ' ')\n\t\tquotes := 0\n\t\tescaping := false\n\n\t\tif hasDQuote {\n\t\t\t// Complex case. We need to keep track of quotes and quoted-pairs (i.e.,  characters escaped with \\ )\n\t\tloop:\n\t\t\tfor n < len(header) {\n\t\t\t\tswitch header[n] {\n\t\t\t\tcase ',':\n\t\t\t\t\tif quotes%2 == 0 {\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\t}\n\t\t\t\tcase '\"':\n\t\t\t\t\tif !escaping {\n\t\t\t\t\t\tquotes++\n\t\t\t\t\t}\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tif quotes%2 == 1 {\n\t\t\t\t\t\tescaping = !escaping\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tn++\n\t\t\t}\n\t\t} else {\n\t\t\t// Simple case. Just look for the next comma.\n\t\t\tif n = bytes.IndexByte(header, ','); n == -1 {\n\t\t\t\tn = len(header)\n\t\t\t}\n\t\t}\n\n\t\tfunctor(header[:n])\n\n\t\tif n >= len(header) {\n\t\t\treturn\n\t\t}\n\t\theader = header[n+1:]\n\t}\n}\n\n// Pool for headerParams instances. The headerParams object *must*\n// be cleared before being returned to the pool.\nvar headerParamPool = sync.Pool{\n\tNew: func() any {\n\t\treturn make(headerParams)\n\t},\n}\n\n// getOffer return valid offer for header negotiation.\n// Do not pass header using utils.UnsafeBytes - this can cause a panic due\n// to the use of utils.ToLowerBytes.\nfunc getOffer(header []byte, isAccepted func(spec, offer string, specParams headerParams) bool, offers ...string) string {\n\tif len(offers) == 0 {\n\t\treturn \"\"\n\t}\n\tif len(header) == 0 {\n\t\treturn offers[0]\n\t}\n\n\tacceptedTypes := make([]acceptedType, 0, 8)\n\torder := 0\n\n\t// Parse header and get accepted types with their quality and specificity\n\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n\tforEachMediaRange(header, func(accept []byte) {\n\t\torder++\n\t\tspec, quality := accept, 1.0\n\t\tvar params headerParams\n\n\t\tif i := bytes.IndexByte(accept, ';'); i != -1 {\n\t\t\tspec = accept[:i]\n\n\t\t\t// Optimized quality parsing\n\t\t\tqIndex := i + 3\n\t\t\tif bytes.HasPrefix(accept[i:], []byte(\";q=\")) && bytes.IndexByte(accept[qIndex:], ';') == -1 {\n\t\t\t\tif q, err := fasthttp.ParseUfloat(accept[qIndex:]); err == nil {\n\t\t\t\t\tquality = q\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparams, _ = headerParamPool.Get().(headerParams) //nolint:errcheck // only contains headerParams\n\t\t\t\tfor k := range params {\n\t\t\t\t\tdelete(params, k)\n\t\t\t\t}\n\t\t\t\tfasthttp.VisitHeaderParams(accept[i:], func(key, value []byte) bool {\n\t\t\t\t\tif len(key) == 1 && key[0] == 'q' {\n\t\t\t\t\t\tif q, err := fasthttp.ParseUfloat(value); err == nil {\n\t\t\t\t\t\t\tquality = q\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tlowerKey := utils.UnsafeString(utils.ToLowerBytes(key))\n\t\t\t\t\tparams[lowerKey] = value\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// Skip this accept type if quality is 0.0\n\t\t\t// See: https://www.rfc-editor.org/rfc/rfc9110#quality.values\n\t\t\tif quality == 0.0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tspec = utils.Trim(spec, ' ')\n\n\t\t// Determine specificity\n\t\tvar specificity int\n\n\t\t// check for wildcard this could be a mime */* or a wildcard character *\n\t\tswitch {\n\t\tcase len(spec) == 1 && spec[0] == '*':\n\t\t\tspecificity = 1\n\t\tcase bytes.Equal(spec, []byte(\"*/*\")):\n\t\t\tspecificity = 1\n\t\tcase bytes.HasSuffix(spec, []byte(\"/*\")):\n\t\t\tspecificity = 2\n\t\tcase bytes.IndexByte(spec, '/') != -1:\n\t\t\tspecificity = 3\n\t\tdefault:\n\t\t\tspecificity = 4\n\t\t}\n\n\t\t// Add to accepted types\n\t\tacceptedTypes = append(acceptedTypes, acceptedType{\n\t\t\tspec:        utils.UnsafeString(spec),\n\t\t\tquality:     quality,\n\t\t\tspecificity: specificity,\n\t\t\torder:       order,\n\t\t\tparams:      params,\n\t\t})\n\t})\n\n\tif len(acceptedTypes) > 1 {\n\t\t// Sort accepted types by quality and specificity, preserving order of equal elements\n\t\tsortAcceptedTypes(&acceptedTypes)\n\t}\n\n\t// Find the first offer that matches the accepted types\n\tfor _, acceptedType := range acceptedTypes {\n\t\tfor _, offer := range offers {\n\t\t\tif offer == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif isAccepted(acceptedType.spec, offer, acceptedType.params) {\n\t\t\t\tif acceptedType.params != nil {\n\t\t\t\t\theaderParamPool.Put(acceptedType.params)\n\t\t\t\t}\n\t\t\t\treturn offer\n\t\t\t}\n\t\t}\n\t\tif acceptedType.params != nil {\n\t\t\theaderParamPool.Put(acceptedType.params)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n// sortAcceptedTypes sorts accepted types by quality and specificity, preserving order of equal elements\n// A type with parameters has higher priority than an equivalent one without parameters.\n// e.g., text/html;a=1;b=2 comes before text/html;a=1\n// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\nfunc sortAcceptedTypes(acceptedTypes *[]acceptedType) {\n\tif acceptedTypes == nil || len(*acceptedTypes) < 2 {\n\t\treturn\n\t}\n\tat := *acceptedTypes\n\n\tfor i := 1; i < len(at); i++ {\n\t\tlo, hi := 0, i-1\n\t\tfor lo <= hi {\n\t\t\tmid := (lo + hi) / 2\n\t\t\tif at[i].quality < at[mid].quality ||\n\t\t\t\t(at[i].quality == at[mid].quality && at[i].specificity < at[mid].specificity) ||\n\t\t\t\t(at[i].quality == at[mid].quality && at[i].specificity < at[mid].specificity && len(at[i].params) < len(at[mid].params)) ||\n\t\t\t\t(at[i].quality == at[mid].quality && at[i].specificity == at[mid].specificity && len(at[i].params) == len(at[mid].params) && at[i].order > at[mid].order) {\n\t\t\t\tlo = mid + 1\n\t\t\t} else {\n\t\t\t\thi = mid - 1\n\t\t\t}\n\t\t}\n\t\tfor j := i; j > lo; j-- {\n\t\t\tat[j-1], at[j] = at[j], at[j-1]\n\t\t}\n\t}\n}\n\nfunc matchEtag(s, etag string) bool {\n\tif s == etag || s == \"W/\"+etag || \"W/\"+s == etag {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (app *App) isEtagStale(etag string, noneMatchBytes []byte) bool {\n\tvar start, end int\n\n\t// Adapted from:\n\t// https://github.com/jshttp/fresh/blob/10e0471669dbbfbfd8de65bc6efac2ddd0bfa057/index.js#L110\n\tfor i := range noneMatchBytes {\n\t\tswitch noneMatchBytes[i] {\n\t\tcase 0x20:\n\t\t\tif start == end {\n\t\t\t\tstart = i + 1\n\t\t\t\tend = i + 1\n\t\t\t}\n\t\tcase 0x2c:\n\t\t\tif matchEtag(app.getString(noneMatchBytes[start:end]), etag) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tstart = i + 1\n\t\t\tend = i + 1\n\t\tdefault:\n\t\t\tend = i + 1\n\t\t}\n\t}\n\n\treturn !matchEtag(app.getString(noneMatchBytes[start:end]), etag)\n}\n\nfunc parseAddr(raw string) (string, string) { //nolint:revive // Returns (host, port)\n\tif i := strings.LastIndex(raw, \":\"); i != -1 {\n\t\treturn raw[:i], raw[i+1:]\n\t}\n\treturn raw, \"\"\n}\n\nconst noCacheValue = \"no-cache\"\n\n// isNoCache checks if the cacheControl header value is a `no-cache`.\nfunc isNoCache(cacheControl string) bool {\n\ti := strings.Index(cacheControl, noCacheValue)\n\tif i == -1 {\n\t\treturn false\n\t}\n\n\t// Xno-cache\n\tif i > 0 && !(cacheControl[i-1] == ' ' || cacheControl[i-1] == ',') {\n\t\treturn false\n\t}\n\n\t// bla bla, no-cache\n\tif i+len(noCacheValue) == len(cacheControl) {\n\t\treturn true\n\t}\n\n\t// bla bla, no-cacheX\n\tif cacheControl[i+len(noCacheValue)] != ',' {\n\t\treturn false\n\t}\n\n\t// OK\n\treturn true\n}\n\ntype testConn struct {\n\tr        bytes.Buffer\n\tw        bytes.Buffer\n\tisClosed bool\n\tsync.Mutex\n}\n\nfunc (c *testConn) Read(b []byte) (int, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\treturn c.r.Read(b) //nolint:wrapcheck // This must not be wrapped\n}\n\nfunc (c *testConn) Write(b []byte) (int, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif c.isClosed {\n\t\treturn 0, errors.New(\"testConn is closed\")\n\t}\n\treturn c.w.Write(b) //nolint:wrapcheck // This must not be wrapped\n}\n\nfunc (c *testConn) Close() error {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tc.isClosed = true\n\treturn nil\n}\n\nfunc (*testConn) LocalAddr() net.Addr                { return &net.TCPAddr{Port: 0, Zone: \"\", IP: net.IPv4zero} }\nfunc (*testConn) RemoteAddr() net.Addr               { return &net.TCPAddr{Port: 0, Zone: \"\", IP: net.IPv4zero} }\nfunc (*testConn) SetDeadline(_ time.Time) error      { return nil }\nfunc (*testConn) SetReadDeadline(_ time.Time) error  { return nil }\nfunc (*testConn) SetWriteDeadline(_ time.Time) error { return nil }\n\nfunc getStringImmutable(b []byte) string {\n\treturn string(b)\n}\n\nfunc getBytesImmutable(s string) []byte {\n\treturn []byte(s)\n}\n\n// HTTP methods and their unique INTs\nfunc (app *App) methodInt(s string) int {\n\t// For better performance\n\tif len(app.configured.RequestMethods) == 0 {\n\t\t// TODO: Use iota instead\n\t\tswitch s {\n\t\tcase MethodGet:\n\t\t\treturn 0\n\t\tcase MethodHead:\n\t\t\treturn 1\n\t\tcase MethodPost:\n\t\t\treturn 2\n\t\tcase MethodPut:\n\t\t\treturn 3\n\t\tcase MethodDelete:\n\t\t\treturn 4\n\t\tcase MethodConnect:\n\t\t\treturn 5\n\t\tcase MethodOptions:\n\t\t\treturn 6\n\t\tcase MethodTrace:\n\t\t\treturn 7\n\t\tcase MethodPatch:\n\t\t\treturn 8\n\t\tdefault:\n\t\t\treturn -1\n\t\t}\n\t}\n\n\t// For method customization\n\tfor i, v := range app.config.RequestMethods {\n\t\tif s == v {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// IsMethodSafe reports whether the HTTP method is considered safe.\n// See https://datatracker.ietf.org/doc/html/rfc9110#section-9.2.1\nfunc IsMethodSafe(m string) bool {\n\tswitch m {\n\tcase MethodGet,\n\t\tMethodHead,\n\t\tMethodOptions,\n\t\tMethodTrace:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// IsMethodIdempotent reports whether the HTTP method is considered idempotent.\n// See https://datatracker.ietf.org/doc/html/rfc9110#section-9.2.2\nfunc IsMethodIdempotent(m string) bool {\n\tif IsMethodSafe(m) {\n\t\treturn true\n\t}\n\n\tswitch m {\n\tcase MethodPut, MethodDelete:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc IndexRune(str string, needle int32) bool {\n\tfor _, b := range str {\n\t\tif b == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Convert a string value to a specified type, handling errors and optional default values.\nfunc Convert[T any](value string, convertor func(string) (T, error), defaultValue ...T) (T, error) {\n\tconverted, err := convertor(value)\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0], nil\n\t\t}\n\n\t\treturn converted, fmt.Errorf(\"failed to convert: %w\", err)\n\t}\n\n\treturn converted, nil\n}\n\n// assertValueType asserts the type of the result to the type of the value\nfunc assertValueType[V GenericType, T any](result T) V {\n\tv, ok := any(result).(V)\n\tif !ok {\n\t\tpanic(fmt.Errorf(\"failed to type-assert to %T\", v))\n\t}\n\treturn v\n}\n\nfunc genericParseDefault[V GenericType](err error, parser func() V, defaultValue ...V) V {\n\tvar v V\n\tif err != nil {\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn v\n\t}\n\treturn parser()\n}\n\nfunc genericParseInt[V GenericType](str string, bitSize int, parser func(int64) V, defaultValue ...V) V {\n\tresult, err := strconv.ParseInt(str, 10, bitSize)\n\treturn genericParseDefault[V](err, func() V { return parser(result) }, defaultValue...)\n}\n\nfunc genericParseUint[V GenericType](str string, bitSize int, parser func(uint64) V, defaultValue ...V) V {\n\tresult, err := strconv.ParseUint(str, 10, bitSize)\n\treturn genericParseDefault[V](err, func() V { return parser(result) }, defaultValue...)\n}\n\nfunc genericParseFloat[V GenericType](str string, bitSize int, parser func(float64) V, defaultValue ...V) V {\n\tresult, err := strconv.ParseFloat(str, bitSize)\n\treturn genericParseDefault[V](err, func() V { return parser(result) }, defaultValue...)\n}\n\nfunc genericParseBool[V GenericType](str string, parser func(bool) V, defaultValue ...V) V {\n\tresult, err := strconv.ParseBool(str)\n\treturn genericParseDefault[V](err, func() V { return parser(result) }, defaultValue...)\n}\n\n//nolint:gosec // Casting in this function is not a concern\nfunc genericParseType[V GenericType](str string, v V, defaultValue ...V) V {\n\tswitch any(v).(type) {\n\tcase int:\n\t\treturn genericParseInt[V](str, 0, func(i int64) V { return assertValueType[V, int](int(i)) }, defaultValue...)\n\tcase int8:\n\t\treturn genericParseInt[V](str, 8, func(i int64) V { return assertValueType[V, int8](int8(i)) }, defaultValue...)\n\tcase int16:\n\t\treturn genericParseInt[V](str, 16, func(i int64) V { return assertValueType[V, int16](int16(i)) }, defaultValue...)\n\tcase int32:\n\t\treturn genericParseInt[V](str, 32, func(i int64) V { return assertValueType[V, int32](int32(i)) }, defaultValue...)\n\tcase int64:\n\t\treturn genericParseInt[V](str, 64, func(i int64) V { return assertValueType[V, int64](i) }, defaultValue...)\n\tcase uint:\n\t\treturn genericParseUint[V](str, 32, func(i uint64) V { return assertValueType[V, uint](uint(i)) }, defaultValue...)\n\tcase uint8:\n\t\treturn genericParseUint[V](str, 8, func(i uint64) V { return assertValueType[V, uint8](uint8(i)) }, defaultValue...)\n\tcase uint16:\n\t\treturn genericParseUint[V](str, 16, func(i uint64) V { return assertValueType[V, uint16](uint16(i)) }, defaultValue...)\n\tcase uint32:\n\t\treturn genericParseUint[V](str, 32, func(i uint64) V { return assertValueType[V, uint32](uint32(i)) }, defaultValue...)\n\tcase uint64:\n\t\treturn genericParseUint[V](str, 64, func(i uint64) V { return assertValueType[V, uint64](i) }, defaultValue...)\n\tcase float32:\n\t\treturn genericParseFloat[V](str, 32, func(i float64) V { return assertValueType[V, float32](float32(i)) }, defaultValue...)\n\tcase float64:\n\t\treturn genericParseFloat[V](str, 64, func(i float64) V { return assertValueType[V, float64](i) }, defaultValue...)\n\tcase bool:\n\t\treturn genericParseBool[V](str, func(b bool) V { return assertValueType[V, bool](b) }, defaultValue...)\n\tcase string:\n\t\tif str == \"\" && len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn assertValueType[V, string](str)\n\tcase []byte:\n\t\tif str == \"\" && len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn assertValueType[V, []byte]([]byte(str))\n\tdefault:\n\t\tif len(defaultValue) > 0 {\n\t\t\treturn defaultValue[0]\n\t\t}\n\t\treturn v\n\t}\n}\n\ntype GenericType interface {\n\tGenericTypeInteger | GenericTypeFloat | bool | string | []byte\n}\n\ntype GenericTypeInteger interface {\n\tGenericTypeIntegerSigned | GenericTypeIntegerUnsigned\n}\n\ntype GenericTypeIntegerSigned interface {\n\tint | int8 | int16 | int32 | int64\n}\n\ntype GenericTypeIntegerUnsigned interface {\n\tuint | uint8 | uint16 | uint32 | uint64\n}\n\ntype GenericTypeFloat interface {\n\tfloat32 | float64\n}\n"
        },
        {
          "name": "helpers_fuzz_test.go",
          "type": "blob",
          "size": 0.6,
          "content": "//go:build go1.18\n\npackage fiber\n\nimport (\n\t\"testing\"\n)\n\n// go test -v -run=^$ -fuzz=FuzzUtilsGetOffer\nfunc FuzzUtilsGetOffer(f *testing.F) {\n\tinputs := []string{\n\t\t`application/json; v=1; foo=bar; q=0.938; extra=param, text/plain;param=\"big fox\"; q=0.43`,\n\t\t`text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8`,\n\t\t`*/*`,\n\t\t`text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c`,\n\t}\n\tfor _, input := range inputs {\n\t\tf.Add(input)\n\t}\n\tf.Fuzz(func(_ *testing.T, spec string) {\n\t\tgetOffer([]byte(spec), acceptsOfferType, `application/json;version=1;v=1;foo=bar`, `text/plain;param=\"big fox\"`)\n\t})\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 20.73,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📝 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc Test_Utils_GetOffer(t *testing.T) {\n\tt.Parallel()\n\trequire.Equal(t, \"\", getOffer([]byte(\"hello\"), acceptsOffer))\n\trequire.Equal(t, \"1\", getOffer([]byte(\"\"), acceptsOffer, \"1\"))\n\trequire.Equal(t, \"\", getOffer([]byte(\"2\"), acceptsOffer, \"1\"))\n\n\trequire.Equal(t, \"\", getOffer([]byte(\"\"), acceptsOfferType))\n\trequire.Equal(t, \"\", getOffer([]byte(\"text/html\"), acceptsOfferType))\n\trequire.Equal(t, \"\", getOffer([]byte(\"text/html\"), acceptsOfferType, \"application/json\"))\n\trequire.Equal(t, \"\", getOffer([]byte(\"text/html;q=0\"), acceptsOfferType, \"text/html\"))\n\trequire.Equal(t, \"\", getOffer([]byte(\"application/json, */*; q=0\"), acceptsOfferType, \"image/png\"))\n\trequire.Equal(t, \"application/xml\", getOffer([]byte(\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"), acceptsOfferType, \"application/xml\", \"application/json\"))\n\trequire.Equal(t, \"text/html\", getOffer([]byte(\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"), acceptsOfferType, \"text/html\"))\n\trequire.Equal(t, \"application/pdf\", getOffer([]byte(\"text/plain;q=0,application/pdf;q=0.9,*/*;q=0.000\"), acceptsOfferType, \"application/pdf\", \"application/json\"))\n\trequire.Equal(t, \"application/pdf\", getOffer([]byte(\"text/plain;q=0,application/pdf;q=0.9,*/*;q=0.000\"), acceptsOfferType, \"application/pdf\", \"application/json\"))\n\trequire.Equal(t, \"text/plain;a=1\", getOffer([]byte(\"text/plain;a=1\"), acceptsOfferType, \"text/plain;a=1\"))\n\trequire.Equal(t, \"\", getOffer([]byte(\"text/plain;a=1;b=2\"), acceptsOfferType, \"text/plain;b=2\"))\n\n\t// Spaces, quotes, out of order params, and case insensitivity\n\trequire.Equal(t, \"text/plain\", getOffer([]byte(\"text/plain  \"), acceptsOfferType, \"text/plain\"))\n\trequire.Equal(t, \"text/plain\", getOffer([]byte(\"text/plain;q=0.4  \"), acceptsOfferType, \"text/plain\"))\n\trequire.Equal(t, \"text/plain\", getOffer([]byte(\"text/plain;q=0.4  ;\"), acceptsOfferType, \"text/plain\"))\n\trequire.Equal(t, \"text/plain\", getOffer([]byte(\"text/plain;q=0.4  ; p=foo\"), acceptsOfferType, \"text/plain\"))\n\trequire.Equal(t, \"text/plain;b=2;a=1\", getOffer([]byte(\"text/plain ;a=1;b=2\"), acceptsOfferType, \"text/plain;b=2;a=1\"))\n\trequire.Equal(t, \"text/plain;a=1\", getOffer([]byte(\"text/plain;   a=1   \"), acceptsOfferType, \"text/plain;a=1\"))\n\trequire.Equal(t, `text/plain;a=\"1;b=2\\\",text/plain\"`, getOffer([]byte(`text/plain;a=\"1;b=2\\\",text/plain\";q=0.9`), acceptsOfferType, `text/plain;a=1;b=2`, `text/plain;a=\"1;b=2\\\",text/plain\"`))\n\trequire.Equal(t, \"text/plain;A=CAPS\", getOffer([]byte(`text/plain;a=\"caPs\"`), acceptsOfferType, \"text/plain;A=CAPS\"))\n\n\t// Priority\n\trequire.Equal(t, \"text/plain\", getOffer([]byte(\"text/plain\"), acceptsOfferType, \"text/plain\", \"text/plain;a=1\"))\n\trequire.Equal(t, \"text/plain;a=1\", getOffer([]byte(\"text/plain\"), acceptsOfferType, \"text/plain;a=1\", \"\", \"text/plain\"))\n\trequire.Equal(t, \"text/plain;a=1\", getOffer([]byte(\"text/plain,text/plain;a=1\"), acceptsOfferType, \"text/plain\", \"text/plain;a=1\"))\n\trequire.Equal(t, \"text/plain\", getOffer([]byte(\"text/plain;q=0.899,text/plain;a=1;q=0.898\"), acceptsOfferType, \"text/plain\", \"text/plain;a=1\"))\n\trequire.Equal(t, \"text/plain;a=1;b=2\", getOffer([]byte(\"text/plain,text/plain;a=1,text/plain;a=1;b=2\"), acceptsOfferType, \"text/plain\", \"text/plain;a=1\", \"text/plain;a=1;b=2\"))\n\n\t// Takes the last value specified\n\trequire.Equal(t, \"text/plain;a=1;b=2\", getOffer([]byte(\"text/plain;a=1;b=1;B=2\"), acceptsOfferType, \"text/plain;a=1;b=1\", \"text/plain;a=1;b=2\"))\n\n\trequire.Equal(t, \"\", getOffer([]byte(\"utf-8, iso-8859-1;q=0.5\"), acceptsOffer))\n\trequire.Equal(t, \"\", getOffer([]byte(\"utf-8, iso-8859-1;q=0.5\"), acceptsOffer, \"ascii\"))\n\trequire.Equal(t, \"utf-8\", getOffer([]byte(\"utf-8, iso-8859-1;q=0.5\"), acceptsOffer, \"utf-8\"))\n\trequire.Equal(t, \"iso-8859-1\", getOffer([]byte(\"utf-8;q=0, iso-8859-1;q=0.5\"), acceptsOffer, \"utf-8\", \"iso-8859-1\"))\n\n\trequire.Equal(t, \"deflate\", getOffer([]byte(\"gzip, deflate\"), acceptsOffer, \"deflate\"))\n\trequire.Equal(t, \"\", getOffer([]byte(\"gzip, deflate;q=0\"), acceptsOffer, \"deflate\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Utils_GetOffer -benchmem -count=4\nfunc Benchmark_Utils_GetOffer(b *testing.B) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\taccept      string\n\t\toffers      []string\n\t}{\n\t\t{\n\t\t\tdescription: \"simple\",\n\t\t\taccept:      \"application/json\",\n\t\t\toffers:      []string{\"application/json\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"6 offers\",\n\t\t\taccept:      \"text/plain\",\n\t\t\toffers:      []string{\"junk/a\", \"junk/b\", \"junk/c\", \"junk/d\", \"junk/e\", \"text/plain\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"1 parameter\",\n\t\t\taccept:      \"application/json; version=1\",\n\t\t\toffers:      []string{\"application/json;version=1\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"2 parameters\",\n\t\t\taccept:      \"application/json; version=1; foo=bar\",\n\t\t\toffers:      []string{\"application/json;version=1;foo=bar\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"3 parameters\",\n\t\t\taccept:      \"application/json; version=1; foo=bar; charset=utf-8\",\n\t\t\toffers:      []string{\"application/json;version=1;foo=bar;charset=utf-8\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"10 parameters\",\n\t\t\taccept:      \"text/plain;a=1;b=2;c=3;d=4;e=5;f=6;g=7;h=8;i=9;j=10\",\n\t\t\toffers:      []string{\"text/plain;a=1;b=2;c=3;d=4;e=5;f=6;g=7;h=8;i=9;j=10\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"6 offers w/params\",\n\t\t\taccept:      \"text/plain; format=flowed\",\n\t\t\toffers: []string{\n\t\t\t\t\"junk/a;a=b\",\n\t\t\t\t\"junk/b;b=c\",\n\t\t\t\t\"junk/c;c=d\",\n\t\t\t\t\"text/plain; format=justified\",\n\t\t\t\t\"text/plain; format=flat\",\n\t\t\t\t\"text/plain; format=flowed\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"mime extension\",\n\t\t\taccept:      \"utf-8, iso-8859-1;q=0.5\",\n\t\t\toffers:      []string{\"utf-8\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"mime extension\",\n\t\t\taccept:      \"utf-8, iso-8859-1;q=0.5\",\n\t\t\toffers:      []string{\"iso-8859-1\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"mime extension\",\n\t\t\taccept:      \"utf-8, iso-8859-1;q=0.5\",\n\t\t\toffers:      []string{\"iso-8859-1\", \"utf-8\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"mime extension\",\n\t\t\taccept:      \"gzip, deflate\",\n\t\t\toffers:      []string{\"deflate\"},\n\t\t},\n\t\t{\n\t\t\tdescription: \"web browser\",\n\t\t\taccept:      \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n\t\t\toffers:      []string{\"text/html\", \"application/xml\", \"application/xml+xhtml\"},\n\t\t},\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor _, tc := range testCases {\n\t\taccept := []byte(tc.accept)\n\t\tb.Run(tc.description, func(b *testing.B) {\n\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\tgetOffer(accept, acceptsOfferType, tc.offers...)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_Utils_ParamsMatch(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\taccept      headerParams\n\t\toffer       string\n\t\tmatch       bool\n\t}{\n\t\t{\n\t\t\tdescription: \"empty accept and offer\",\n\t\t\taccept:      nil,\n\t\t\toffer:       \"\",\n\t\t\tmatch:       true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"accept is empty, offer has params\",\n\t\t\taccept:      make(headerParams),\n\t\t\toffer:       \";foo=bar\",\n\t\t\tmatch:       true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"offer is empty, accept has params\",\n\t\t\taccept:      headerParams{\"foo\": []byte(\"bar\")},\n\t\t\toffer:       \"\",\n\t\t\tmatch:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"accept has extra parameters\",\n\t\t\taccept:      headerParams{\"foo\": []byte(\"bar\"), \"a\": []byte(\"1\")},\n\t\t\toffer:       \";foo=bar\",\n\t\t\tmatch:       false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"matches regardless of order\",\n\t\t\taccept:      headerParams{\"b\": []byte(\"2\"), \"a\": []byte(\"1\")},\n\t\t\toffer:       \";b=2;a=1\",\n\t\t\tmatch:       true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"case insensitive\",\n\t\t\taccept:      headerParams{\"ParaM\": []byte(\"FoO\")},\n\t\t\toffer:       \";pAram=foO\",\n\t\t\tmatch:       true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\trequire.Equal(t, tc.match, paramsMatch(tc.accept, tc.offer), tc.description)\n\t}\n}\n\nfunc Benchmark_Utils_ParamsMatch(b *testing.B) {\n\tvar match bool\n\n\tspecParams := headerParams{\n\t\t\"appLe\": []byte(\"orange\"),\n\t\t\"param\": []byte(\"foo\"),\n\t}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tmatch = paramsMatch(specParams, `;param=foo; apple=orange`)\n\t}\n\trequire.True(b, match)\n}\n\nfunc Test_Utils_AcceptsOfferType(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tdescription string\n\t\tspec        string\n\t\tspecParams  headerParams\n\t\tofferType   string\n\t\taccepts     bool\n\t}{\n\t\t{\n\t\t\tdescription: \"no params, matching\",\n\t\t\tspec:        \"application/json\",\n\t\t\tofferType:   \"application/json\",\n\t\t\taccepts:     true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"no params, mismatch\",\n\t\t\tspec:        \"application/json\",\n\t\t\tofferType:   \"application/xml\",\n\t\t\taccepts:     false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"params match\",\n\t\t\tspec:        \"application/json\",\n\t\t\tspecParams:  headerParams{\"format\": []byte(\"foo\"), \"version\": []byte(\"1\")},\n\t\t\tofferType:   \"application/json;version=1;format=foo;q=0.1\",\n\t\t\taccepts:     true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"spec has extra params\",\n\t\t\tspec:        \"text/html\",\n\t\t\tspecParams:  headerParams{\"charset\": []byte(\"utf-8\")},\n\t\t\tofferType:   \"text/html\",\n\t\t\taccepts:     false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"offer has extra params\",\n\t\t\tspec:        \"text/html\",\n\t\t\tofferType:   \"text/html;charset=utf-8\",\n\t\t\taccepts:     true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"ignores optional whitespace\",\n\t\t\tspec:        \"application/json\",\n\t\t\tspecParams:  headerParams{\"format\": []byte(\"foo\"), \"version\": []byte(\"1\")},\n\t\t\tofferType:   \"application/json;  version=1 ;    format=foo   \",\n\t\t\taccepts:     true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"ignores optional whitespace\",\n\t\t\tspec:        \"application/json\",\n\t\t\tspecParams:  headerParams{\"format\": []byte(\"foo bar\"), \"version\": []byte(\"1\")},\n\t\t\tofferType:   `application/json;version=\"1\";format=\"foo bar\"`,\n\t\t\taccepts:     true,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\taccepts := acceptsOfferType(tc.spec, tc.offerType, tc.specParams)\n\t\trequire.Equal(t, tc.accepts, accepts, tc.description)\n\t}\n}\n\nfunc Test_Utils_GetSplicedStrList(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tdescription  string\n\t\theaderValue  string\n\t\texpectedList []string\n\t}{\n\t\t{\n\t\t\tdescription:  \"normal case\",\n\t\t\theaderValue:  \"gzip, deflate,br\",\n\t\t\texpectedList: []string{\"gzip\", \"deflate\", \"br\"},\n\t\t},\n\t\t{\n\t\t\tdescription:  \"no matter the value\",\n\t\t\theaderValue:  \"   gzip,deflate, br, zip\",\n\t\t\texpectedList: []string{\"gzip\", \"deflate\", \"br\", \"zip\"},\n\t\t},\n\t\t{\n\t\t\tdescription:  \"headerValue is empty\",\n\t\t\theaderValue:  \"\",\n\t\t\texpectedList: nil,\n\t\t},\n\t\t{\n\t\t\tdescription:  \"has a comma without element\",\n\t\t\theaderValue:  \"gzip,\",\n\t\t\texpectedList: []string{\"gzip\", \"\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\ttc := tc // create a new 'tc' variable for the goroutine\n\t\t\tt.Parallel()\n\t\t\tdst := make([]string, 10)\n\t\t\tresult := getSplicedStrList(tc.headerValue, dst)\n\t\t\trequire.Equal(t, tc.expectedList, result)\n\t\t})\n\t}\n}\n\nfunc Benchmark_Utils_GetSplicedStrList(b *testing.B) {\n\tdestination := make([]string, 5)\n\tresult := destination\n\tconst input = `deflate, gzip,br,brotli,zstd`\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tresult = getSplicedStrList(input, destination)\n\t}\n\trequire.Equal(b, []string{\"deflate\", \"gzip\", \"br\", \"brotli\", \"zstd\"}, result)\n}\n\nfunc Test_Utils_SortAcceptedTypes(t *testing.T) {\n\tt.Parallel()\n\tacceptedTypes := []acceptedType{\n\t\t{spec: \"text/html\", quality: 1, specificity: 3, order: 0},\n\t\t{spec: \"text/*\", quality: 0.5, specificity: 2, order: 1},\n\t\t{spec: \"*/*\", quality: 0.1, specificity: 1, order: 2},\n\t\t{spec: \"application/json\", quality: 0.999, specificity: 3, order: 3},\n\t\t{spec: \"application/xml\", quality: 1, specificity: 3, order: 4},\n\t\t{spec: \"application/pdf\", quality: 1, specificity: 3, order: 5},\n\t\t{spec: \"image/png\", quality: 1, specificity: 3, order: 6},\n\t\t{spec: \"image/jpeg\", quality: 1, specificity: 3, order: 7},\n\t\t{spec: \"image/*\", quality: 1, specificity: 2, order: 8},\n\t\t{spec: \"image/gif\", quality: 1, specificity: 3, order: 9},\n\t\t{spec: \"text/plain\", quality: 1, specificity: 3, order: 10},\n\t\t{spec: \"application/json\", quality: 0.999, specificity: 3, params: headerParams{\"a\": []byte(\"1\")}, order: 11},\n\t}\n\tsortAcceptedTypes(&acceptedTypes)\n\trequire.Equal(t, []acceptedType{\n\t\t{spec: \"text/html\", quality: 1, specificity: 3, order: 0},\n\t\t{spec: \"application/xml\", quality: 1, specificity: 3, order: 4},\n\t\t{spec: \"application/pdf\", quality: 1, specificity: 3, order: 5},\n\t\t{spec: \"image/png\", quality: 1, specificity: 3, order: 6},\n\t\t{spec: \"image/jpeg\", quality: 1, specificity: 3, order: 7},\n\t\t{spec: \"image/gif\", quality: 1, specificity: 3, order: 9},\n\t\t{spec: \"text/plain\", quality: 1, specificity: 3, order: 10},\n\t\t{spec: \"image/*\", quality: 1, specificity: 2, order: 8},\n\t\t{spec: \"application/json\", quality: 0.999, specificity: 3, params: headerParams{\"a\": []byte(\"1\")}, order: 11},\n\t\t{spec: \"application/json\", quality: 0.999, specificity: 3, order: 3},\n\t\t{spec: \"text/*\", quality: 0.5, specificity: 2, order: 1},\n\t\t{spec: \"*/*\", quality: 0.1, specificity: 1, order: 2},\n\t}, acceptedTypes)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Utils_SortAcceptedTypes_Sorted -benchmem -count=4\nfunc Benchmark_Utils_SortAcceptedTypes_Sorted(b *testing.B) {\n\tacceptedTypes := make([]acceptedType, 3)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tacceptedTypes[0] = acceptedType{spec: \"text/html\", quality: 1, specificity: 1, order: 0}\n\t\tacceptedTypes[1] = acceptedType{spec: \"text/*\", quality: 0.5, specificity: 1, order: 1}\n\t\tacceptedTypes[2] = acceptedType{spec: \"*/*\", quality: 0.1, specificity: 1, order: 2}\n\t\tsortAcceptedTypes(&acceptedTypes)\n\t}\n\trequire.Equal(b, \"text/html\", acceptedTypes[0].spec)\n\trequire.Equal(b, \"text/*\", acceptedTypes[1].spec)\n\trequire.Equal(b, \"*/*\", acceptedTypes[2].spec)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Utils_SortAcceptedTypes_Unsorted -benchmem -count=4\nfunc Benchmark_Utils_SortAcceptedTypes_Unsorted(b *testing.B) {\n\tacceptedTypes := make([]acceptedType, 11)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tacceptedTypes[0] = acceptedType{spec: \"text/html\", quality: 1, specificity: 3, order: 0}\n\t\tacceptedTypes[1] = acceptedType{spec: \"text/*\", quality: 0.5, specificity: 2, order: 1}\n\t\tacceptedTypes[2] = acceptedType{spec: \"*/*\", quality: 0.1, specificity: 1, order: 2}\n\t\tacceptedTypes[3] = acceptedType{spec: \"application/json\", quality: 0.999, specificity: 3, order: 3}\n\t\tacceptedTypes[4] = acceptedType{spec: \"application/xml\", quality: 1, specificity: 3, order: 4}\n\t\tacceptedTypes[5] = acceptedType{spec: \"application/pdf\", quality: 1, specificity: 3, order: 5}\n\t\tacceptedTypes[6] = acceptedType{spec: \"image/png\", quality: 1, specificity: 3, order: 6}\n\t\tacceptedTypes[7] = acceptedType{spec: \"image/jpeg\", quality: 1, specificity: 3, order: 7}\n\t\tacceptedTypes[8] = acceptedType{spec: \"image/*\", quality: 1, specificity: 2, order: 8}\n\t\tacceptedTypes[9] = acceptedType{spec: \"image/gif\", quality: 1, specificity: 3, order: 9}\n\t\tacceptedTypes[10] = acceptedType{spec: \"text/plain\", quality: 1, specificity: 3, order: 10}\n\t\tsortAcceptedTypes(&acceptedTypes)\n\t}\n\trequire.Equal(b, []acceptedType{\n\t\t{spec: \"text/html\", quality: 1, specificity: 3, order: 0},\n\t\t{spec: \"application/xml\", quality: 1, specificity: 3, order: 4},\n\t\t{spec: \"application/pdf\", quality: 1, specificity: 3, order: 5},\n\t\t{spec: \"image/png\", quality: 1, specificity: 3, order: 6},\n\t\t{spec: \"image/jpeg\", quality: 1, specificity: 3, order: 7},\n\t\t{spec: \"image/gif\", quality: 1, specificity: 3, order: 9},\n\t\t{spec: \"text/plain\", quality: 1, specificity: 3, order: 10},\n\t\t{spec: \"image/*\", quality: 1, specificity: 2, order: 8},\n\t\t{spec: \"application/json\", quality: 0.999, specificity: 3, order: 3},\n\t\t{spec: \"text/*\", quality: 0.5, specificity: 2, order: 1},\n\t\t{spec: \"*/*\", quality: 0.1, specificity: 1, order: 2},\n\t}, acceptedTypes)\n}\n\nfunc Test_Utils_UniqueRouteStack(t *testing.T) {\n\tt.Parallel()\n\troute1 := &Route{}\n\troute2 := &Route{}\n\troute3 := &Route{}\n\trequire.Equal(\n\t\tt,\n\t\t[]*Route{\n\t\t\troute1,\n\t\t\troute2,\n\t\t\troute3,\n\t\t},\n\t\tuniqueRouteStack([]*Route{\n\t\t\troute1,\n\t\t\troute1,\n\t\t\troute1,\n\t\t\troute2,\n\t\t\troute2,\n\t\t\troute2,\n\t\t\troute3,\n\t\t\troute3,\n\t\t\troute3,\n\t\t\troute1,\n\t\t\troute2,\n\t\t\troute3,\n\t\t}))\n}\n\nfunc Test_Utils_getGroupPath(t *testing.T) {\n\tt.Parallel()\n\tres := getGroupPath(\"/v1\", \"/\")\n\trequire.Equal(t, \"/v1/\", res)\n\n\tres = getGroupPath(\"/v1/\", \"/\")\n\trequire.Equal(t, \"/v1/\", res)\n\n\tres = getGroupPath(\"/\", \"/\")\n\trequire.Equal(t, \"/\", res)\n\n\tres = getGroupPath(\"/v1/api/\", \"/\")\n\trequire.Equal(t, \"/v1/api/\", res)\n\n\tres = getGroupPath(\"/v1/api\", \"group\")\n\trequire.Equal(t, \"/v1/api/group\", res)\n\n\tres = getGroupPath(\"/v1/api\", \"\")\n\trequire.Equal(t, \"/v1/api\", res)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Utils_ -benchmem -count=3\nfunc Benchmark_Utils_getGroupPath(b *testing.B) {\n\tvar res string\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = getGroupPath(\"/v1/long/path/john/doe\", \"/why/this/name/is/so/awesome\")\n\t\t_ = getGroupPath(\"/v1\", \"/\")\n\t\t_ = getGroupPath(\"/v1\", \"/api\")\n\t\tres = getGroupPath(\"/v1\", \"/api/register/:project\")\n\t}\n\trequire.Equal(b, \"/v1/api/register/:project\", res)\n}\n\nfunc Benchmark_Utils_Unescape(b *testing.B) {\n\tunescaped := \"\"\n\tdst := make([]byte, 0)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tsource := \"/cr%C3%A9er\"\n\t\tpathBytes := utils.UnsafeBytes(source)\n\t\tpathBytes = fasthttp.AppendUnquotedArg(dst[:0], pathBytes)\n\t\tunescaped = utils.UnsafeString(pathBytes)\n\t}\n\n\trequire.Equal(b, \"/créer\", unescaped)\n}\n\nfunc Test_Utils_Parse_Address(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\taddr, host, port string\n\t}{\n\t\t{addr: \"[::1]:3000\", host: \"[::1]\", port: \"3000\"},\n\t\t{addr: \"127.0.0.1:3000\", host: \"127.0.0.1\", port: \"3000\"},\n\t\t{addr: \"/path/to/unix/socket\", host: \"/path/to/unix/socket\", port: \"\"},\n\t}\n\n\tfor _, c := range testCases {\n\t\thost, port := parseAddr(c.addr)\n\t\trequire.Equal(t, c.host, host, \"addr host\")\n\t\trequire.Equal(t, c.port, port, \"addr port\")\n\t}\n}\n\nfunc Test_Utils_TestConn_Deadline(t *testing.T) {\n\tt.Parallel()\n\tconn := &testConn{}\n\trequire.NoError(t, conn.SetDeadline(time.Time{}))\n\trequire.NoError(t, conn.SetReadDeadline(time.Time{}))\n\trequire.NoError(t, conn.SetWriteDeadline(time.Time{}))\n}\n\nfunc Test_Utils_TestConn_ReadWrite(t *testing.T) {\n\tt.Parallel()\n\tconn := &testConn{}\n\n\t// Verify read of request\n\t_, err := conn.r.Write([]byte(\"Request\"))\n\trequire.NoError(t, err)\n\n\treq := make([]byte, 7)\n\t_, err = conn.Read(req)\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"Request\"), req)\n\n\t// Verify write of response\n\t_, err = conn.Write([]byte(\"Response\"))\n\trequire.NoError(t, err)\n\n\tres := make([]byte, 8)\n\t_, err = conn.w.Read(res)\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"Response\"), res)\n}\n\nfunc Test_Utils_TestConn_Closed_Write(t *testing.T) {\n\tt.Parallel()\n\tconn := &testConn{}\n\n\t// Verify write of response\n\t_, err := conn.Write([]byte(\"Response 1\\n\"))\n\trequire.NoError(t, err)\n\n\t// Close early, write should fail\n\tconn.Close() //nolint:errcheck, revive // It is fine to ignore the error here\n\t_, err = conn.Write([]byte(\"Response 2\\n\"))\n\trequire.Error(t, err)\n\n\tres := make([]byte, 11)\n\t_, err = conn.w.Read(res)\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"Response 1\\n\"), res)\n}\n\nfunc Test_Utils_IsNoCache(t *testing.T) {\n\tt.Parallel()\n\ttestCases := []struct {\n\t\tstring\n\t\tbool\n\t}{\n\t\t{string: \"public\", bool: false},\n\t\t{string: \"no-cache\", bool: true},\n\t\t{string: \"public, no-cache, max-age=30\", bool: true},\n\t\t{string: \"public,no-cache\", bool: true},\n\t\t{string: \"public,no-cacheX\", bool: false},\n\t\t{string: \"no-cache, public\", bool: true},\n\t\t{string: \"Xno-cache, public\", bool: false},\n\t\t{string: \"max-age=30, no-cache,public\", bool: true},\n\t}\n\n\tfor _, c := range testCases {\n\t\tok := isNoCache(c.string)\n\t\trequire.Equal(t, c.bool, ok, \"want %t, got isNoCache(%s)=%t\", c.bool, c.string, ok)\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_Utils_IsNoCache -benchmem -count=4\nfunc Benchmark_Utils_IsNoCache(b *testing.B) {\n\tvar ok bool\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = isNoCache(\"public\")\n\t\t_ = isNoCache(\"no-cache\")\n\t\t_ = isNoCache(\"public, no-cache, max-age=30\")\n\t\t_ = isNoCache(\"public,no-cache\")\n\t\t_ = isNoCache(\"no-cache, public\")\n\t\tok = isNoCache(\"max-age=30, no-cache,public\")\n\t}\n\trequire.True(b, ok)\n}\n\n// go test -v -run=^$ -bench=Benchmark_SlashRecognition -benchmem -count=4\nfunc Benchmark_SlashRecognition(b *testing.B) {\n\tsearch := \"wtf/1234\"\n\tvar result bool\n\n\tb.Run(\"indexBytes\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tresult = false\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tif strings.IndexByte(search, slashDelimiter) != -1 {\n\t\t\t\tresult = true\n\t\t\t}\n\t\t}\n\t\trequire.True(b, result)\n\t})\n\tb.Run(\"forEach\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tresult = false\n\t\tc := int32(slashDelimiter)\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, b := range search {\n\t\t\t\tif b == c {\n\t\t\t\t\tresult = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trequire.True(b, result)\n\t})\n\tb.Run(\"IndexRune\", func(b *testing.B) {\n\t\tb.ReportAllocs()\n\t\tb.ResetTimer()\n\t\tresult = false\n\t\tc := int32(slashDelimiter)\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tresult = IndexRune(search, c)\n\t\t}\n\t\trequire.True(b, result)\n\t})\n}\n"
        },
        {
          "name": "hooks.go",
          "type": "blob",
          "size": 5.3,
          "content": "package fiber\n\nimport (\n\t\"github.com/gofiber/fiber/v3/log\"\n)\n\n// OnRouteHandler Handlers define a function to create hooks for Fiber.\ntype (\n\tOnRouteHandler     = func(Route) error\n\tOnNameHandler      = OnRouteHandler\n\tOnGroupHandler     = func(Group) error\n\tOnGroupNameHandler = OnGroupHandler\n\tOnListenHandler    = func(ListenData) error\n\tOnShutdownHandler  = func() error\n\tOnForkHandler      = func(int) error\n\tOnMountHandler     = func(*App) error\n)\n\n// Hooks is a struct to use it with App.\ntype Hooks struct {\n\t// Embed app\n\tapp *App\n\n\t// Hooks\n\tonRoute     []OnRouteHandler\n\tonName      []OnNameHandler\n\tonGroup     []OnGroupHandler\n\tonGroupName []OnGroupNameHandler\n\tonListen    []OnListenHandler\n\tonShutdown  []OnShutdownHandler\n\tonFork      []OnForkHandler\n\tonMount     []OnMountHandler\n}\n\n// ListenData is a struct to use it with OnListenHandler\ntype ListenData struct {\n\tHost string\n\tPort string\n\tTLS  bool\n}\n\nfunc newHooks(app *App) *Hooks {\n\treturn &Hooks{\n\t\tapp:         app,\n\t\tonRoute:     make([]OnRouteHandler, 0),\n\t\tonGroup:     make([]OnGroupHandler, 0),\n\t\tonGroupName: make([]OnGroupNameHandler, 0),\n\t\tonName:      make([]OnNameHandler, 0),\n\t\tonListen:    make([]OnListenHandler, 0),\n\t\tonShutdown:  make([]OnShutdownHandler, 0),\n\t\tonFork:      make([]OnForkHandler, 0),\n\t\tonMount:     make([]OnMountHandler, 0),\n\t}\n}\n\n// OnRoute is a hook to execute user functions on each route registration.\n// Also you can get route properties by route parameter.\nfunc (h *Hooks) OnRoute(handler ...OnRouteHandler) {\n\th.app.mutex.Lock()\n\th.onRoute = append(h.onRoute, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnName is a hook to execute user functions on each route naming.\n// Also you can get route properties by route parameter.\n//\n// WARN: OnName only works with naming routes, not groups.\nfunc (h *Hooks) OnName(handler ...OnNameHandler) {\n\th.app.mutex.Lock()\n\th.onName = append(h.onName, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnGroup is a hook to execute user functions on each group registration.\n// Also you can get group properties by group parameter.\nfunc (h *Hooks) OnGroup(handler ...OnGroupHandler) {\n\th.app.mutex.Lock()\n\th.onGroup = append(h.onGroup, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnGroupName is a hook to execute user functions on each group naming.\n// Also you can get group properties by group parameter.\n//\n// WARN: OnGroupName only works with naming groups, not routes.\nfunc (h *Hooks) OnGroupName(handler ...OnGroupNameHandler) {\n\th.app.mutex.Lock()\n\th.onGroupName = append(h.onGroupName, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnListen is a hook to execute user functions on Listen, ListenTLS, Listener.\nfunc (h *Hooks) OnListen(handler ...OnListenHandler) {\n\th.app.mutex.Lock()\n\th.onListen = append(h.onListen, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnShutdown is a hook to execute user functions after Shutdown.\nfunc (h *Hooks) OnShutdown(handler ...OnShutdownHandler) {\n\th.app.mutex.Lock()\n\th.onShutdown = append(h.onShutdown, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnFork is a hook to execute user function after fork process.\nfunc (h *Hooks) OnFork(handler ...OnForkHandler) {\n\th.app.mutex.Lock()\n\th.onFork = append(h.onFork, handler...)\n\th.app.mutex.Unlock()\n}\n\n// OnMount is a hook to execute user function after mounting process.\n// The mount event is fired when sub-app is mounted on a parent app. The parent app is passed as a parameter.\n// It works for app and group mounting.\nfunc (h *Hooks) OnMount(handler ...OnMountHandler) {\n\th.app.mutex.Lock()\n\th.onMount = append(h.onMount, handler...)\n\th.app.mutex.Unlock()\n}\n\nfunc (h *Hooks) executeOnRouteHooks(route Route) error {\n\t// Check mounting\n\tif h.app.mountFields.mountPath != \"\" {\n\t\troute.path = h.app.mountFields.mountPath + route.path\n\t\troute.Path = route.path\n\t}\n\n\tfor _, v := range h.onRoute {\n\t\tif err := v(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (h *Hooks) executeOnNameHooks(route Route) error {\n\t// Check mounting\n\tif h.app.mountFields.mountPath != \"\" {\n\t\troute.path = h.app.mountFields.mountPath + route.path\n\t\troute.Path = route.path\n\t}\n\n\tfor _, v := range h.onName {\n\t\tif err := v(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (h *Hooks) executeOnGroupHooks(group Group) error {\n\t// Check mounting\n\tif h.app.mountFields.mountPath != \"\" {\n\t\tgroup.Prefix = h.app.mountFields.mountPath + group.Prefix\n\t}\n\n\tfor _, v := range h.onGroup {\n\t\tif err := v(group); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (h *Hooks) executeOnGroupNameHooks(group Group) error {\n\t// Check mounting\n\tif h.app.mountFields.mountPath != \"\" {\n\t\tgroup.Prefix = h.app.mountFields.mountPath + group.Prefix\n\t}\n\n\tfor _, v := range h.onGroupName {\n\t\tif err := v(group); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (h *Hooks) executeOnListenHooks(listenData ListenData) error {\n\tfor _, v := range h.onListen {\n\t\tif err := v(listenData); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (h *Hooks) executeOnShutdownHooks() {\n\tfor _, v := range h.onShutdown {\n\t\tif err := v(); err != nil {\n\t\t\tlog.Errorf(\"failed to call shutdown hook: %v\", err)\n\t\t}\n\t}\n}\n\nfunc (h *Hooks) executeOnForkHooks(pid int) {\n\tfor _, v := range h.onFork {\n\t\tif err := v(pid); err != nil {\n\t\t\tlog.Errorf(\"failed to call fork hook: %v\", err)\n\t\t}\n\t}\n}\n\nfunc (h *Hooks) executeOnMountHooks(app *App) error {\n\tfor _, v := range h.onMount {\n\t\tif err := v(app); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "hooks_test.go",
          "type": "blob",
          "size": 5.32,
          "content": "package fiber\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/bytebufferpool\"\n)\n\nfunc testSimpleHandler(c Ctx) error {\n\treturn c.SendString(\"simple\")\n}\n\nfunc Test_Hook_OnRoute(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Hooks().OnRoute(func(r Route) error {\n\t\trequire.Equal(t, \"\", r.Name)\n\n\t\treturn nil\n\t})\n\n\tapp.Get(\"/\", testSimpleHandler).Name(\"x\")\n\n\tsubApp := New()\n\tsubApp.Get(\"/test\", testSimpleHandler)\n\n\tapp.Use(\"/sub\", subApp)\n}\n\nfunc Test_Hook_OnRoute_Mount(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tsubApp := New()\n\tapp.Use(\"/sub\", subApp)\n\n\tsubApp.Hooks().OnRoute(func(r Route) error {\n\t\trequire.Equal(t, \"/sub/test\", r.Path)\n\n\t\treturn nil\n\t})\n\n\tapp.Hooks().OnRoute(func(r Route) error {\n\t\trequire.Equal(t, \"/\", r.Path)\n\n\t\treturn nil\n\t})\n\n\tapp.Get(\"/\", testSimpleHandler).Name(\"x\")\n\tsubApp.Get(\"/test\", testSimpleHandler)\n}\n\nfunc Test_Hook_OnName(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\tapp.Hooks().OnName(func(r Route) error {\n\t\t_, err := buf.WriteString(r.Name)\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\tapp.Get(\"/\", testSimpleHandler).Name(\"index\")\n\n\tsubApp := New()\n\tsubApp.Get(\"/test\", testSimpleHandler)\n\tsubApp.Get(\"/test2\", testSimpleHandler)\n\n\tapp.Use(\"/sub\", subApp)\n\n\trequire.Equal(t, \"index\", buf.String())\n}\n\nfunc Test_Hook_OnName_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trequire.Equal(t, \"unknown error\", fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}()\n\n\tapp.Hooks().OnName(func(_ Route) error {\n\t\treturn errors.New(\"unknown error\")\n\t})\n\n\tapp.Get(\"/\", testSimpleHandler).Name(\"index\")\n}\n\nfunc Test_Hook_OnGroup(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\tapp.Hooks().OnGroup(func(g Group) error {\n\t\t_, err := buf.WriteString(g.Prefix)\n\t\trequire.NoError(t, err)\n\t\treturn nil\n\t})\n\n\tgrp := app.Group(\"/x\").Name(\"x.\")\n\tgrp.Group(\"/a\")\n\n\trequire.Equal(t, \"/x/x/a\", buf.String())\n}\n\nfunc Test_Hook_OnGroup_Mount(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tmicro := New()\n\tmicro.Use(\"/john\", app)\n\n\tapp.Hooks().OnGroup(func(g Group) error {\n\t\trequire.Equal(t, \"/john/v1\", g.Prefix)\n\t\treturn nil\n\t})\n\n\tv1 := app.Group(\"/v1\")\n\tv1.Get(\"/doe\", func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t})\n}\n\nfunc Test_Hook_OnGroupName(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\tbuf2 := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf2)\n\n\tapp.Hooks().OnGroupName(func(g Group) error {\n\t\t_, err := buf.WriteString(g.name)\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\tapp.Hooks().OnName(func(r Route) error {\n\t\t_, err := buf2.WriteString(r.Name)\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\tgrp := app.Group(\"/x\").Name(\"x.\")\n\tgrp.Get(\"/test\", testSimpleHandler).Name(\"test\")\n\tgrp.Get(\"/test2\", testSimpleHandler)\n\n\trequire.Equal(t, \"x.\", buf.String())\n\trequire.Equal(t, \"x.test\", buf2.String())\n}\n\nfunc Test_Hook_OnGroupName_Error(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trequire.Equal(t, \"unknown error\", fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}()\n\n\tapp.Hooks().OnGroupName(func(_ Group) error {\n\t\treturn errors.New(\"unknown error\")\n\t})\n\n\tgrp := app.Group(\"/x\").Name(\"x.\")\n\tgrp.Get(\"/test\", testSimpleHandler)\n}\n\nfunc Test_Hook_OnShutdown(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\tapp.Hooks().OnShutdown(func() error {\n\t\t_, err := buf.WriteString(\"shutdowning\")\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\trequire.NoError(t, app.Shutdown())\n\trequire.Equal(t, \"shutdowning\", buf.String())\n}\n\nfunc Test_Hook_OnListen(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\tapp.Hooks().OnListen(func(_ ListenData) error {\n\t\t_, err := buf.WriteString(\"ready\")\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\trequire.NoError(t, app.Listen(\":9000\"))\n\n\trequire.Equal(t, \"ready\", buf.String())\n}\n\nfunc Test_Hook_OnListenPrefork(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tbuf := bytebufferpool.Get()\n\tdefer bytebufferpool.Put(buf)\n\n\tapp.Hooks().OnListen(func(_ ListenData) error {\n\t\t_, err := buf.WriteString(\"ready\")\n\t\trequire.NoError(t, err)\n\n\t\treturn nil\n\t})\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":9000\", ListenConfig{DisableStartupMessage: true, EnablePrefork: true}))\n\trequire.Equal(t, \"ready\", buf.String())\n}\n\nfunc Test_Hook_OnHook(t *testing.T) {\n\tapp := New()\n\n\t// Reset test var\n\ttestPreforkMaster = true\n\ttestOnPrefork = true\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\tapp.Hooks().OnFork(func(pid int) error {\n\t\trequire.Equal(t, 1, pid)\n\t\treturn nil\n\t})\n\n\trequire.NoError(t, app.prefork(\":3000\", nil, ListenConfig{DisableStartupMessage: true, EnablePrefork: true}))\n}\n\nfunc Test_Hook_OnMount(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", testSimpleHandler).Name(\"x\")\n\n\tsubApp := New()\n\tsubApp.Get(\"/test\", testSimpleHandler)\n\n\tsubApp.Hooks().OnMount(func(parent *App) error {\n\t\trequire.Empty(t, parent.mountFields.mountPath)\n\n\t\treturn nil\n\t})\n\n\tapp.Use(\"/sub\", subApp)\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "listen.go",
          "type": "blob",
          "size": 15.68,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\t\"time\"\n\n\t\"github.com/gofiber/fiber/v3/log\"\n\t\"github.com/mattn/go-colorable\"\n\t\"github.com/mattn/go-isatty\"\n\t\"golang.org/x/crypto/acme/autocert\"\n)\n\n// Figlet text to show Fiber ASCII art on startup message\nvar figletFiberText = `\n    _______ __             \n   / ____(_) /_  ___  _____\n  / /_  / / __ \\/ _ \\/ ___/\n / __/ / / /_/ /  __/ /    \n/_/   /_/_.___/\\___/_/          %s`\n\nconst (\n\tglobalIpv4Addr = \"0.0.0.0\"\n)\n\n// ListenConfig is a struct to customize startup of Fiber.\ntype ListenConfig struct {\n\t// GracefulContext is a field to shutdown Fiber by given context gracefully.\n\t//\n\t// Default: nil\n\tGracefulContext context.Context `json:\"graceful_context\"` //nolint:containedctx // It's needed to set context inside Listen.\n\n\t// TLSConfigFunc allows customizing tls.Config as you want.\n\t//\n\t// Default: nil\n\tTLSConfigFunc func(tlsConfig *tls.Config) `json:\"tls_config_func\"`\n\n\t// ListenerFunc allows accessing and customizing net.Listener.\n\t//\n\t// Default: nil\n\tListenerAddrFunc func(addr net.Addr) `json:\"listener_addr_func\"`\n\n\t// BeforeServeFunc allows customizing and accessing fiber app before serving the app.\n\t//\n\t// Default: nil\n\tBeforeServeFunc func(app *App) error `json:\"before_serve_func\"`\n\n\t// OnShutdownError allows to customize error behavior when to graceful shutdown server by given signal.\n\t//\n\t// Print error with log.Fatalf() by default.\n\t// Default: nil\n\tOnShutdownError func(err error)\n\n\t// OnShutdownSuccess allows to customize success behavior when to graceful shutdown server by given signal.\n\t//\n\t// Default: nil\n\tOnShutdownSuccess func()\n\n\t// AutoCertManager manages TLS certificates automatically using the ACME protocol,\n\t// Enables integration with Let's Encrypt or other ACME-compatible providers.\n\t//\n\t// Default: nil\n\tAutoCertManager *autocert.Manager `json:\"auto_cert_manager\"`\n\n\t// Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only)\n\t// WARNING: When prefork is set to true, only \"tcp4\" and \"tcp6\" can be chosen.\n\t//\n\t// Default: NetworkTCP4\n\tListenerNetwork string `json:\"listener_network\"`\n\n\t// CertFile is a path of certficate file.\n\t// If you want to use TLS, you have to enter this field.\n\t//\n\t// Default : \"\"\n\tCertFile string `json:\"cert_file\"`\n\n\t// KeyFile is a path of certficate's private key.\n\t// If you want to use TLS, you have to enter this field.\n\t//\n\t// Default : \"\"\n\tCertKeyFile string `json:\"cert_key_file\"`\n\n\t// CertClientFile is a path of client certficate.\n\t// If you want to use mTLS, you have to enter this field.\n\t//\n\t// Default : \"\"\n\tCertClientFile string `json:\"cert_client_file\"`\n\n\t// When the graceful shutdown begins, use this field to set the timeout\n\t// duration. If the timeout is reached, OnShutdownError will be called.\n\t// Set to 0 to disable the timeout and wait indefinitely.\n\t//\n\t// Default: 10 * time.Second\n\tShutdownTimeout time.Duration `json:\"shutdown_timeout\"`\n\n\t// TLSMinVersion allows to set TLS minimum version.\n\t//\n\t// Default: tls.VersionTLS12\n\t// WARNING: TLS1.0 and TLS1.1 versions are not supported.\n\tTLSMinVersion uint16 `json:\"tls_min_version\"`\n\n\t// When set to true, it will not print out the «Fiber» ASCII art and listening address.\n\t//\n\t// Default: false\n\tDisableStartupMessage bool `json:\"disable_startup_message\"`\n\n\t// When set to true, this will spawn multiple Go processes listening on the same port.\n\t//\n\t// Default: false\n\tEnablePrefork bool `json:\"enable_prefork\"`\n\n\t// If set to true, will print all routes with their method, path and handler.\n\t//\n\t// Default: false\n\tEnablePrintRoutes bool `json:\"enable_print_routes\"`\n}\n\n// listenConfigDefault is a function to set default values of ListenConfig.\nfunc listenConfigDefault(config ...ListenConfig) ListenConfig {\n\tif len(config) < 1 {\n\t\treturn ListenConfig{\n\t\t\tTLSMinVersion:   tls.VersionTLS12,\n\t\t\tListenerNetwork: NetworkTCP4,\n\t\t\tOnShutdownError: func(err error) {\n\t\t\t\tlog.Fatalf(\"shutdown: %v\", err) //nolint:revive // It's an option\n\t\t\t},\n\t\t\tShutdownTimeout: 10 * time.Second,\n\t\t}\n\t}\n\n\tcfg := config[0]\n\tif cfg.ListenerNetwork == \"\" {\n\t\tcfg.ListenerNetwork = NetworkTCP4\n\t}\n\n\tif cfg.OnShutdownError == nil {\n\t\tcfg.OnShutdownError = func(err error) {\n\t\t\tlog.Fatalf(\"shutdown: %v\", err) //nolint:revive // It's an option\n\t\t}\n\t}\n\n\tif cfg.TLSMinVersion == 0 {\n\t\tcfg.TLSMinVersion = tls.VersionTLS12\n\t}\n\n\tif cfg.TLSMinVersion != tls.VersionTLS12 && cfg.TLSMinVersion != tls.VersionTLS13 {\n\t\tpanic(\"unsupported TLS version, please use tls.VersionTLS12 or tls.VersionTLS13\")\n\t}\n\n\treturn cfg\n}\n\n// Listen serves HTTP requests from the given addr.\n// You should enter custom ListenConfig to customize startup. (TLS, mTLS, prefork...)\n//\n//\tapp.Listen(\":8080\")\n//\tapp.Listen(\"127.0.0.1:8080\")\n//\tapp.Listen(\":8080\", ListenConfig{EnablePrefork: true})\nfunc (app *App) Listen(addr string, config ...ListenConfig) error {\n\tcfg := listenConfigDefault(config...)\n\n\t// Configure TLS\n\tvar tlsConfig *tls.Config\n\tif cfg.CertFile != \"\" && cfg.CertKeyFile != \"\" {\n\t\tcert, err := tls.LoadX509KeyPair(cfg.CertFile, cfg.CertKeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"tls: cannot load TLS key pair from certFile=%q and keyFile=%q: %w\", cfg.CertFile, cfg.CertKeyFile, err)\n\t\t}\n\n\t\ttlsHandler := &TLSHandler{}\n\t\ttlsConfig = &tls.Config{ //nolint:gosec // This is a user input\n\t\t\tMinVersion: cfg.TLSMinVersion,\n\t\t\tCertificates: []tls.Certificate{\n\t\t\t\tcert,\n\t\t\t},\n\t\t\tGetCertificate: tlsHandler.GetClientInfo,\n\t\t}\n\n\t\tif cfg.CertClientFile != \"\" {\n\t\t\tclientCACert, err := os.ReadFile(filepath.Clean(cfg.CertClientFile))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to read file: %w\", err)\n\t\t\t}\n\n\t\t\tclientCertPool := x509.NewCertPool()\n\t\t\tclientCertPool.AppendCertsFromPEM(clientCACert)\n\n\t\t\ttlsConfig.ClientAuth = tls.RequireAndVerifyClientCert\n\t\t\ttlsConfig.ClientCAs = clientCertPool\n\t\t}\n\n\t\t// Attach the tlsHandler to the config\n\t\tapp.SetTLSHandler(tlsHandler)\n\t} else if cfg.AutoCertManager != nil {\n\t\ttlsConfig = &tls.Config{ //nolint:gosec // This is a user input\n\t\t\tMinVersion:     cfg.TLSMinVersion,\n\t\t\tGetCertificate: cfg.AutoCertManager.GetCertificate,\n\t\t\tNextProtos:     []string{\"http/1.1\", \"acme-tls/1\"},\n\t\t}\n\t}\n\n\tif tlsConfig != nil && cfg.TLSConfigFunc != nil {\n\t\tcfg.TLSConfigFunc(tlsConfig)\n\t}\n\n\t// Graceful shutdown\n\tif cfg.GracefulContext != nil {\n\t\tctx, cancel := context.WithCancel(cfg.GracefulContext)\n\t\tdefer cancel()\n\n\t\tgo app.gracefulShutdown(ctx, cfg)\n\t}\n\n\t// Start prefork\n\tif cfg.EnablePrefork {\n\t\treturn app.prefork(addr, tlsConfig, cfg)\n\t}\n\n\t// Configure Listener\n\tln, err := app.createListener(addr, tlsConfig, cfg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen: %w\", err)\n\t}\n\n\t// prepare the server for the start\n\tapp.startupProcess()\n\n\t// run hooks\n\tapp.runOnListenHooks(app.prepareListenData(ln.Addr().String(), getTLSConfig(ln) != nil, cfg))\n\n\t// Print startup message & routes\n\tapp.printMessages(cfg, ln)\n\n\t// Serve\n\tif cfg.BeforeServeFunc != nil {\n\t\tif err := cfg.BeforeServeFunc(app); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn app.server.Serve(ln)\n}\n\n// Listener serves HTTP requests from the given listener.\n// You should enter custom ListenConfig to customize startup. (prefork, startup message, graceful shutdown...)\nfunc (app *App) Listener(ln net.Listener, config ...ListenConfig) error {\n\tcfg := listenConfigDefault(config...)\n\n\t// Graceful shutdown\n\tif cfg.GracefulContext != nil {\n\t\tctx, cancel := context.WithCancel(cfg.GracefulContext)\n\t\tdefer cancel()\n\n\t\tgo app.gracefulShutdown(ctx, cfg)\n\t}\n\n\t// prepare the server for the start\n\tapp.startupProcess()\n\n\t// run hooks\n\tapp.runOnListenHooks(app.prepareListenData(ln.Addr().String(), getTLSConfig(ln) != nil, cfg))\n\n\t// Print startup message & routes\n\tapp.printMessages(cfg, ln)\n\n\t// Serve\n\tif cfg.BeforeServeFunc != nil {\n\t\tif err := cfg.BeforeServeFunc(app); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Prefork is not supported for custom listeners\n\tif cfg.EnablePrefork {\n\t\tlog.Warn(\"Prefork isn't supported for custom listeners.\")\n\t}\n\n\treturn app.server.Serve(ln)\n}\n\n// Create listener function.\nfunc (*App) createListener(addr string, tlsConfig *tls.Config, cfg ListenConfig) (net.Listener, error) {\n\tvar listener net.Listener\n\tvar err error\n\n\tif tlsConfig != nil {\n\t\tlistener, err = tls.Listen(cfg.ListenerNetwork, addr, tlsConfig)\n\t} else {\n\t\tlistener, err = net.Listen(cfg.ListenerNetwork, addr)\n\t}\n\n\t// Check for error before using the listener\n\tif err != nil {\n\t\t// Wrap the error from tls.Listen/net.Listen\n\t\treturn nil, fmt.Errorf(\"failed to listen: %w\", err)\n\t}\n\n\tif cfg.ListenerAddrFunc != nil {\n\t\tcfg.ListenerAddrFunc(listener.Addr())\n\t}\n\n\treturn listener, nil\n}\n\nfunc (app *App) printMessages(cfg ListenConfig, ln net.Listener) {\n\t// Print startup message\n\tif !cfg.DisableStartupMessage {\n\t\tapp.startupMessage(ln.Addr().String(), getTLSConfig(ln) != nil, \"\", cfg)\n\t}\n\n\t// Print routes\n\tif cfg.EnablePrintRoutes {\n\t\tapp.printRoutesMessage()\n\t}\n}\n\n// prepareListenData create an slice of ListenData\nfunc (*App) prepareListenData(addr string, isTLS bool, cfg ListenConfig) ListenData { //revive:disable-line:flag-parameter // Accepting a bool param named isTLS if fine here\n\thost, port := parseAddr(addr)\n\tif host == \"\" {\n\t\tif cfg.ListenerNetwork == NetworkTCP6 {\n\t\t\thost = \"[::1]\"\n\t\t} else {\n\t\t\thost = globalIpv4Addr\n\t\t}\n\t}\n\n\treturn ListenData{\n\t\tHost: host,\n\t\tPort: port,\n\t\tTLS:  isTLS,\n\t}\n}\n\n// startupMessage prepares the startup message with the handler number, port, address and other information\nfunc (app *App) startupMessage(addr string, isTLS bool, pids string, cfg ListenConfig) { //nolint: revive // Accepting a bool param named isTLS if fine here\n\t// ignore child processes\n\tif IsChild() {\n\t\treturn\n\t}\n\n\t// Alias colors\n\tcolors := app.config.ColorScheme\n\n\thost, port := parseAddr(addr)\n\tif host == \"\" {\n\t\tif cfg.ListenerNetwork == NetworkTCP6 {\n\t\t\thost = \"[::1]\"\n\t\t} else {\n\t\t\thost = globalIpv4Addr\n\t\t}\n\t}\n\n\tscheme := schemeHTTP\n\tif isTLS {\n\t\tscheme = schemeHTTPS\n\t}\n\n\tisPrefork := \"Disabled\"\n\tif cfg.EnablePrefork {\n\t\tisPrefork = \"Enabled\"\n\t}\n\n\tprocs := strconv.Itoa(runtime.GOMAXPROCS(0))\n\tif !cfg.EnablePrefork {\n\t\tprocs = \"1\"\n\t}\n\n\tout := colorable.NewColorableStdout()\n\tif os.Getenv(\"TERM\") == \"dumb\" || os.Getenv(\"NO_COLOR\") == \"1\" || (!isatty.IsTerminal(os.Stdout.Fd()) && !isatty.IsCygwinTerminal(os.Stdout.Fd())) {\n\t\tout = colorable.NewNonColorable(os.Stdout)\n\t}\n\n\tfmt.Fprintf(out, \"%s\\n\", fmt.Sprintf(figletFiberText, colors.Red+\"v\"+Version+colors.Reset)) //nolint:errcheck,revive // ignore error\n\tfmt.Fprintf(out, strings.Repeat(\"-\", 50)+\"\\n\")                                              //nolint:errcheck,revive,govet // ignore error\n\n\tif host == \"0.0.0.0\" {\n\t\t//nolint:errcheck,revive // ignore error\n\t\tfmt.Fprintf(out,\n\t\t\t\"%sINFO%s Server started on: \\t%s%s://127.0.0.1:%s%s (bound on host 0.0.0.0 and port %s)\\n\",\n\t\t\tcolors.Green, colors.Reset, colors.Blue, scheme, port, colors.Reset, port)\n\t} else {\n\t\t//nolint:errcheck,revive // ignore error\n\t\tfmt.Fprintf(out,\n\t\t\t\"%sINFO%s Server started on: \\t%s%s%s\\n\",\n\t\t\tcolors.Green, colors.Reset, colors.Blue, fmt.Sprintf(\"%s://%s:%s\", scheme, host, port), colors.Reset)\n\t}\n\n\tif app.config.AppName != \"\" {\n\t\tfmt.Fprintf(out, \"%sINFO%s Application name: \\t\\t%s%s%s\\n\", colors.Green, colors.Reset, colors.Blue, app.config.AppName, colors.Reset) //nolint:errcheck,revive // ignore error\n\t}\n\n\t//nolint:errcheck,revive // ignore error\n\tfmt.Fprintf(out,\n\t\t\"%sINFO%s Total handlers count: \\t%s%s%s\\n\",\n\t\tcolors.Green, colors.Reset, colors.Blue, strconv.Itoa(int(app.handlersCount)), colors.Reset)\n\n\tif isPrefork == \"Enabled\" {\n\t\tfmt.Fprintf(out, \"%sINFO%s Prefork: \\t\\t\\t%s%s%s\\n\", colors.Green, colors.Reset, colors.Blue, isPrefork, colors.Reset) //nolint:errcheck,revive // ignore error\n\t} else {\n\t\tfmt.Fprintf(out, \"%sINFO%s Prefork: \\t\\t\\t%s%s%s\\n\", colors.Green, colors.Reset, colors.Red, isPrefork, colors.Reset) //nolint:errcheck,revive // ignore error\n\t}\n\n\tfmt.Fprintf(out, \"%sINFO%s PID: \\t\\t\\t%s%v%s\\n\", colors.Green, colors.Reset, colors.Blue, os.Getpid(), colors.Reset)       //nolint:errcheck,revive // ignore error\n\tfmt.Fprintf(out, \"%sINFO%s Total process count: \\t%s%s%s\\n\", colors.Green, colors.Reset, colors.Blue, procs, colors.Reset) //nolint:errcheck,revive // ignore error\n\n\tif cfg.EnablePrefork {\n\t\t// Turn the `pids` variable (in the form \",a,b,c,d,e,f,etc\") into a slice of PIDs\n\t\tpidSlice := make([]string, 0)\n\t\tfor _, v := range strings.Split(pids, \",\") {\n\t\t\tif v != \"\" {\n\t\t\t\tpidSlice = append(pidSlice, v)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintf(out, \"%sINFO%s Child PIDs: \\t\\t%s\", colors.Green, colors.Reset, colors.Blue) //nolint:errcheck,revive // ignore error\n\t\ttotalPids := len(pidSlice)\n\t\trowTotalPidCount := 10\n\n\t\tfor i := 0; i < totalPids; i += rowTotalPidCount {\n\t\t\tstart := i\n\t\t\tend := i + rowTotalPidCount\n\n\t\t\tif end > totalPids {\n\t\t\t\tend = totalPids\n\t\t\t}\n\n\t\t\tfor n, pid := range pidSlice[start:end] {\n\t\t\t\tfmt.Fprintf(out, \"%s\", pid) //nolint:errcheck,revive // ignore error\n\t\t\t\tif n+1 != len(pidSlice[start:end]) {\n\t\t\t\t\tfmt.Fprintf(out, \", \") //nolint:errcheck,revive // ignore error\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Fprintf(out, \"\\n%s\", colors.Reset) //nolint:errcheck,revive // ignore error\n\t\t}\n\t}\n\n\t// add new Line as spacer\n\tfmt.Fprintf(out, \"\\n%s\", colors.Reset) //nolint:errcheck,revive // ignore error\n}\n\n// printRoutesMessage print all routes with method, path, name and handlers\n// in a format of table, like this:\n// method | path | name      | handlers\n// GET    | /    | routeName | github.com/gofiber/fiber/v3.emptyHandler\n// HEAD   | /    |           | github.com/gofiber/fiber/v3.emptyHandler\nfunc (app *App) printRoutesMessage() {\n\t// ignore child processes\n\tif IsChild() {\n\t\treturn\n\t}\n\n\t// Alias colors\n\tcolors := app.config.ColorScheme\n\n\tvar routes []RouteMessage\n\tfor _, routeStack := range app.stack {\n\t\tfor _, route := range routeStack {\n\t\t\tvar newRoute RouteMessage\n\t\t\tnewRoute.name = route.Name\n\t\t\tnewRoute.method = route.Method\n\t\t\tnewRoute.path = route.Path\n\t\t\tfor _, handler := range route.Handlers {\n\t\t\t\tnewRoute.handlers += runtime.FuncForPC(reflect.ValueOf(handler).Pointer()).Name() + \" \"\n\t\t\t}\n\t\t\troutes = append(routes, newRoute)\n\t\t}\n\t}\n\n\tout := colorable.NewColorableStdout()\n\tif os.Getenv(\"TERM\") == \"dumb\" || os.Getenv(\"NO_COLOR\") == \"1\" || (!isatty.IsTerminal(os.Stdout.Fd()) && !isatty.IsCygwinTerminal(os.Stdout.Fd())) {\n\t\tout = colorable.NewNonColorable(os.Stdout)\n\t}\n\n\tw := tabwriter.NewWriter(out, 1, 1, 1, ' ', 0)\n\t// Sort routes by path\n\tsort.Slice(routes, func(i, j int) bool {\n\t\treturn routes[i].path < routes[j].path\n\t})\n\n\tfmt.Fprintf(w, \"%smethod\\t%s| %spath\\t%s| %sname\\t%s| %shandlers\\t%s\\n\", colors.Blue, colors.White, colors.Green, colors.White, colors.Cyan, colors.White, colors.Yellow, colors.Reset) //nolint:errcheck,revive // ignore error\n\tfmt.Fprintf(w, \"%s------\\t%s| %s----\\t%s| %s----\\t%s| %s--------\\t%s\\n\", colors.Blue, colors.White, colors.Green, colors.White, colors.Cyan, colors.White, colors.Yellow, colors.Reset) //nolint:errcheck,revive // ignore error\n\n\tfor _, route := range routes {\n\t\t//nolint:errcheck,revive // ignore error\n\t\tfmt.Fprintf(w, \"%s%s\\t%s| %s%s\\t%s| %s%s\\t%s| %s%s%s\\n\", colors.Blue, route.method, colors.White, colors.Green, route.path, colors.White, colors.Cyan, route.name, colors.White, colors.Yellow, route.handlers, colors.Reset)\n\t}\n\n\t_ = w.Flush() //nolint:errcheck // It is fine to ignore the error here\n}\n\n// shutdown goroutine\nfunc (app *App) gracefulShutdown(ctx context.Context, cfg ListenConfig) {\n\t<-ctx.Done()\n\n\tvar err error\n\n\tif cfg.ShutdownTimeout != 0 {\n\t\terr = app.ShutdownWithTimeout(cfg.ShutdownTimeout) //nolint:contextcheck // TODO: Implement it\n\t} else {\n\t\terr = app.Shutdown() //nolint:contextcheck // TODO: Implement it\n\t}\n\n\tif err != nil {\n\t\tcfg.OnShutdownError(err)\n\t\treturn\n\t}\n\n\tif success := cfg.OnShutdownSuccess; success != nil {\n\t\tsuccess()\n\t}\n}\n"
        },
        {
          "name": "listen_test.go",
          "type": "blob",
          "size": 16.9,
          "content": "package fiber\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\" //nolint:depguard // TODO: Required to capture output, use internal log package instead\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/fasthttp\"\n\t\"github.com/valyala/fasthttp/fasthttputil\"\n)\n\n// go test -run Test_Listen\nfunc Test_Listen(t *testing.T) {\n\tapp := New()\n\n\trequire.Error(t, app.Listen(\":99999\"))\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":4003\", ListenConfig{DisableStartupMessage: true}))\n}\n\n// go test -run Test_Listen_Graceful_Shutdown\nfunc Test_Listen_Graceful_Shutdown(t *testing.T) {\n\tvar mu sync.Mutex\n\tvar shutdown bool\n\n\tapp := New()\n\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(c.Hostname())\n\t})\n\n\tln := fasthttputil.NewInmemoryListener()\n\terrs := make(chan error)\n\n\tgo func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\t\tdefer cancel()\n\n\t\terrs <- app.Listener(ln, ListenConfig{\n\t\t\tDisableStartupMessage: true,\n\t\t\tGracefulContext:       ctx,\n\t\t\tOnShutdownSuccess: func() {\n\t\t\t\tmu.Lock()\n\t\t\t\tshutdown = true\n\t\t\t\tmu.Unlock()\n\t\t\t},\n\t\t})\n\t}()\n\n\t// Server readiness check\n\tfor i := 0; i < 10; i++ {\n\t\tconn, err := ln.Dial()\n\t\tif err == nil {\n\t\t\tconn.Close() //nolint:errcheck // ignore error\n\t\t\tbreak\n\t\t}\n\t\t// Wait a bit before retrying\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tif i == 9 {\n\t\t\tt.Fatalf(\"Server did not become ready in time: %v\", err)\n\t\t}\n\t}\n\n\ttestCases := []struct {\n\t\tExpectedErr        error\n\t\tExpectedBody       string\n\t\tTime               time.Duration\n\t\tExpectedStatusCode int\n\t}{\n\t\t{Time: 500 * time.Millisecond, ExpectedBody: \"example.com\", ExpectedStatusCode: StatusOK, ExpectedErr: nil},\n\t\t{Time: 3 * time.Second, ExpectedBody: \"\", ExpectedStatusCode: StatusOK, ExpectedErr: fasthttputil.ErrInmemoryListenerClosed},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttime.Sleep(tc.Time)\n\n\t\treq := fasthttp.AcquireRequest()\n\t\treq.SetRequestURI(\"http://example.com\")\n\n\t\tclient := fasthttp.HostClient{}\n\t\tclient.Dial = func(_ string) (net.Conn, error) { return ln.Dial() }\n\n\t\tresp := fasthttp.AcquireResponse()\n\t\terr := client.Do(req, resp)\n\n\t\trequire.Equal(t, tc.ExpectedErr, err)\n\t\trequire.Equal(t, tc.ExpectedStatusCode, resp.StatusCode())\n\t\trequire.Equal(t, tc.ExpectedBody, string(resp.Body()))\n\n\t\tfasthttp.ReleaseRequest(req)\n\t\tfasthttp.ReleaseResponse(resp)\n\t}\n\n\tmu.Lock()\n\terr := <-errs\n\trequire.True(t, shutdown)\n\trequire.NoError(t, err)\n\tmu.Unlock()\n}\n\n// go test -run Test_Listen_Graceful_Shutdown_Timeout\nfunc Test_Listen_Graceful_Shutdown_Timeout(t *testing.T) {\n\tvar mu sync.Mutex\n\tvar shutdownSuccess bool\n\tvar shutdownTimeoutError error\n\n\tapp := New()\n\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(c.Hostname())\n\t})\n\n\tln := fasthttputil.NewInmemoryListener()\n\terrs := make(chan error)\n\n\tgo func() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\t\tdefer cancel()\n\n\t\terrs <- app.Listener(ln, ListenConfig{\n\t\t\tDisableStartupMessage: true,\n\t\t\tGracefulContext:       ctx,\n\t\t\tShutdownTimeout:       500 * time.Millisecond,\n\t\t\tOnShutdownSuccess: func() {\n\t\t\t\tmu.Lock()\n\t\t\t\tshutdownSuccess = true\n\t\t\t\tmu.Unlock()\n\t\t\t},\n\t\t\tOnShutdownError: func(err error) {\n\t\t\t\tmu.Lock()\n\t\t\t\tshutdownTimeoutError = err\n\t\t\t\tmu.Unlock()\n\t\t\t},\n\t\t})\n\t}()\n\n\t// Server readiness check\n\tfor i := 0; i < 10; i++ {\n\t\tconn, err := ln.Dial()\n\t\t// To test a graceful shutdown timeout, do not close the connection.\n\t\tif err == nil {\n\t\t\t_ = conn\n\t\t\tbreak\n\t\t}\n\t\t// Wait a bit before retrying\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tif i == 9 {\n\t\t\tt.Fatalf(\"Server did not become ready in time: %v\", err)\n\t\t}\n\t}\n\n\ttestCases := []struct {\n\t\tExpectedErr             error\n\t\tExpectedShutdownError   error\n\t\tExpectedBody            string\n\t\tTime                    time.Duration\n\t\tExpectedStatusCode      int\n\t\tExpectedShutdownSuccess bool\n\t}{\n\t\t{\n\t\t\tTime:                    100 * time.Millisecond,\n\t\t\tExpectedBody:            \"example.com\",\n\t\t\tExpectedStatusCode:      StatusOK,\n\t\t\tExpectedErr:             nil,\n\t\t\tExpectedShutdownError:   nil,\n\t\t\tExpectedShutdownSuccess: false,\n\t\t},\n\t\t{\n\t\t\tTime:                    3 * time.Second,\n\t\t\tExpectedBody:            \"\",\n\t\t\tExpectedStatusCode:      StatusOK,\n\t\t\tExpectedErr:             fasthttputil.ErrInmemoryListenerClosed,\n\t\t\tExpectedShutdownError:   context.DeadlineExceeded,\n\t\t\tExpectedShutdownSuccess: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttime.Sleep(tc.Time)\n\n\t\treq := fasthttp.AcquireRequest()\n\t\treq.SetRequestURI(\"http://example.com\")\n\n\t\tclient := fasthttp.HostClient{}\n\t\tclient.Dial = func(_ string) (net.Conn, error) { return ln.Dial() }\n\n\t\tresp := fasthttp.AcquireResponse()\n\t\terr := client.Do(req, resp)\n\n\t\tif err == nil {\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tc.ExpectedStatusCode, resp.StatusCode())\n\t\t\trequire.Equal(t, tc.ExpectedBody, string(resp.Body()))\n\t\t} else {\n\t\t\trequire.ErrorIs(t, err, tc.ExpectedErr)\n\t\t}\n\n\t\tmu.Lock()\n\t\trequire.Equal(t, tc.ExpectedShutdownSuccess, shutdownSuccess)\n\t\trequire.Equal(t, tc.ExpectedShutdownError, shutdownTimeoutError)\n\t\tmu.Unlock()\n\n\t\tfasthttp.ReleaseRequest(req)\n\t\tfasthttp.ReleaseResponse(resp)\n\t}\n\n\tmu.Lock()\n\terr := <-errs\n\trequire.NoError(t, err)\n\tmu.Unlock()\n}\n\n// go test -run Test_Listen_Prefork\nfunc Test_Listen_Prefork(t *testing.T) {\n\ttestPreforkMaster = true\n\n\tapp := New()\n\n\trequire.NoError(t, app.Listen(\":99999\", ListenConfig{DisableStartupMessage: true, EnablePrefork: true}))\n}\n\n// go test -run Test_Listen_TLSMinVersion\nfunc Test_Listen_TLSMinVersion(t *testing.T) {\n\ttestPreforkMaster = true\n\n\tapp := New()\n\n\t// Invalid TLSMinVersion\n\trequire.Panics(t, func() {\n\t\t_ = app.Listen(\":443\", ListenConfig{TLSMinVersion: tls.VersionTLS10}) //nolint:errcheck // ignore error\n\t})\n\trequire.Panics(t, func() {\n\t\t_ = app.Listen(\":443\", ListenConfig{TLSMinVersion: tls.VersionTLS11}) //nolint:errcheck // ignore error\n\t})\n\n\t// Prefork\n\trequire.Panics(t, func() {\n\t\t_ = app.Listen(\":443\", ListenConfig{DisableStartupMessage: true, EnablePrefork: true, TLSMinVersion: tls.VersionTLS10}) //nolint:errcheck // ignore error\n\t})\n\trequire.Panics(t, func() {\n\t\t_ = app.Listen(\":443\", ListenConfig{DisableStartupMessage: true, EnablePrefork: true, TLSMinVersion: tls.VersionTLS11}) //nolint:errcheck // ignore error\n\t})\n\n\t// Valid TLSMinVersion\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{TLSMinVersion: tls.VersionTLS13}))\n\n\t// Valid TLSMinVersion with Prefork\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\trequire.NoError(t, app.Listen(\":99999\", ListenConfig{DisableStartupMessage: true, EnablePrefork: true, TLSMinVersion: tls.VersionTLS13}))\n}\n\n// go test -run Test_Listen_TLS\nfunc Test_Listen_TLS(t *testing.T) {\n\tapp := New()\n\n\t// invalid port\n\trequire.Error(t, app.Listen(\":99999\", ListenConfig{\n\t\tCertFile:    \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile: \"./.github/testdata/ssl.key\",\n\t}))\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{\n\t\tCertFile:    \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile: \"./.github/testdata/ssl.key\",\n\t}))\n}\n\n// go test -run Test_Listen_TLS_Prefork\nfunc Test_Listen_TLS_Prefork(t *testing.T) {\n\ttestPreforkMaster = true\n\n\tapp := New()\n\n\t// invalid key file content\n\trequire.Error(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tEnablePrefork:         true,\n\t\tCertFile:              \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile:           \"./.github/testdata/template.tmpl\",\n\t}))\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":99999\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tEnablePrefork:         true,\n\t\tCertFile:              \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile:           \"./.github/testdata/ssl.key\",\n\t}))\n}\n\n// go test -run Test_Listen_MutualTLS\nfunc Test_Listen_MutualTLS(t *testing.T) {\n\tapp := New()\n\n\t// invalid port\n\trequire.Error(t, app.Listen(\":99999\", ListenConfig{\n\t\tCertFile:       \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile:    \"./.github/testdata/ssl.key\",\n\t\tCertClientFile: \"./.github/testdata/ca-chain.cert.pem\",\n\t}))\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{\n\t\tCertFile:       \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile:    \"./.github/testdata/ssl.key\",\n\t\tCertClientFile: \"./.github/testdata/ca-chain.cert.pem\",\n\t}))\n}\n\n// go test -run Test_Listen_MutualTLS_Prefork\nfunc Test_Listen_MutualTLS_Prefork(t *testing.T) {\n\ttestPreforkMaster = true\n\n\tapp := New()\n\n\t// invalid key file content\n\trequire.Error(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tEnablePrefork:         true,\n\t\tCertFile:              \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile:           \"./.github/testdata/template.html\",\n\t\tCertClientFile:        \"./.github/testdata/ca-chain.cert.pem\",\n\t}))\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":99999\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tEnablePrefork:         true,\n\t\tCertFile:              \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile:           \"./.github/testdata/ssl.key\",\n\t\tCertClientFile:        \"./.github/testdata/ca-chain.cert.pem\",\n\t}))\n}\n\n// go test -run Test_Listener\nfunc Test_Listener(t *testing.T) {\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\tln := fasthttputil.NewInmemoryListener()\n\trequire.NoError(t, app.Listener(ln))\n}\n\nfunc Test_App_Listener_TLS_Listener(t *testing.T) {\n\t// Create tls certificate\n\tcer, err := tls.LoadX509KeyPair(\"./.github/testdata/ssl.pem\", \"./.github/testdata/ssl.key\")\n\tif err != nil {\n\t\trequire.NoError(t, err)\n\t}\n\t//nolint:gosec // We're in a test so using old ciphers is fine\n\tconfig := &tls.Config{Certificates: []tls.Certificate{cer}}\n\n\t//nolint:gosec // We're in a test so listening on all interfaces is fine\n\tln, err := tls.Listen(NetworkTCP4, \":0\", config)\n\trequire.NoError(t, err)\n\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listener(ln))\n}\n\n// go test -run Test_Listen_TLSConfigFunc\nfunc Test_Listen_TLSConfigFunc(t *testing.T) {\n\tvar callTLSConfig bool\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tTLSConfigFunc: func(_ *tls.Config) {\n\t\t\tcallTLSConfig = true\n\t\t},\n\t\tCertFile:    \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile: \"./.github/testdata/ssl.key\",\n\t}))\n\n\trequire.True(t, callTLSConfig)\n}\n\n// go test -run Test_Listen_ListenerAddrFunc\nfunc Test_Listen_ListenerAddrFunc(t *testing.T) {\n\tvar network string\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tListenerAddrFunc: func(addr net.Addr) {\n\t\t\tnetwork = addr.Network()\n\t\t},\n\t\tCertFile:    \"./.github/testdata/ssl.pem\",\n\t\tCertKeyFile: \"./.github/testdata/ssl.key\",\n\t}))\n\n\trequire.Equal(t, \"tcp\", network)\n}\n\n// go test -run Test_Listen_BeforeServeFunc\nfunc Test_Listen_BeforeServeFunc(t *testing.T) {\n\tvar handlers uint32\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\twantErr := errors.New(\"test\")\n\trequire.ErrorIs(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tBeforeServeFunc: func(fiber *App) error {\n\t\t\thandlers = fiber.HandlersCount()\n\n\t\t\treturn wantErr\n\t\t},\n\t}), wantErr)\n\n\trequire.Zero(t, handlers)\n}\n\n// go test -run Test_Listen_ListenerNetwork\nfunc Test_Listen_ListenerNetwork(t *testing.T) {\n\tvar network string\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tListenerNetwork:       NetworkTCP6,\n\t\tListenerAddrFunc: func(addr net.Addr) {\n\t\t\tnetwork = addr.String()\n\t\t},\n\t}))\n\n\trequire.Contains(t, network, \"[::]:\")\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.Listen(\":0\", ListenConfig{\n\t\tDisableStartupMessage: true,\n\t\tListenerNetwork:       NetworkTCP4,\n\t\tListenerAddrFunc: func(addr net.Addr) {\n\t\t\tnetwork = addr.String()\n\t\t},\n\t}))\n\n\trequire.Contains(t, network, \"0.0.0.0:\")\n}\n\n// go test -run Test_Listen_Master_Process_Show_Startup_Message\nfunc Test_Listen_Master_Process_Show_Startup_Message(t *testing.T) {\n\tcfg := ListenConfig{\n\t\tEnablePrefork: true,\n\t}\n\n\tstartupMessage := captureOutput(func() {\n\t\tNew().\n\t\t\tstartupMessage(\":3000\", true, strings.Repeat(\",11111,22222,33333,44444,55555,60000\", 10), cfg)\n\t})\n\tcolors := Colors{}\n\trequire.Contains(t, startupMessage, \"https://127.0.0.1:3000\")\n\trequire.Contains(t, startupMessage, \"(bound on host 0.0.0.0 and port 3000)\")\n\trequire.Contains(t, startupMessage, \"Child PIDs\")\n\trequire.Contains(t, startupMessage, \"11111, 22222, 33333, 44444, 55555, 60000\")\n\trequire.Contains(t, startupMessage, fmt.Sprintf(\"Prefork: \\t\\t\\t%sEnabled%s\", colors.Blue, colors.Reset))\n}\n\n// go test -run Test_Listen_Master_Process_Show_Startup_MessageWithAppName\nfunc Test_Listen_Master_Process_Show_Startup_MessageWithAppName(t *testing.T) {\n\tcfg := ListenConfig{\n\t\tEnablePrefork: true,\n\t}\n\n\tapp := New(Config{AppName: \"Test App v3.0.0\"})\n\tstartupMessage := captureOutput(func() {\n\t\tapp.startupMessage(\":3000\", true, strings.Repeat(\",11111,22222,33333,44444,55555,60000\", 10), cfg)\n\t})\n\trequire.Equal(t, \"Test App v3.0.0\", app.Config().AppName)\n\trequire.Contains(t, startupMessage, app.Config().AppName)\n}\n\n// go test -run Test_Listen_Master_Process_Show_Startup_MessageWithAppNameNonAscii\nfunc Test_Listen_Master_Process_Show_Startup_MessageWithAppNameNonAscii(t *testing.T) {\n\tcfg := ListenConfig{\n\t\tEnablePrefork: true,\n\t}\n\n\tappName := \"Serveur de vérification des données\"\n\tapp := New(Config{AppName: appName})\n\n\tstartupMessage := captureOutput(func() {\n\t\tapp.startupMessage(\":3000\", false, \"\", cfg)\n\t})\n\trequire.Contains(t, startupMessage, \"Serveur de vérification des données\")\n}\n\n// go test -run Test_Listen_Master_Process_Show_Startup_MessageWithDisabledPreforkAndCustomEndpoint\nfunc Test_Listen_Master_Process_Show_Startup_MessageWithDisabledPreforkAndCustomEndpoint(t *testing.T) {\n\tcfg := ListenConfig{\n\t\tEnablePrefork: false,\n\t}\n\n\tappName := \"Fiber Example Application\"\n\tapp := New(Config{AppName: appName})\n\tstartupMessage := captureOutput(func() {\n\t\tapp.startupMessage(\"server.com:8081\", true, strings.Repeat(\",11111,22222,33333,44444,55555,60000\", 5), cfg)\n\t})\n\tcolors := Colors{}\n\trequire.Contains(t, startupMessage, fmt.Sprintf(\"%sINFO%s\", colors.Green, colors.Reset))\n\trequire.Contains(t, startupMessage, fmt.Sprintf(\"%s%s%s\", colors.Blue, appName, colors.Reset))\n\trequire.Contains(t, startupMessage, fmt.Sprintf(\"%s%s%s\", colors.Blue, \"https://server.com:8081\", colors.Reset))\n\trequire.Contains(t, startupMessage, fmt.Sprintf(\"Prefork: \\t\\t\\t%sDisabled%s\", colors.Red, colors.Reset))\n}\n\n// go test -run Test_Listen_Print_Route\nfunc Test_Listen_Print_Route(t *testing.T) {\n\tapp := New()\n\tapp.Get(\"/\", emptyHandler).Name(\"routeName\")\n\tprintRoutesMessage := captureOutput(func() {\n\t\tapp.printRoutesMessage()\n\t})\n\trequire.Contains(t, printRoutesMessage, MethodGet)\n\trequire.Contains(t, printRoutesMessage, \"/\")\n\trequire.Contains(t, printRoutesMessage, \"emptyHandler\")\n\trequire.Contains(t, printRoutesMessage, \"routeName\")\n}\n\n// go test -run Test_Listen_Print_Route_With_Group\nfunc Test_Listen_Print_Route_With_Group(t *testing.T) {\n\tapp := New()\n\tapp.Get(\"/\", emptyHandler)\n\n\tv1 := app.Group(\"v1\")\n\tv1.Get(\"/test\", emptyHandler).Name(\"v1\")\n\tv1.Post(\"/test/fiber\", emptyHandler)\n\tv1.Put(\"/test/fiber/*\", emptyHandler)\n\n\tprintRoutesMessage := captureOutput(func() {\n\t\tapp.printRoutesMessage()\n\t})\n\n\trequire.Contains(t, printRoutesMessage, MethodGet)\n\trequire.Contains(t, printRoutesMessage, \"/\")\n\trequire.Contains(t, printRoutesMessage, \"emptyHandler\")\n\trequire.Contains(t, printRoutesMessage, \"/v1/test\")\n\trequire.Contains(t, printRoutesMessage, \"POST\")\n\trequire.Contains(t, printRoutesMessage, \"/v1/test/fiber\")\n\trequire.Contains(t, printRoutesMessage, \"PUT\")\n\trequire.Contains(t, printRoutesMessage, \"/v1/test/fiber/*\")\n}\n\nfunc captureOutput(f func()) string {\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tstdout := os.Stdout\n\tstderr := os.Stderr\n\tdefer func() {\n\t\tos.Stdout = stdout\n\t\tos.Stderr = stderr\n\t\tlog.SetOutput(os.Stderr)\n\t}()\n\tos.Stdout = writer\n\tos.Stderr = writer\n\tlog.SetOutput(writer)\n\tout := make(chan string)\n\twg := new(sync.WaitGroup)\n\twg.Add(1)\n\tgo func() {\n\t\tvar buf bytes.Buffer\n\t\twg.Done()\n\t\t_, err := io.Copy(&buf, reader)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tout <- buf.String()\n\t}()\n\twg.Wait()\n\tf()\n\terr = writer.Close()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn <-out\n}\n\nfunc emptyHandler(_ Ctx) error {\n\treturn nil\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "middleware",
          "type": "tree",
          "content": null
        },
        {
          "name": "mount.go",
          "type": "blob",
          "size": 7.03,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"sort\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/gofiber/utils/v2\"\n)\n\n// Put fields related to mounting.\ntype mountFields struct {\n\t// Mounted and main apps\n\tappList map[string]*App\n\t// Prefix of app if it was mounted\n\tmountPath string\n\t// Ordered keys of apps (sorted by key length for Render)\n\tappListKeys []string\n\t// check added routes of sub-apps\n\tsubAppsRoutesAdded sync.Once\n\t// check mounted sub-apps\n\tsubAppsProcessed sync.Once\n}\n\n// Create empty mountFields instance\nfunc newMountFields(app *App) *mountFields {\n\treturn &mountFields{\n\t\tappList:     map[string]*App{\"\": app},\n\t\tappListKeys: make([]string, 0),\n\t}\n}\n\n// Mount attaches another app instance as a sub-router along a routing path.\n// It's very useful to split up a large API as many independent routers and\n// compose them as a single service using Mount. The fiber's error handler and\n// any of the fiber's sub apps are added to the application's error handlers\n// to be invoked on errors that happen within the prefix route.\nfunc (app *App) mount(prefix string, subApp *App) Router {\n\tprefix = utils.TrimRight(prefix, '/')\n\tif prefix == \"\" {\n\t\tprefix = \"/\"\n\t}\n\n\t// Support for configs of mounted-apps and sub-mounted-apps\n\tfor mountedPrefixes, subApp := range subApp.mountFields.appList {\n\t\tpath := getGroupPath(prefix, mountedPrefixes)\n\n\t\tsubApp.mountFields.mountPath = path\n\t\tapp.mountFields.appList[path] = subApp\n\t}\n\n\t// register mounted group\n\tmountGroup := &Group{Prefix: prefix, app: subApp}\n\tapp.register([]string{methodUse}, prefix, mountGroup, nil)\n\n\t// Execute onMount hooks\n\tif err := subApp.hooks.executeOnMountHooks(app); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn app\n}\n\n// Mount attaches another app instance as a sub-router along a routing path.\n// It's very useful to split up a large API as many independent routers and\n// compose them as a single service using Mount.\nfunc (grp *Group) mount(prefix string, subApp *App) Router {\n\tgroupPath := getGroupPath(grp.Prefix, prefix)\n\tgroupPath = utils.TrimRight(groupPath, '/')\n\tif groupPath == \"\" {\n\t\tgroupPath = \"/\"\n\t}\n\n\t// Support for configs of mounted-apps and sub-mounted-apps\n\tfor mountedPrefixes, subApp := range subApp.mountFields.appList {\n\t\tpath := getGroupPath(groupPath, mountedPrefixes)\n\n\t\tsubApp.mountFields.mountPath = path\n\t\tgrp.app.mountFields.appList[path] = subApp\n\t}\n\n\t// register mounted group\n\tmountGroup := &Group{Prefix: groupPath, app: subApp}\n\tgrp.app.register([]string{methodUse}, groupPath, mountGroup, nil)\n\n\t// Execute onMount hooks\n\tif err := subApp.hooks.executeOnMountHooks(grp.app); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn grp\n}\n\n// The MountPath property contains one or more path patterns on which a sub-app was mounted.\nfunc (app *App) MountPath() string {\n\treturn app.mountFields.mountPath\n}\n\n// hasMountedApps Checks if there are any mounted apps in the current application.\nfunc (app *App) hasMountedApps() bool {\n\treturn len(app.mountFields.appList) > 1\n}\n\n// mountStartupProcess Handles the startup process of mounted apps by appending sub-app routes, generating app list keys, and processing sub-app routes.\nfunc (app *App) mountStartupProcess() {\n\tif app.hasMountedApps() {\n\t\t// add routes of sub-apps\n\t\tapp.mountFields.subAppsProcessed.Do(func() {\n\t\t\tapp.appendSubAppLists(app.mountFields.appList)\n\t\t\tapp.generateAppListKeys()\n\t\t})\n\t\t// adds the routes of the sub-apps to the current application.\n\t\tapp.mountFields.subAppsRoutesAdded.Do(func() {\n\t\t\tapp.processSubAppsRoutes()\n\t\t})\n\t}\n}\n\n// generateAppListKeys generates app list keys for Render, should work after appendSubAppLists\nfunc (app *App) generateAppListKeys() {\n\tfor key := range app.mountFields.appList {\n\t\tapp.mountFields.appListKeys = append(app.mountFields.appListKeys, key)\n\t}\n\n\tsort.Slice(app.mountFields.appListKeys, func(i, j int) bool {\n\t\treturn len(app.mountFields.appListKeys[i]) < len(app.mountFields.appListKeys[j])\n\t})\n}\n\n// appendSubAppLists supports nested for sub apps\nfunc (app *App) appendSubAppLists(appList map[string]*App, parent ...string) {\n\t// Optimize: Cache parent prefix\n\tparentPrefix := \"\"\n\tif len(parent) > 0 {\n\t\tparentPrefix = parent[0]\n\t}\n\n\tfor prefix, subApp := range appList {\n\t\t// skip real app\n\t\tif prefix == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif parentPrefix != \"\" {\n\t\t\tprefix = getGroupPath(parentPrefix, prefix)\n\t\t}\n\n\t\tif _, ok := app.mountFields.appList[prefix]; !ok {\n\t\t\tapp.mountFields.appList[prefix] = subApp\n\t\t}\n\n\t\t// The first element of appList is always the app itself. If there are no other sub apps, we should skip appending nested apps.\n\t\tif len(subApp.mountFields.appList) > 1 {\n\t\t\tapp.appendSubAppLists(subApp.mountFields.appList, prefix)\n\t\t}\n\t}\n}\n\n// processSubAppsRoutes adds routes of sub-apps recursively when the server is started\nfunc (app *App) processSubAppsRoutes() {\n\tfor prefix, subApp := range app.mountFields.appList {\n\t\t// skip real app\n\t\tif prefix == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\t// process the inner routes\n\t\tif subApp.hasMountedApps() {\n\t\t\tsubApp.mountFields.subAppsRoutesAdded.Do(func() {\n\t\t\t\tsubApp.processSubAppsRoutes()\n\t\t\t})\n\t\t}\n\t}\n\tvar handlersCount uint32\n\tvar routePos uint32\n\t// Iterate over the stack of the parent app\n\tfor m := range app.stack {\n\t\t// Iterate over each route in the stack\n\t\tstackLen := len(app.stack[m])\n\t\tfor i := 0; i < stackLen; i++ {\n\t\t\troute := app.stack[m][i]\n\t\t\t// Check if the route has a mounted app\n\t\t\tif !route.mount {\n\t\t\t\troutePos++\n\t\t\t\t// If not, update the route's position and continue\n\t\t\t\troute.pos = routePos\n\t\t\t\tif !route.use || (route.use && m == 0) {\n\t\t\t\t\thandlersCount += uint32(len(route.Handlers)) //nolint:gosec // Not a concern\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Create a slice to hold the sub-app's routes\n\t\t\tsubRoutes := make([]*Route, len(route.group.app.stack[m]))\n\n\t\t\t// Iterate over the sub-app's routes\n\t\t\tfor j, subAppRoute := range route.group.app.stack[m] {\n\t\t\t\t// Clone the sub-app's route\n\t\t\t\tsubAppRouteClone := app.copyRoute(subAppRoute)\n\n\t\t\t\t// Add the parent route's path as a prefix to the sub-app's route\n\t\t\t\tapp.addPrefixToRoute(route.path, subAppRouteClone)\n\n\t\t\t\t// Add the cloned sub-app's route to the slice of sub-app routes\n\t\t\t\tsubRoutes[j] = subAppRouteClone\n\t\t\t}\n\n\t\t\t// Insert the sub-app's routes into the parent app's stack\n\t\t\tnewStack := make([]*Route, len(app.stack[m])+len(subRoutes)-1)\n\t\t\tcopy(newStack[:i], app.stack[m][:i])\n\t\t\tcopy(newStack[i:i+len(subRoutes)], subRoutes)\n\t\t\tcopy(newStack[i+len(subRoutes):], app.stack[m][i+1:])\n\t\t\tapp.stack[m] = newStack\n\n\t\t\t// Decrease the parent app's route count to account for the mounted app's original route\n\t\t\tatomic.AddUint32(&app.routesCount, ^uint32(0))\n\t\t\ti--\n\t\t\t// Increase the parent app's route count to account for the sub-app's routes\n\t\t\tatomic.AddUint32(&app.routesCount, uint32(len(subRoutes))) //nolint:gosec // Not a concern\n\n\t\t\t// Mark the parent app's routes as refreshed\n\t\t\tapp.routesRefreshed = true\n\t\t\t// update stackLen after appending subRoutes to app.stack[m]\n\t\t\tstackLen = len(app.stack[m])\n\t\t}\n\t}\n\tatomic.StoreUint32(&app.handlersCount, handlersCount)\n}\n"
        },
        {
          "name": "mount_test.go",
          "type": "blob",
          "size": 16.33,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\n// go test -run Test_App_Mount\nfunc Test_App_Mount(t *testing.T) {\n\tt.Parallel()\n\tmicro := New()\n\tmicro.Get(\"/doe\", func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t})\n\n\tapp := New()\n\tapp.Use(\"/john\", micro)\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/john/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\trequire.Equal(t, uint32(1), app.handlersCount)\n}\n\nfunc Test_App_Mount_RootPath_Nested(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tdynamic := New()\n\tapiserver := New()\n\n\tapiroutes := apiserver.Group(\"/v1\")\n\tapiroutes.Get(\"/home\", func(c Ctx) error {\n\t\treturn c.SendString(\"home\")\n\t})\n\n\tdynamic.Use(\"/api\", apiserver)\n\tapp.Use(\"/\", dynamic)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/api/v1/home\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\trequire.Equal(t, uint32(1), app.handlersCount)\n}\n\n// go test -run Test_App_Mount_Nested\nfunc Test_App_Mount_Nested(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tone := New()\n\ttwo := New()\n\tthree := New()\n\n\ttwo.Use(\"/three\", three)\n\tapp.Use(\"/one\", one)\n\tone.Use(\"/two\", two)\n\n\tone.Get(\"/doe\", func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t})\n\n\ttwo.Get(\"/nested\", func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t})\n\n\tthree.Get(\"/test\", func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/one/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/one/two/nested\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/one/two/three/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\trequire.Equal(t, uint32(3), app.handlersCount)\n\trequire.Equal(t, uint32(3), app.routesCount)\n}\n\n// go test -run Test_App_Mount_Express_Behavior\nfunc Test_App_Mount_Express_Behavior(t *testing.T) {\n\tt.Parallel()\n\tcreateTestHandler := func(body string) func(c Ctx) error {\n\t\treturn func(c Ctx) error {\n\t\t\treturn c.SendString(body)\n\t\t}\n\t}\n\ttestEndpoint := func(app *App, route, expectedBody string, expectedStatusCode int) {\n\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, route, nil))\n\t\trequire.NoError(t, err, \"app.Test(req)\")\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, expectedStatusCode, resp.StatusCode, \"Status code\")\n\t\trequire.Equal(t, expectedBody, string(body), \"Unexpected response body\")\n\t}\n\n\tapp := New()\n\tsubApp := New()\n\t// app setup\n\t{\n\t\tsubApp.Get(\"/hello\", createTestHandler(\"subapp hello!\"))\n\t\tsubApp.Get(\"/world\", createTestHandler(\"subapp world!\")) // <- wins\n\n\t\tapp.Get(\"/hello\", createTestHandler(\"app hello!\")) // <- wins\n\t\tapp.Use(\"/\", subApp)                               // <- subApp registration\n\t\tapp.Get(\"/world\", createTestHandler(\"app world!\"))\n\n\t\tapp.Get(\"/bar\", createTestHandler(\"app bar!\"))\n\t\tsubApp.Get(\"/bar\", createTestHandler(\"subapp bar!\")) // <- wins\n\n\t\tsubApp.Get(\"/foo\", createTestHandler(\"subapp foo!\")) // <- wins\n\t\tapp.Get(\"/foo\", createTestHandler(\"app foo!\"))\n\n\t\t// 404 Handler\n\t\tapp.Use(func(c Ctx) error {\n\t\t\treturn c.SendStatus(StatusNotFound)\n\t\t})\n\t}\n\t// expectation check\n\ttestEndpoint(app, \"/world\", \"subapp world!\", StatusOK)\n\ttestEndpoint(app, \"/hello\", \"app hello!\", StatusOK)\n\ttestEndpoint(app, \"/bar\", \"subapp bar!\", StatusOK)\n\ttestEndpoint(app, \"/foo\", \"subapp foo!\", StatusOK)\n\ttestEndpoint(app, \"/unknown\", ErrNotFound.Message, StatusNotFound)\n\n\trequire.Equal(t, uint32(9), app.handlersCount)\n\trequire.Equal(t, uint32(17), app.routesCount)\n}\n\n// go test -run Test_App_Mount_RoutePositions\nfunc Test_App_Mount_RoutePositions(t *testing.T) {\n\tt.Parallel()\n\ttestEndpoint := func(app *App, route, expectedBody string) {\n\t\tresp, err := app.Test(httptest.NewRequest(MethodGet, route, nil))\n\t\trequire.NoError(t, err, \"app.Test(req)\")\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\t\trequire.Equal(t, expectedBody, string(body), \"Unexpected response body\")\n\t}\n\n\tapp := New()\n\tsubApp1 := New()\n\tsubApp2 := New()\n\t// app setup\n\t{\n\t\tapp.Use(func(c Ctx) error {\n\t\t\t// set initial value\n\t\t\tc.Locals(\"world\", \"world\")\n\t\t\treturn c.Next()\n\t\t})\n\t\tapp.Use(\"/subApp1\", subApp1)\n\t\tapp.Use(func(c Ctx) error {\n\t\t\treturn c.Next()\n\t\t})\n\t\tapp.Get(\"/bar\", func(c Ctx) error {\n\t\t\treturn c.SendString(\"ok\")\n\t\t})\n\t\tapp.Use(func(c Ctx) error {\n\t\t\t// is overwritten in case the positioning is not correct\n\t\t\tc.Locals(\"world\", \"hello\")\n\t\t\treturn c.Next()\n\t\t})\n\t\tmethods := subApp2.Group(\"/subApp2\")\n\t\tmethods.Get(\"/world\", func(c Ctx) error {\n\t\t\tv, ok := c.Locals(\"world\").(string)\n\t\t\tif !ok {\n\t\t\t\tpanic(\"unexpected data type\")\n\t\t\t}\n\t\t\treturn c.SendString(v)\n\t\t})\n\t\tapp.Use(\"\", subApp2)\n\t}\n\n\ttestEndpoint(app, \"/subApp2/world\", \"hello\")\n\n\trouteStackGET := app.Stack()[0]\n\trequire.True(t, routeStackGET[0].use)\n\trequire.Equal(t, \"/\", routeStackGET[0].path)\n\n\trequire.True(t, routeStackGET[1].use)\n\trequire.Equal(t, \"/\", routeStackGET[1].path)\n\trequire.Less(t, routeStackGET[0].pos, routeStackGET[1].pos, \"wrong position of route 0\")\n\n\trequire.False(t, routeStackGET[2].use)\n\trequire.Equal(t, \"/bar\", routeStackGET[2].path)\n\trequire.Less(t, routeStackGET[1].pos, routeStackGET[2].pos, \"wrong position of route 1\")\n\n\trequire.True(t, routeStackGET[3].use)\n\trequire.Equal(t, \"/\", routeStackGET[3].path)\n\trequire.Less(t, routeStackGET[2].pos, routeStackGET[3].pos, \"wrong position of route 2\")\n\n\trequire.False(t, routeStackGET[4].use)\n\trequire.Equal(t, \"/subapp2/world\", routeStackGET[4].path)\n\trequire.Less(t, routeStackGET[3].pos, routeStackGET[4].pos, \"wrong position of route 3\")\n\n\trequire.Len(t, routeStackGET, 5)\n}\n\n// go test -run Test_App_MountPath\nfunc Test_App_MountPath(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tone := New()\n\ttwo := New()\n\tthree := New()\n\n\ttwo.Use(\"/three\", three)\n\tone.Use(\"/two\", two)\n\tapp.Use(\"/one\", one)\n\n\trequire.Equal(t, \"/one\", one.MountPath())\n\trequire.Equal(t, \"/one/two\", two.MountPath())\n\trequire.Equal(t, \"/one/two/three\", three.MountPath())\n\trequire.Equal(t, \"\", app.MountPath())\n}\n\nfunc Test_App_ErrorHandler_GroupMount(t *testing.T) {\n\tt.Parallel()\n\tmicro := New(Config{\n\t\tErrorHandler: func(c Ctx, err error) error {\n\t\t\trequire.Equal(t, \"0: GET error\", err.Error())\n\t\t\treturn c.Status(500).SendString(\"1: custom error\")\n\t\t},\n\t})\n\tmicro.Get(\"/doe\", func(_ Ctx) error {\n\t\treturn errors.New(\"0: GET error\")\n\t})\n\n\tapp := New()\n\tv1 := app.Group(\"/v1\")\n\tv1.Use(\"/john\", micro)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/v1/john/doe\", nil))\n\ttestErrorResponse(t, err, resp, \"1: custom error\")\n}\n\nfunc Test_App_ErrorHandler_GroupMountRootLevel(t *testing.T) {\n\tt.Parallel()\n\tmicro := New(Config{\n\t\tErrorHandler: func(c Ctx, err error) error {\n\t\t\trequire.Equal(t, \"0: GET error\", err.Error())\n\t\t\treturn c.Status(500).SendString(\"1: custom error\")\n\t\t},\n\t})\n\tmicro.Get(\"/john/doe\", func(_ Ctx) error {\n\t\treturn errors.New(\"0: GET error\")\n\t})\n\n\tapp := New()\n\tv1 := app.Group(\"/v1\")\n\tv1.Use(\"/\", micro)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/v1/john/doe\", nil))\n\ttestErrorResponse(t, err, resp, \"1: custom error\")\n}\n\n// go test -run Test_App_Group_Mount\nfunc Test_App_Group_Mount(t *testing.T) {\n\tt.Parallel()\n\tmicro := New()\n\tmicro.Get(\"/doe\", func(c Ctx) error {\n\t\treturn c.SendStatus(StatusOK)\n\t})\n\n\tapp := New()\n\tv1 := app.Group(\"/v1\")\n\tv1.Use(\"/john\", micro)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/v1/john/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\trequire.Equal(t, uint32(1), app.handlersCount)\n}\n\nfunc Test_App_UseParentErrorHandler(t *testing.T) {\n\tt.Parallel()\n\tapp := New(Config{\n\t\tErrorHandler: func(ctx Ctx, _ error) error {\n\t\t\treturn ctx.Status(500).SendString(\"hi, i'm a custom error\")\n\t\t},\n\t})\n\n\tfiber := New()\n\tfiber.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"something happened\")\n\t})\n\n\tapp.Use(\"/api\", fiber)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/api\", nil))\n\ttestErrorResponse(t, err, resp, \"hi, i'm a custom error\")\n}\n\nfunc Test_App_UseMountedErrorHandler(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tfiber := New(Config{\n\t\tErrorHandler: func(c Ctx, _ error) error {\n\t\t\treturn c.Status(500).SendString(\"hi, i'm a custom error\")\n\t\t},\n\t})\n\tfiber.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"something happened\")\n\t})\n\n\tapp.Use(\"/api\", fiber)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/api\", nil))\n\ttestErrorResponse(t, err, resp, \"hi, i'm a custom error\")\n}\n\nfunc Test_App_UseMountedErrorHandlerRootLevel(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tfiber := New(Config{\n\t\tErrorHandler: func(c Ctx, _ error) error {\n\t\t\treturn c.Status(500).SendString(\"hi, i'm a custom error\")\n\t\t},\n\t})\n\tfiber.Get(\"/api\", func(_ Ctx) error {\n\t\treturn errors.New(\"something happened\")\n\t})\n\n\tapp.Use(\"/\", fiber)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/api\", nil))\n\ttestErrorResponse(t, err, resp, \"hi, i'm a custom error\")\n}\n\nfunc Test_App_UseMountedErrorHandlerForBestPrefixMatch(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\ttsf := func(c Ctx, _ error) error {\n\t\treturn c.Status(200).SendString(\"hi, i'm a custom sub fiber error 2\")\n\t}\n\ttripleSubFiber := New(Config{\n\t\tErrorHandler: tsf,\n\t})\n\ttripleSubFiber.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"something happened\")\n\t})\n\n\tsf := func(c Ctx, _ error) error {\n\t\treturn c.Status(200).SendString(\"hi, i'm a custom sub fiber error\")\n\t}\n\tsubfiber := New(Config{\n\t\tErrorHandler: sf,\n\t})\n\tsubfiber.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"something happened\")\n\t})\n\tsubfiber.Use(\"/third\", tripleSubFiber)\n\n\tf := func(c Ctx, _ error) error {\n\t\treturn c.Status(200).SendString(\"hi, i'm a custom error\")\n\t}\n\tfiber := New(Config{\n\t\tErrorHandler: f,\n\t})\n\tfiber.Get(\"/\", func(_ Ctx) error {\n\t\treturn errors.New(\"something happened\")\n\t})\n\tfiber.Use(\"/sub\", subfiber)\n\n\tapp.Use(\"/api\", fiber)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/api/sub\", nil))\n\trequire.NoError(t, err, \"/api/sub req\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tb, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"iotuil.ReadAll()\")\n\trequire.Equal(t, \"hi, i'm a custom sub fiber error\", string(b), \"Response body\")\n\n\tresp2, err := app.Test(httptest.NewRequest(MethodGet, \"/api/sub/third\", nil))\n\trequire.NoError(t, err, \"/api/sub/third req\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tb, err = io.ReadAll(resp2.Body)\n\trequire.NoError(t, err, \"iotuil.ReadAll()\")\n\trequire.Equal(t, \"hi, i'm a custom sub fiber error 2\", string(b), \"Third fiber Response body\")\n}\n\n// go test -run Test_Mount_Route_Names\nfunc Test_Mount_Route_Names(t *testing.T) {\n\tt.Parallel()\n\t// create sub-app with 2 handlers:\n\tsubApp1 := New()\n\tsubApp1.Get(\"/users\", func(c Ctx) error {\n\t\turl, err := c.GetRouteURL(\"add-user\", Map{})\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"/app1/users\", url, \"handler: app1.add-user\") // the prefix is /app1 because of the mount\n\t\t// if subApp1 is not mounted, expected url just /users\n\t\treturn nil\n\t}).Name(\"get-users\")\n\tsubApp1.Post(\"/users\", func(c Ctx) error {\n\t\troute := c.App().GetRoute(\"get-users\")\n\t\trequire.Equal(t, MethodGet, route.Method, \"handler: app1.get-users method\")\n\t\trequire.Equal(t, \"/app1/users\", route.Path, \"handler: app1.get-users path\")\n\t\treturn nil\n\t}).Name(\"add-user\")\n\n\t// create sub-app with 2 handlers inside a group:\n\tsubApp2 := New()\n\tapp2Grp := subApp2.Group(\"/users\").Name(\"users.\")\n\tapp2Grp.Get(\"\", emptyHandler).Name(\"get\")\n\tapp2Grp.Post(\"\", emptyHandler).Name(\"add\")\n\n\t// put both sub-apps into root app\n\trootApp := New()\n\t_ = rootApp.Use(\"/app1\", subApp1)\n\t_ = rootApp.Use(\"/app2\", subApp2)\n\n\trootApp.startupProcess()\n\n\t// take route directly from sub-app\n\troute := subApp1.GetRoute(\"get-users\")\n\trequire.Equal(t, MethodGet, route.Method)\n\trequire.Equal(t, \"/users\", route.Path)\n\n\troute = subApp1.GetRoute(\"add-user\")\n\trequire.Equal(t, MethodPost, route.Method)\n\trequire.Equal(t, \"/users\", route.Path)\n\n\t// take route directly from sub-app with group\n\troute = subApp2.GetRoute(\"users.get\")\n\trequire.Equal(t, MethodGet, route.Method)\n\trequire.Equal(t, \"/users\", route.Path)\n\n\troute = subApp2.GetRoute(\"users.add\")\n\trequire.Equal(t, MethodPost, route.Method)\n\trequire.Equal(t, \"/users\", route.Path)\n\n\t// take route from root app (using names of sub-apps)\n\troute = rootApp.GetRoute(\"add-user\")\n\trequire.Equal(t, MethodPost, route.Method)\n\trequire.Equal(t, \"/app1/users\", route.Path)\n\n\troute = rootApp.GetRoute(\"users.add\")\n\trequire.Equal(t, MethodPost, route.Method)\n\trequire.Equal(t, \"/app2/users\", route.Path)\n\n\t// GetRouteURL inside handler\n\treq := httptest.NewRequest(MethodGet, \"/app1/users\", nil)\n\tresp, err := rootApp.Test(req)\n\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// ctx.App().GetRoute() inside handler\n\treq = httptest.NewRequest(MethodPost, \"/app1/users\", nil)\n\tresp, err = rootApp.Test(req)\n\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n}\n\n// go test -run Test_Ctx_Render_Mount\nfunc Test_Ctx_Render_Mount(t *testing.T) {\n\tt.Parallel()\n\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(t, err)\n\n\tsub := New(Config{\n\t\tViews: engine,\n\t})\n\n\tsub.Get(\"/:name\", func(c Ctx) error {\n\t\treturn c.Render(\"hello_world.tmpl\", Map{\n\t\t\t\"Name\": c.Params(\"name\"),\n\t\t})\n\t})\n\n\tapp := New()\n\tapp.Use(\"/hello\", sub)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/hello/a\", nil))\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.NoError(t, err, \"app.Test(req)\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello a!</h1>\", string(body))\n}\n\n// go test -run Test_Ctx_Render_Mount_ParentOrSubHasViews\nfunc Test_Ctx_Render_Mount_ParentOrSubHasViews(t *testing.T) {\n\tt.Parallel()\n\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(t, err)\n\n\tengine2 := &testTemplateEngine{path: \"testdata2\"}\n\terr = engine2.Load()\n\trequire.NoError(t, err)\n\n\tengine3 := &testTemplateEngine{path: \"testdata3\"}\n\terr = engine3.Load()\n\trequire.NoError(t, err)\n\n\tsub := New(Config{\n\t\tViews: engine3,\n\t})\n\n\tsub2 := New(Config{\n\t\tViews: engine2,\n\t})\n\n\tapp := New(Config{\n\t\tViews: engine,\n\t})\n\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\treturn c.Render(\"index.tmpl\", Map{\n\t\t\t\"Title\": \"Hello, World!\",\n\t\t})\n\t})\n\n\tsub.Get(\"/world/:name\", func(c Ctx) error {\n\t\treturn c.Render(\"hello_world.tmpl\", Map{\n\t\t\t\"Name\": c.Params(\"name\"),\n\t\t})\n\t})\n\n\tsub2.Get(\"/moment\", func(c Ctx) error {\n\t\treturn c.Render(\"bruh.tmpl\", Map{})\n\t})\n\n\tsub.Use(\"/bruh\", sub2)\n\tapp.Use(\"/hello\", sub)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/hello/world/a\", nil))\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.NoError(t, err, \"app.Test(req)\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello a!</h1>\", string(body))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.NoError(t, err, \"app.Test(req)\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello, World!</h1>\", string(body))\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/hello/bruh/moment\", nil))\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\trequire.NoError(t, err, \"app.Test(req)\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>I'm Bruh</h1>\", string(body))\n}\n\nfunc Test_Ctx_Render_MountGroup(t *testing.T) {\n\tt.Parallel()\n\n\tengine := &testTemplateEngine{}\n\terr := engine.Load()\n\trequire.NoError(t, err)\n\n\tmicro := New(Config{\n\t\tViews: engine,\n\t})\n\n\tmicro.Get(\"/doe\", func(c Ctx) error {\n\t\treturn c.Render(\"hello_world.tmpl\", Map{\n\t\t\t\"Name\": \"doe\",\n\t\t})\n\t})\n\n\tapp := New()\n\tv1 := app.Group(\"/v1\")\n\tv1.Use(\"/john\", micro)\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/v1/john/doe\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"<h1>Hello doe!</h1>\", string(body))\n}\n"
        },
        {
          "name": "path.go",
          "type": "blob",
          "size": 24.37,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📄 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n// ⚠️ This path parser was inspired by ucarion/urlpath (MIT License).\n// 💖 Maintained and modified for Fiber by @renewerner87\n\npackage fiber\n\nimport (\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/google/uuid\"\n)\n\n// routeParser holds the path segments and param names\ntype routeParser struct {\n\tsegs          []*routeSegment // the parsed segments of the route\n\tparams        []string        // that parameter names the parsed route\n\twildCardCount int             // number of wildcard parameters, used internally to give the wildcard parameter its number\n\tplusCount     int             // number of plus parameters, used internally to give the plus parameter its number\n}\n\n// routeSegment holds the segment metadata\ntype routeSegment struct {\n\t// const information\n\tConst       string        // constant part of the route\n\tParamName   string        // name of the parameter for access to it, for wildcards and plus parameters access iterators starting with 1 are added\n\tComparePart string        // search part to find the end of the parameter\n\tConstraints []*Constraint // Constraint type if segment is a parameter, if not it will be set to noConstraint by default\n\tPartCount   int           // how often is the search part contained in the non-param segments? -> necessary for greedy search\n\tLength      int           // length of the parameter for segment, when its 0 then the length is undetermined\n\t// future TODO: add support for optional groups \"/abc(/def)?\"\n\t// parameter information\n\tIsParam    bool // Truth value that indicates whether it is a parameter or a constant part\n\tIsGreedy   bool // indicates whether the parameter is greedy or not, is used with wildcard and plus\n\tIsOptional bool // indicates whether the parameter is optional or not\n\t// common information\n\tIsLast           bool // shows if the segment is the last one for the route\n\tHasOptionalSlash bool // segment has the possibility of an optional slash\n}\n\n// different special routing signs\nconst (\n\twildcardParam                byte = '*'  // indicates an optional greedy parameter\n\tplusParam                    byte = '+'  // indicates a required greedy parameter\n\toptionalParam                byte = '?'  // concludes a parameter by name and makes it optional\n\tparamStarterChar             byte = ':'  // start character for a parameter with name\n\tslashDelimiter               byte = '/'  // separator for the route, unlike the other delimiters this character at the end can be optional\n\tslashDelimiterStr            byte = '/'  // separator for the route, unlike the other delimiters this character at the end can be optional\n\tescapeChar                   byte = '\\\\' // escape character\n\tparamConstraintStart         byte = '<'  // start of type constraint for a parameter\n\tparamConstraintEnd           byte = '>'  // end of type constraint for a parameter\n\tparamConstraintSeparator     byte = ';'  // separator of type constraints for a parameter\n\tparamConstraintDataStart     byte = '('  // start of data of type constraint for a parameter\n\tparamConstraintDataEnd       byte = ')'  // end of data of type constraint for a parameter\n\tparamConstraintDataSeparator byte = ','  // separator of data of type constraint for a parameter\n)\n\n// TypeConstraint parameter constraint types\ntype TypeConstraint int16\n\ntype Constraint struct {\n\tRegexCompiler     *regexp.Regexp\n\tName              string\n\tData              []string\n\tcustomConstraints []CustomConstraint\n\tID                TypeConstraint\n}\n\n// CustomConstraint is an interface for custom constraints\ntype CustomConstraint interface {\n\t// Name returns the name of the constraint.\n\t// This name is used in the constraint matching.\n\tName() string\n\n\t// Execute executes the constraint.\n\t// It returns true if the constraint is matched and right.\n\t// param is the parameter value to check.\n\t// args are the constraint arguments.\n\tExecute(param string, args ...string) bool\n}\n\nconst (\n\tnoConstraint TypeConstraint = iota + 1\n\tintConstraint\n\tboolConstraint\n\tfloatConstraint\n\talphaConstraint\n\tdatetimeConstraint\n\tguidConstraint\n\tminLenConstraint\n\tmaxLenConstraint\n\tlenConstraint\n\tbetweenLenConstraint\n\tminConstraint\n\tmaxConstraint\n\trangeConstraint\n\tregexConstraint\n)\n\n// list of possible parameter and segment delimiter\nvar (\n\t// slash has a special role, unlike the other parameters it must not be interpreted as a parameter\n\trouteDelimiter = []byte{slashDelimiter, '-', '.'}\n\t// list of greedy parameters\n\tgreedyParameters = []byte{wildcardParam, plusParam}\n\t// list of chars for the parameter recognizing\n\tparameterStartChars = []byte{wildcardParam, plusParam, paramStarterChar}\n\t// list of chars of delimiters and the starting parameter name char\n\tparameterDelimiterChars = append([]byte{paramStarterChar, escapeChar}, routeDelimiter...)\n\t// list of chars to find the end of a parameter\n\tparameterEndChars = append([]byte{optionalParam}, parameterDelimiterChars...)\n\t// list of parameter constraint start\n\tparameterConstraintStartChars = []byte{paramConstraintStart}\n\t// list of parameter constraint end\n\tparameterConstraintEndChars = []byte{paramConstraintEnd}\n\t// list of parameter separator\n\tparameterConstraintSeparatorChars = []byte{paramConstraintSeparator}\n\t// list of parameter constraint data start\n\tparameterConstraintDataStartChars = []byte{paramConstraintDataStart}\n\t// list of parameter constraint data end\n\tparameterConstraintDataEndChars = []byte{paramConstraintDataEnd}\n\t// list of parameter constraint data separator\n\tparameterConstraintDataSeparatorChars = []byte{paramConstraintDataSeparator}\n)\n\n// RoutePatternMatch checks if a given path matches a Fiber route pattern.\nfunc RoutePatternMatch(path, pattern string, cfg ...Config) bool {\n\t// See logic in (*Route).match and (*App).register\n\tvar ctxParams [maxParams]string\n\n\tconfig := Config{}\n\tif len(cfg) > 0 {\n\t\tconfig = cfg[0]\n\t}\n\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\n\t// Cannot have an empty pattern\n\tif pattern == \"\" {\n\t\tpattern = \"/\"\n\t}\n\t// Pattern always start with a '/'\n\tif pattern[0] != '/' {\n\t\tpattern = \"/\" + pattern\n\t}\n\n\tpatternPretty := pattern\n\n\t// Case-sensitive routing, all to lowercase\n\tif !config.CaseSensitive {\n\t\tpatternPretty = utils.ToLower(patternPretty)\n\t\tpath = utils.ToLower(path)\n\t}\n\t// Strict routing, remove trailing slashes\n\tif !config.StrictRouting && len(patternPretty) > 1 {\n\t\tpatternPretty = utils.TrimRight(patternPretty, '/')\n\t}\n\n\tparser := parseRoute(patternPretty)\n\n\tif patternPretty == \"/\" && path == \"/\" {\n\t\treturn true\n\t\t// '*' wildcard matches any path\n\t} else if patternPretty == \"/*\" {\n\t\treturn true\n\t}\n\n\t// Does this route have parameters\n\tif len(parser.params) > 0 {\n\t\tif match := parser.getMatch(path, path, &ctxParams, false); match {\n\t\t\treturn true\n\t\t}\n\t}\n\t// Check for a simple match\n\tpatternPretty = RemoveEscapeChar(patternPretty)\n\tif len(patternPretty) == len(path) && patternPretty == path {\n\t\treturn true\n\t}\n\t// No match\n\treturn false\n}\n\n// parseRoute analyzes the route and divides it into segments for constant areas and parameters,\n// this information is needed later when assigning the requests to the declared routes\nfunc parseRoute(pattern string, customConstraints ...CustomConstraint) routeParser {\n\tparser := routeParser{}\n\tpart := \"\"\n\tfor len(pattern) > 0 {\n\t\tnextParamPosition := findNextParamPosition(pattern)\n\t\t// handle the parameter part\n\t\tif nextParamPosition == 0 {\n\t\t\tprocessedPart, seg := parser.analyseParameterPart(pattern, customConstraints...)\n\t\t\tparser.params, parser.segs, part = append(parser.params, seg.ParamName), append(parser.segs, seg), processedPart\n\t\t} else {\n\t\t\tprocessedPart, seg := parser.analyseConstantPart(pattern, nextParamPosition)\n\t\t\tparser.segs, part = append(parser.segs, seg), processedPart\n\t\t}\n\n\t\t// reduce the pattern by the processed parts\n\t\tif len(part) == len(pattern) {\n\t\t\tbreak\n\t\t}\n\t\tpattern = pattern[len(part):]\n\t}\n\t// mark last segment\n\tif len(parser.segs) > 0 {\n\t\tparser.segs[len(parser.segs)-1].IsLast = true\n\t}\n\tparser.segs = addParameterMetaInfo(parser.segs)\n\n\treturn parser\n}\n\n// addParameterMetaInfo add important meta information to the parameter segments\n// to simplify the search for the end of the parameter\nfunc addParameterMetaInfo(segs []*routeSegment) []*routeSegment {\n\tvar comparePart string\n\tsegLen := len(segs)\n\t// loop from end to begin\n\tfor i := segLen - 1; i >= 0; i-- {\n\t\t// set the compare part for the parameter\n\t\tif segs[i].IsParam {\n\t\t\t// important for finding the end of the parameter\n\t\t\tsegs[i].ComparePart = RemoveEscapeChar(comparePart)\n\t\t} else {\n\t\t\tcomparePart = segs[i].Const\n\t\t\tif len(comparePart) > 1 {\n\t\t\t\tcomparePart = utils.TrimRight(comparePart, slashDelimiterStr)\n\t\t\t}\n\t\t}\n\t}\n\n\t// loop from begin to end\n\tfor i := 0; i < segLen; i++ {\n\t\t// check how often the compare part is in the following const parts\n\t\tif segs[i].IsParam {\n\t\t\t// check if parameter segments are directly after each other and if one of them is greedy\n\t\t\t// in case the next parameter or the current parameter is not a wildcard it's not greedy, we only want one character\n\t\t\tif segLen > i+1 && !segs[i].IsGreedy && segs[i+1].IsParam && !segs[i+1].IsGreedy {\n\t\t\t\tsegs[i].Length = 1\n\t\t\t}\n\t\t\tif segs[i].ComparePart == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor j := i + 1; j <= len(segs)-1; j++ {\n\t\t\t\tif !segs[j].IsParam {\n\t\t\t\t\t// count is important for the greedy match\n\t\t\t\t\tsegs[i].PartCount += strings.Count(segs[j].Const, segs[i].ComparePart)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if the end of the segment is a optional slash and then if the segement is optional or the last one\n\t\t} else if segs[i].Const[len(segs[i].Const)-1] == slashDelimiter && (segs[i].IsLast || (segLen > i+1 && segs[i+1].IsOptional)) {\n\t\t\tsegs[i].HasOptionalSlash = true\n\t\t}\n\t}\n\n\treturn segs\n}\n\n// findNextParamPosition search for the next possible parameter start position\nfunc findNextParamPosition(pattern string) int {\n\tnextParamPosition := findNextNonEscapedCharsetPosition(pattern, parameterStartChars)\n\tif nextParamPosition != -1 && len(pattern) > nextParamPosition && pattern[nextParamPosition] != wildcardParam {\n\t\t// search for parameter characters for the found parameter start,\n\t\t// if there are more, move the parameter start to the last parameter char\n\t\tfor found := findNextNonEscapedCharsetPosition(pattern[nextParamPosition+1:], parameterStartChars); found == 0; {\n\t\t\tnextParamPosition++\n\t\t\tif len(pattern) > nextParamPosition {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nextParamPosition\n}\n\n// analyseConstantPart find the end of the constant part and create the route segment\nfunc (*routeParser) analyseConstantPart(pattern string, nextParamPosition int) (string, *routeSegment) {\n\t// handle the constant part\n\tprocessedPart := pattern\n\tif nextParamPosition != -1 {\n\t\t// remove the constant part until the parameter\n\t\tprocessedPart = pattern[:nextParamPosition]\n\t}\n\tconstPart := RemoveEscapeChar(processedPart)\n\treturn processedPart, &routeSegment{\n\t\tConst:  constPart,\n\t\tLength: len(constPart),\n\t}\n}\n\n// analyseParameterPart find the parameter end and create the route segment\nfunc (routeParser *routeParser) analyseParameterPart(pattern string, customConstraints ...CustomConstraint) (string, *routeSegment) {\n\tisWildCard := pattern[0] == wildcardParam\n\tisPlusParam := pattern[0] == plusParam\n\n\tvar parameterEndPosition int\n\tif strings.ContainsRune(pattern, rune(paramConstraintStart)) && strings.ContainsRune(pattern, rune(paramConstraintEnd)) {\n\t\tparameterEndPosition = findNextCharsetPositionConstraint(pattern[1:], parameterEndChars)\n\t} else {\n\t\tparameterEndPosition = findNextNonEscapedCharsetPosition(pattern[1:], parameterEndChars)\n\t}\n\n\tparameterConstraintStart := -1\n\tparameterConstraintEnd := -1\n\t// handle wildcard end\n\tswitch {\n\tcase isWildCard, isPlusParam:\n\t\tparameterEndPosition = 0\n\tcase parameterEndPosition == -1:\n\t\tparameterEndPosition = len(pattern) - 1\n\tcase !isInCharset(pattern[parameterEndPosition+1], parameterDelimiterChars):\n\t\tparameterEndPosition++\n\t}\n\n\t// find constraint part if exists in the parameter part and remove it\n\tif parameterEndPosition > 0 {\n\t\tparameterConstraintStart = findNextNonEscapedCharsetPosition(pattern[0:parameterEndPosition], parameterConstraintStartChars)\n\t\tparameterConstraintEnd = findLastCharsetPosition(pattern[0:parameterEndPosition+1], parameterConstraintEndChars)\n\t}\n\n\t// cut params part\n\tprocessedPart := pattern[0 : parameterEndPosition+1]\n\tparamName := RemoveEscapeChar(GetTrimmedParam(processedPart))\n\n\t// Check has constraint\n\tvar constraints []*Constraint\n\n\tif hasConstraint := parameterConstraintStart != -1 && parameterConstraintEnd != -1; hasConstraint {\n\t\tconstraintString := pattern[parameterConstraintStart+1 : parameterConstraintEnd]\n\t\tuserConstraints := splitNonEscaped(constraintString, string(parameterConstraintSeparatorChars))\n\t\tconstraints = make([]*Constraint, 0, len(userConstraints))\n\n\t\tfor _, c := range userConstraints {\n\t\t\tstart := findNextNonEscapedCharsetPosition(c, parameterConstraintDataStartChars)\n\t\t\tend := findLastCharsetPosition(c, parameterConstraintDataEndChars)\n\n\t\t\t// Assign constraint\n\t\t\tif start != -1 && end != -1 {\n\t\t\t\tconstraint := &Constraint{\n\t\t\t\t\tID:                getParamConstraintType(c[:start]),\n\t\t\t\t\tName:              c[:start],\n\t\t\t\t\tcustomConstraints: customConstraints,\n\t\t\t\t}\n\n\t\t\t\t// remove escapes from data\n\t\t\t\tif constraint.ID != regexConstraint {\n\t\t\t\t\tconstraint.Data = splitNonEscaped(c[start+1:end], string(parameterConstraintDataSeparatorChars))\n\t\t\t\t\tif len(constraint.Data) == 1 {\n\t\t\t\t\t\tconstraint.Data[0] = RemoveEscapeChar(constraint.Data[0])\n\t\t\t\t\t} else if len(constraint.Data) == 2 { // This is fine, we simply expect two parts\n\t\t\t\t\t\tconstraint.Data[0] = RemoveEscapeChar(constraint.Data[0])\n\t\t\t\t\t\tconstraint.Data[1] = RemoveEscapeChar(constraint.Data[1])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Precompile regex if has regex constraint\n\t\t\t\tif constraint.ID == regexConstraint {\n\t\t\t\t\tconstraint.Data = []string{c[start+1 : end]}\n\t\t\t\t\tconstraint.RegexCompiler = regexp.MustCompile(constraint.Data[0])\n\t\t\t\t}\n\n\t\t\t\tconstraints = append(constraints, constraint)\n\t\t\t} else {\n\t\t\t\tconstraints = append(constraints, &Constraint{\n\t\t\t\t\tID:                getParamConstraintType(c),\n\t\t\t\t\tData:              []string{},\n\t\t\t\t\tName:              c,\n\t\t\t\t\tcustomConstraints: customConstraints,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tparamName = RemoveEscapeChar(GetTrimmedParam(pattern[0:parameterConstraintStart]))\n\t}\n\n\t// add access iterator to wildcard and plus\n\tif isWildCard {\n\t\trouteParser.wildCardCount++\n\t\tparamName += strconv.Itoa(routeParser.wildCardCount)\n\t} else if isPlusParam {\n\t\trouteParser.plusCount++\n\t\tparamName += strconv.Itoa(routeParser.plusCount)\n\t}\n\n\tsegment := &routeSegment{\n\t\tParamName:  paramName,\n\t\tIsParam:    true,\n\t\tIsOptional: isWildCard || pattern[parameterEndPosition] == optionalParam,\n\t\tIsGreedy:   isWildCard || isPlusParam,\n\t}\n\n\tif len(constraints) > 0 {\n\t\tsegment.Constraints = constraints\n\t}\n\n\treturn processedPart, segment\n}\n\n// isInCharset check is the given character in the charset list\nfunc isInCharset(searchChar byte, charset []byte) bool {\n\tfor _, char := range charset {\n\t\tif char == searchChar {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// findNextCharsetPosition search the next char position from the charset\nfunc findNextCharsetPosition(search string, charset []byte) int {\n\tnextPosition := -1\n\tfor _, char := range charset {\n\t\tif pos := strings.IndexByte(search, char); pos != -1 && (pos < nextPosition || nextPosition == -1) {\n\t\t\tnextPosition = pos\n\t\t}\n\t}\n\n\treturn nextPosition\n}\n\n// findLastCharsetPosition search the last char position from the charset\nfunc findLastCharsetPosition(search string, charset []byte) int {\n\tlastPosition := -1\n\tfor _, char := range charset {\n\t\tif pos := strings.LastIndexByte(search, char); pos != -1 && (pos < lastPosition || lastPosition == -1) {\n\t\t\tlastPosition = pos\n\t\t}\n\t}\n\n\treturn lastPosition\n}\n\n// findNextCharsetPositionConstraint search the next char position from the charset\n// unlike findNextCharsetPosition, it takes care of constraint start-end chars to parse route pattern\nfunc findNextCharsetPositionConstraint(search string, charset []byte) int {\n\tconstraintStart := findNextNonEscapedCharsetPosition(search, parameterConstraintStartChars)\n\tconstraintEnd := findNextNonEscapedCharsetPosition(search, parameterConstraintEndChars)\n\tnextPosition := -1\n\n\tfor _, char := range charset {\n\t\tpos := strings.IndexByte(search, char)\n\n\t\tif pos != -1 && (pos < nextPosition || nextPosition == -1) {\n\t\t\tif (pos > constraintStart && pos > constraintEnd) || (pos < constraintStart && pos < constraintEnd) {\n\t\t\t\tnextPosition = pos\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nextPosition\n}\n\n// findNextNonEscapedCharsetPosition search the next char position from the charset and skip the escaped characters\nfunc findNextNonEscapedCharsetPosition(search string, charset []byte) int {\n\tpos := findNextCharsetPosition(search, charset)\n\tfor pos > 0 && search[pos-1] == escapeChar {\n\t\tif len(search) == pos+1 {\n\t\t\t// escaped character is at the end\n\t\t\treturn -1\n\t\t}\n\t\tnextPossiblePos := findNextCharsetPosition(search[pos+1:], charset)\n\t\tif nextPossiblePos == -1 {\n\t\t\treturn -1\n\t\t}\n\t\t// the previous character is taken into consideration\n\t\tpos = nextPossiblePos + pos + 1\n\t}\n\n\treturn pos\n}\n\n// splitNonEscaped slices s into all substrings separated by sep and returns a slice of the substrings between those separators\n// This function also takes a care of escape char when splitting.\nfunc splitNonEscaped(s, sep string) []string {\n\tvar result []string\n\ti := findNextNonEscapedCharsetPosition(s, []byte(sep))\n\n\tfor i > -1 {\n\t\tresult = append(result, s[:i])\n\t\ts = s[i+len(sep):]\n\t\ti = findNextNonEscapedCharsetPosition(s, []byte(sep))\n\t}\n\n\treturn append(result, s)\n}\n\n// getMatch parses the passed url and tries to match it against the route segments and determine the parameter positions\nfunc (routeParser *routeParser) getMatch(detectionPath, path string, params *[maxParams]string, partialCheck bool) bool { //nolint: revive // Accepting a bool param is fine here\n\tvar i, paramsIterator, partLen int\n\tfor _, segment := range routeParser.segs {\n\t\tpartLen = len(detectionPath)\n\t\t// check const segment\n\t\tif !segment.IsParam {\n\t\t\ti = segment.Length\n\t\t\t// is optional part or the const part must match with the given string\n\t\t\t// check if the end of the segment is an optional slash\n\t\t\tif segment.HasOptionalSlash && partLen == i-1 && detectionPath == segment.Const[:i-1] {\n\t\t\t\ti--\n\t\t\t} else if !(i <= partLen && detectionPath[:i] == segment.Const) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\t// determine parameter length\n\t\t\ti = findParamLen(detectionPath, segment)\n\t\t\tif !segment.IsOptional && i == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\t// take over the params positions\n\t\t\tparams[paramsIterator] = path[:i]\n\n\t\t\tif !(segment.IsOptional && i == 0) {\n\t\t\t\t// check constraint\n\t\t\t\tfor _, c := range segment.Constraints {\n\t\t\t\t\tif matched := c.CheckConstraint(params[paramsIterator]); !matched {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparamsIterator++\n\t\t}\n\n\t\t// reduce founded part from the string\n\t\tif partLen > 0 {\n\t\t\tdetectionPath, path = detectionPath[i:], path[i:]\n\t\t}\n\t}\n\tif detectionPath != \"\" && !partialCheck {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// findParamLen for the expressjs wildcard behavior (right to left greedy)\n// look at the other segments and take what is left for the wildcard from right to left\nfunc findParamLen(s string, segment *routeSegment) int {\n\tif segment.IsLast {\n\t\treturn findParamLenForLastSegment(s, segment)\n\t}\n\n\tif segment.Length != 0 && len(s) >= segment.Length {\n\t\treturn segment.Length\n\t} else if segment.IsGreedy {\n\t\t// Search the parameters until the next constant part\n\t\t// special logic for greedy params\n\t\tsearchCount := strings.Count(s, segment.ComparePart)\n\t\tif searchCount > 1 {\n\t\t\treturn findGreedyParamLen(s, searchCount, segment)\n\t\t}\n\t}\n\n\tif len(segment.ComparePart) == 1 {\n\t\tif constPosition := strings.IndexByte(s, segment.ComparePart[0]); constPosition != -1 {\n\t\t\treturn constPosition\n\t\t}\n\t} else if constPosition := strings.Index(s, segment.ComparePart); constPosition != -1 {\n\t\t// if the compare part was found, but contains a slash although this part is not greedy, then it must not match\n\t\t// example: /api/:param/fixedEnd -> path: /api/123/456/fixedEnd = no match , /api/123/fixedEnd = match\n\t\tif !segment.IsGreedy && strings.IndexByte(s[:constPosition], slashDelimiter) != -1 {\n\t\t\treturn 0\n\t\t}\n\t\treturn constPosition\n\t}\n\n\treturn len(s)\n}\n\n// findParamLenForLastSegment get the length of the parameter if it is the last segment\nfunc findParamLenForLastSegment(s string, seg *routeSegment) int {\n\tif !seg.IsGreedy {\n\t\tif i := strings.IndexByte(s, slashDelimiter); i != -1 {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn len(s)\n}\n\n// findGreedyParamLen get the length of the parameter for greedy segments from right to left\nfunc findGreedyParamLen(s string, searchCount int, segment *routeSegment) int {\n\t// check all from right to left segments\n\tfor i := segment.PartCount; i > 0 && searchCount > 0; i-- {\n\t\tsearchCount--\n\n\t\tconstPosition := strings.LastIndex(s, segment.ComparePart)\n\t\tif constPosition == -1 {\n\t\t\tbreak\n\t\t}\n\t\ts = s[:constPosition]\n\t}\n\n\treturn len(s)\n}\n\n// GetTrimmedParam trims the ':' & '?' from a string\nfunc GetTrimmedParam(param string) string {\n\tstart := 0\n\tend := len(param)\n\n\tif end == 0 || param[start] != paramStarterChar { // is not a param\n\t\treturn param\n\t}\n\tstart++\n\tif param[end-1] == optionalParam { // is ?\n\t\tend--\n\t}\n\n\treturn param[start:end]\n}\n\n// RemoveEscapeChar remove escape characters\nfunc RemoveEscapeChar(word string) string {\n\tb := []byte(word)\n\tdst := 0\n\tfor src := 0; src < len(b); src++ {\n\t\tif b[src] == '\\\\' {\n\t\t\tcontinue\n\t\t}\n\t\tb[dst] = b[src]\n\t\tdst++\n\t}\n\treturn string(b[:dst])\n}\n\nfunc getParamConstraintType(constraintPart string) TypeConstraint {\n\tswitch constraintPart {\n\tcase ConstraintInt:\n\t\treturn intConstraint\n\tcase ConstraintBool:\n\t\treturn boolConstraint\n\tcase ConstraintFloat:\n\t\treturn floatConstraint\n\tcase ConstraintAlpha:\n\t\treturn alphaConstraint\n\tcase ConstraintGUID:\n\t\treturn guidConstraint\n\tcase ConstraintMinLen, ConstraintMinLenLower:\n\t\treturn minLenConstraint\n\tcase ConstraintMaxLen, ConstraintMaxLenLower:\n\t\treturn maxLenConstraint\n\tcase ConstraintLen:\n\t\treturn lenConstraint\n\tcase ConstraintBetweenLen, ConstraintBetweenLenLower:\n\t\treturn betweenLenConstraint\n\tcase ConstraintMin:\n\t\treturn minConstraint\n\tcase ConstraintMax:\n\t\treturn maxConstraint\n\tcase ConstraintRange:\n\t\treturn rangeConstraint\n\tcase ConstraintDatetime:\n\t\treturn datetimeConstraint\n\tcase ConstraintRegex:\n\t\treturn regexConstraint\n\tdefault:\n\t\treturn noConstraint\n\t}\n}\n\n//nolint:errcheck // TODO: Properly check _all_ errors in here, log them & immediately return\nfunc (c *Constraint) CheckConstraint(param string) bool {\n\tvar err error\n\tvar num int\n\n\t// check data exists\n\tneedOneData := []TypeConstraint{minLenConstraint, maxLenConstraint, lenConstraint, minConstraint, maxConstraint, datetimeConstraint, regexConstraint}\n\tneedTwoData := []TypeConstraint{betweenLenConstraint, rangeConstraint}\n\n\tfor _, data := range needOneData {\n\t\tif c.ID == data && len(c.Data) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor _, data := range needTwoData {\n\t\tif c.ID == data && len(c.Data) < 2 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// check constraints\n\tswitch c.ID {\n\tcase noConstraint:\n\t\tfor _, cc := range c.customConstraints {\n\t\t\tif cc.Name() == c.Name {\n\t\t\t\treturn cc.Execute(param, c.Data...)\n\t\t\t}\n\t\t}\n\tcase intConstraint:\n\t\t_, err = strconv.Atoi(param)\n\tcase boolConstraint:\n\t\t_, err = strconv.ParseBool(param)\n\tcase floatConstraint:\n\t\t_, err = strconv.ParseFloat(param, 32)\n\tcase alphaConstraint:\n\t\tfor _, r := range param {\n\t\t\tif !unicode.IsLetter(r) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase guidConstraint:\n\t\t_, err = uuid.Parse(param)\n\tcase minLenConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\n\t\tif len(param) < data {\n\t\t\treturn false\n\t\t}\n\tcase maxLenConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\n\t\tif len(param) > data {\n\t\t\treturn false\n\t\t}\n\tcase lenConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\n\t\tif len(param) != data {\n\t\t\treturn false\n\t\t}\n\tcase betweenLenConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\t\tdata2, _ := strconv.Atoi(c.Data[1])\n\t\tlength := len(param)\n\t\tif length < data || length > data2 {\n\t\t\treturn false\n\t\t}\n\tcase minConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\t\tnum, err = strconv.Atoi(param)\n\n\t\tif num < data {\n\t\t\treturn false\n\t\t}\n\tcase maxConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\t\tnum, err = strconv.Atoi(param)\n\n\t\tif num > data {\n\t\t\treturn false\n\t\t}\n\tcase rangeConstraint:\n\t\tdata, _ := strconv.Atoi(c.Data[0])\n\t\tdata2, _ := strconv.Atoi(c.Data[1])\n\t\tnum, err = strconv.Atoi(param)\n\n\t\tif num < data || num > data2 {\n\t\t\treturn false\n\t\t}\n\tcase datetimeConstraint:\n\t\t_, err = time.Parse(c.Data[0], param)\n\tcase regexConstraint:\n\t\tif match := c.RegexCompiler.MatchString(param); !match {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn err == nil\n}\n"
        },
        {
          "name": "path_test.go",
          "type": "blob",
          "size": 8.34,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📝 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\n// go test -race -run Test_Path_parseRoute\nfunc Test_Path_parseRoute(t *testing.T) {\n\tt.Parallel()\n\tvar rp routeParser\n\n\trp = parseRoute(\"/shop/product/::filter/color::color/size::size\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/shop/product/:\", Length: 15},\n\t\t\t{IsParam: true, ParamName: \"filter\", ComparePart: \"/color:\", PartCount: 1},\n\t\t\t{Const: \"/color:\", Length: 7},\n\t\t\t{IsParam: true, ParamName: \"color\", ComparePart: \"/size:\", PartCount: 1},\n\t\t\t{Const: \"/size:\", Length: 6},\n\t\t\t{IsParam: true, ParamName: \"size\", IsLast: true},\n\t\t},\n\t\tparams: []string{\"filter\", \"color\", \"size\"},\n\t}, rp)\n\n\trp = parseRoute(\"/api/v1/:param/abc/*\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/api/v1/\", Length: 8},\n\t\t\t{IsParam: true, ParamName: \"param\", ComparePart: \"/abc\", PartCount: 1},\n\t\t\t{Const: \"/abc/\", Length: 5, HasOptionalSlash: true},\n\t\t\t{IsParam: true, ParamName: \"*1\", IsGreedy: true, IsOptional: true, IsLast: true},\n\t\t},\n\t\tparams:        []string{\"param\", \"*1\"},\n\t\twildCardCount: 1,\n\t}, rp)\n\n\trp = parseRoute(\"/v1/some/resource/name\\\\:customVerb\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/v1/some/resource/name:customVerb\", Length: 33, IsLast: true},\n\t\t},\n\t\tparams: nil,\n\t}, rp)\n\n\trp = parseRoute(\"/v1/some/resource/:name\\\\:customVerb\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/v1/some/resource/\", Length: 18},\n\t\t\t{IsParam: true, ParamName: \"name\", ComparePart: \":customVerb\", PartCount: 1},\n\t\t\t{Const: \":customVerb\", Length: 11, IsLast: true},\n\t\t},\n\t\tparams: []string{\"name\"},\n\t}, rp)\n\n\t// heavy test with escaped charaters\n\trp = parseRoute(\"/v1/some/resource/name\\\\\\\\:customVerb?\\\\?/:param/*\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/v1/some/resource/name:customVerb??/\", Length: 36},\n\t\t\t{IsParam: true, ParamName: \"param\", ComparePart: \"/\", PartCount: 1},\n\t\t\t{Const: \"/\", Length: 1, HasOptionalSlash: true},\n\t\t\t{IsParam: true, ParamName: \"*1\", IsGreedy: true, IsOptional: true, IsLast: true},\n\t\t},\n\t\tparams:        []string{\"param\", \"*1\"},\n\t\twildCardCount: 1,\n\t}, rp)\n\n\trp = parseRoute(\"/api/*/:param/:param2\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/api/\", Length: 5, HasOptionalSlash: true},\n\t\t\t{IsParam: true, ParamName: \"*1\", IsGreedy: true, IsOptional: true, ComparePart: \"/\", PartCount: 2},\n\t\t\t{Const: \"/\", Length: 1},\n\t\t\t{IsParam: true, ParamName: \"param\", ComparePart: \"/\", PartCount: 1},\n\t\t\t{Const: \"/\", Length: 1},\n\t\t\t{IsParam: true, ParamName: \"param2\", IsLast: true},\n\t\t},\n\t\tparams:        []string{\"*1\", \"param\", \"param2\"},\n\t\twildCardCount: 1,\n\t}, rp)\n\n\trp = parseRoute(\"/test:optional?:optional2?\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/test\", Length: 5},\n\t\t\t{IsParam: true, ParamName: \"optional\", IsOptional: true, Length: 1},\n\t\t\t{IsParam: true, ParamName: \"optional2\", IsOptional: true, IsLast: true},\n\t\t},\n\t\tparams: []string{\"optional\", \"optional2\"},\n\t}, rp)\n\n\trp = parseRoute(\"/config/+.json\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/config/\", Length: 8},\n\t\t\t{IsParam: true, ParamName: \"+1\", IsGreedy: true, IsOptional: false, ComparePart: \".json\", PartCount: 1},\n\t\t\t{Const: \".json\", Length: 5, IsLast: true},\n\t\t},\n\t\tparams:    []string{\"+1\"},\n\t\tplusCount: 1,\n\t}, rp)\n\n\trp = parseRoute(\"/api/:day.:month?.:year?\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/api/\", Length: 5},\n\t\t\t{IsParam: true, ParamName: \"day\", IsOptional: false, ComparePart: \".\", PartCount: 2},\n\t\t\t{Const: \".\", Length: 1},\n\t\t\t{IsParam: true, ParamName: \"month\", IsOptional: true, ComparePart: \".\", PartCount: 1},\n\t\t\t{Const: \".\", Length: 1},\n\t\t\t{IsParam: true, ParamName: \"year\", IsOptional: true, IsLast: true},\n\t\t},\n\t\tparams: []string{\"day\", \"month\", \"year\"},\n\t}, rp)\n\n\trp = parseRoute(\"/*v1*/proxy\")\n\trequire.Equal(t, routeParser{\n\t\tsegs: []*routeSegment{\n\t\t\t{Const: \"/\", Length: 1, HasOptionalSlash: true},\n\t\t\t{IsParam: true, ParamName: \"*1\", IsGreedy: true, IsOptional: true, ComparePart: \"v1\", PartCount: 1},\n\t\t\t{Const: \"v1\", Length: 2},\n\t\t\t{IsParam: true, ParamName: \"*2\", IsGreedy: true, IsOptional: true, ComparePart: \"/proxy\", PartCount: 1},\n\t\t\t{Const: \"/proxy\", Length: 6, IsLast: true},\n\t\t},\n\t\tparams:        []string{\"*1\", \"*2\"},\n\t\twildCardCount: 2,\n\t}, rp)\n}\n\n// go test -race -run Test_Path_matchParams\nfunc Test_Path_matchParams(t *testing.T) {\n\tt.Parallel()\n\tvar ctxParams [maxParams]string\n\ttestCaseFn := func(testCollection routeCaseCollection) {\n\t\tparser := parseRoute(testCollection.pattern)\n\t\tfor _, c := range testCollection.testCases {\n\t\t\tmatch := parser.getMatch(c.url, c.url, &ctxParams, c.partialCheck)\n\t\t\trequire.Equal(t, c.match, match, \"route: '%s', url: '%s'\", testCollection.pattern, c.url)\n\t\t\tif match && len(c.params) > 0 {\n\t\t\t\trequire.Equal(t, c.params[0:len(c.params)], ctxParams[0:len(c.params)], \"route: '%s', url: '%s'\", testCollection.pattern, c.url)\n\t\t\t}\n\t\t}\n\t}\n\tfor _, testCaseCollection := range routeTestCases {\n\t\ttestCaseFn(testCaseCollection)\n\t}\n}\n\n// go test -race -run Test_RoutePatternMatch\nfunc Test_RoutePatternMatch(t *testing.T) {\n\tt.Parallel()\n\ttestCaseFn := func(pattern string, cases []routeTestCase) {\n\t\tfor _, c := range cases {\n\t\t\t// skip all cases for partial checks\n\t\t\tif c.partialCheck {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmatch := RoutePatternMatch(c.url, pattern)\n\t\t\trequire.Equal(t, c.match, match, \"route: '%s', url: '%s'\", pattern, c.url)\n\t\t}\n\t}\n\tfor _, testCase := range routeTestCases {\n\t\ttestCaseFn(testCase.pattern, testCase.testCases)\n\t}\n}\n\nfunc Test_Utils_GetTrimmedParam(t *testing.T) {\n\tt.Parallel()\n\tres := GetTrimmedParam(\"\")\n\trequire.Equal(t, \"\", res)\n\tres = GetTrimmedParam(\"*\")\n\trequire.Equal(t, \"*\", res)\n\tres = GetTrimmedParam(\":param\")\n\trequire.Equal(t, \"param\", res)\n\tres = GetTrimmedParam(\":param1?\")\n\trequire.Equal(t, \"param1\", res)\n\tres = GetTrimmedParam(\"noParam\")\n\trequire.Equal(t, \"noParam\", res)\n}\n\nfunc Test_Utils_RemoveEscapeChar(t *testing.T) {\n\tt.Parallel()\n\tres := RemoveEscapeChar(\":test\\\\:bla\")\n\trequire.Equal(t, \":test:bla\", res)\n\tres = RemoveEscapeChar(\"\\\\abc\")\n\trequire.Equal(t, \"abc\", res)\n\tres = RemoveEscapeChar(\"noEscapeChar\")\n\trequire.Equal(t, \"noEscapeChar\", res)\n}\n\nfunc Benchmark_Utils_RemoveEscapeChar(b *testing.B) {\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tvar res string\n\tfor n := 0; n < b.N; n++ {\n\t\tres = RemoveEscapeChar(\":test\\\\:bla\")\n\t}\n\n\trequire.Equal(b, \":test:bla\", res)\n}\n\n// go test -race -run Test_Path_matchParams\nfunc Benchmark_Path_matchParams(t *testing.B) {\n\tvar ctxParams [maxParams]string\n\tbenchCaseFn := func(testCollection routeCaseCollection) {\n\t\tparser := parseRoute(testCollection.pattern)\n\t\tfor _, c := range testCollection.testCases {\n\t\t\tvar matchRes bool\n\t\t\tstate := \"match\"\n\t\t\tif !c.match {\n\t\t\t\tstate = \"not match\"\n\t\t\t}\n\t\t\tt.Run(testCollection.pattern+\" | \"+state+\" | \"+c.url, func(b *testing.B) {\n\t\t\t\tfor i := 0; i <= b.N; i++ {\n\t\t\t\t\tif match := parser.getMatch(c.url, c.url, &ctxParams, c.partialCheck); match {\n\t\t\t\t\t\t// Get testCases from the original path\n\t\t\t\t\t\tmatchRes = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trequire.Equal(t, c.match, matchRes, \"route: '%s', url: '%s'\", testCollection.pattern, c.url)\n\t\t\t\tif matchRes && len(c.params) > 0 {\n\t\t\t\t\trequire.Equal(t, c.params[0:len(c.params)-1], ctxParams[0:len(c.params)-1], \"route: '%s', url: '%s'\", testCollection.pattern, c.url)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfor _, testCollection := range benchmarkCases {\n\t\tbenchCaseFn(testCollection)\n\t}\n}\n\n// go test -race -run Test_RoutePatternMatch\nfunc Benchmark_RoutePatternMatch(t *testing.B) {\n\tbenchCaseFn := func(testCollection routeCaseCollection) {\n\t\tfor _, c := range testCollection.testCases {\n\t\t\t// skip all cases for partial checks\n\t\t\tif c.partialCheck {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar matchRes bool\n\t\t\tstate := \"match\"\n\t\t\tif !c.match {\n\t\t\t\tstate = \"not match\"\n\t\t\t}\n\t\t\tt.Run(testCollection.pattern+\" | \"+state+\" | \"+c.url, func(b *testing.B) {\n\t\t\t\tfor i := 0; i <= b.N; i++ {\n\t\t\t\t\tif match := RoutePatternMatch(c.url, testCollection.pattern); match {\n\t\t\t\t\t\t// Get testCases from the original path\n\t\t\t\t\t\tmatchRes = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trequire.Equal(t, c.match, matchRes, \"route: '%s', url: '%s'\", testCollection.pattern, c.url)\n\t\t\t})\n\t\t}\n\t}\n\n\tfor _, testCollection := range benchmarkCases {\n\t\tbenchCaseFn(testCollection)\n\t}\n}\n"
        },
        {
          "name": "path_testcases_test.go",
          "type": "blob",
          "size": 26.65,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📝 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"strings\"\n)\n\ntype routeTestCase struct {\n\turl          string\n\tparams       []string\n\tmatch        bool\n\tpartialCheck bool\n}\n\ntype routeCaseCollection struct {\n\tpattern   string\n\ttestCases []routeTestCase\n}\n\nvar (\n\tbenchmarkCases []routeCaseCollection\n\trouteTestCases []routeCaseCollection\n)\n\nfunc init() {\n\t// smaller list for benchmark cases\n\tbenchmarkCases = []routeCaseCollection{\n\t\t{\n\t\t\tpattern: \"/api/v1/const\",\n\t\t\ttestCases: []routeTestCase{\n\t\t\t\t{url: \"/api/v1/const\", params: []string{}, match: true},\n\t\t\t\t{url: \"/api/v1\", params: nil, match: false},\n\t\t\t\t{url: \"/api/v1/\", params: nil, match: false},\n\t\t\t\t{url: \"/api/v1/something\", params: nil, match: false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tpattern: \"/api/:param/fixedEnd\",\n\t\t\ttestCases: []routeTestCase{\n\t\t\t\t{url: \"/api/abc/fixedEnd\", params: []string{\"abc\"}, match: true},\n\t\t\t\t{url: \"/api/abc/def/fixedEnd\", params: nil, match: false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tpattern: \"/api/v1/:param/*\",\n\t\t\ttestCases: []routeTestCase{\n\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"entity\", \"\"}, match: true},\n\t\t\t\t{url: \"/api/v1/entity/\", params: []string{\"entity\", \"\"}, match: true},\n\t\t\t\t{url: \"/api/v1/entity/1\", params: []string{\"entity\", \"1\"}, match: true},\n\t\t\t\t{url: \"/api/v\", params: nil, match: false},\n\t\t\t\t{url: \"/api/v2\", params: nil, match: false},\n\t\t\t\t{url: \"/api/v1/\", params: nil, match: false},\n\t\t\t},\n\t\t},\n\t}\n\n\t// combine benchmark cases and other cases\n\trouteTestCases = benchmarkCases\n\trouteTestCases = append(\n\t\trouteTestCases,\n\t\t[]routeCaseCollection{\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param/+\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/entity/\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/entity/1\", params: []string{\"entity\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/v\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v2\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/optional\", params: []string{\"optional\"}, match: true},\n\t\t\t\t\t{url: \"/api/v\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v2\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/xyz\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/v1/some/resource/name\\:customVerb`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/v1/some/resource/name:customVerb\", params: nil, match: true},\n\t\t\t\t\t{url: \"/v1/some/resource/name:test\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/v1/some/resource/:name\\:customVerb`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/v1/some/resource/test:customVerb\", params: []string{\"test\"}, match: true},\n\t\t\t\t\t{url: \"/v1/some/resource/test:test\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/v1/some/resource/name\\\\:customVerb?\\?/:param/*`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/v1/some/resource/name:customVerb??/test/optionalWildCard/character\", params: []string{\"test\", \"optionalWildCard/character\"}, match: true},\n\t\t\t\t\t{url: \"/v1/some/resource/name:customVerb??/test\", params: []string{\"test\", \"\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/*\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"entity\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/entity/1/2\", params: []string{\"entity/1/2\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/Entity/1/2\", params: []string{\"Entity/1/2\"}, match: true},\n\t\t\t\t\t{url: \"/api/v\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v2\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/abc\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"entity\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/entity/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param-:param2\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity-entity2\", params: []string{\"entity\", \"entity2\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/entity/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/entity-8728382\", params: []string{\"entity\", \"8728382\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:filename.:extension\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/test.pdf\", params: []string{\"test\", \"pdf\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/test/pdf\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/test-pdf\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/test_pdf\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/shop/product/::filter/color::color/size::size\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/shop/product/:test/color:blue/size:xs\", params: []string{\"test\", \"blue\", \"xs\"}, match: true},\n\t\t\t\t\t{url: \"/shop/product/test/color:blue/size:xs\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/::param?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/:hello\", params: []string{\"hello\"}, match: true},\n\t\t\t\t\t{url: \"/:\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// successive parameters, each take one character and the last parameter gets everything\n\t\t\t{\n\t\t\t\tpattern: \"/test:sign:param\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/test-abc\", params: []string{\"-\", \"abc\"}, match: true},\n\t\t\t\t\t{url: \"/test\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// optional parameters are not greedy\n\t\t\t{\n\t\t\t\tpattern: \"/:param1:param2?:param3\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/abbbc\", params: []string{\"a\", \"b\", \"bbc\"}, match: true},\n\t\t\t\t\t// {url: \"/ac\", testCases: []string{\"a\", \"\", \"c\"}, match: true}, // TODO: fix it\n\t\t\t\t\t{url: \"/test\", params: []string{\"t\", \"e\", \"st\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/test:optional?:mandatory\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t// {url: \"/testo\", testCases: []string{\"\", \"o\"}, match: true}, // TODO: fix it\n\t\t\t\t\t{url: \"/testoaaa\", params: []string{\"o\", \"aaa\"}, match: true},\n\t\t\t\t\t{url: \"/test\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/test:optional?:optional2?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/testo\", params: []string{\"o\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/testoaaa\", params: []string{\"o\", \"aaa\"}, match: true},\n\t\t\t\t\t{url: \"/test\", params: []string{\"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/tes\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/foo:param?bar\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/foofaselbar\", params: []string{\"fasel\"}, match: true},\n\t\t\t\t\t{url: \"/foobar\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/fooba\", params: nil, match: false},\n\t\t\t\t\t{url: \"/fobar\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/foo*bar\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/foofaselbar\", params: []string{\"fasel\"}, match: true},\n\t\t\t\t\t{url: \"/foobar\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/foo+bar\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/foofaselbar\", params: []string{\"fasel\"}, match: true},\n\t\t\t\t\t{url: \"/foobar\", params: nil, match: false},\n\t\t\t\t\t{url: \"/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/a*cde*g/\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/abbbcdefffg\", params: []string{\"bbb\", \"fff\"}, match: true},\n\t\t\t\t\t{url: \"/acdeg\", params: []string{\"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/*v1*/proxy\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/customer/v1/cart/proxy\", params: []string{\"customer/\", \"/cart\"}, match: true},\n\t\t\t\t\t{url: \"/v1/proxy\", params: []string{\"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/v1/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// successive wildcard -> first wildcard is greedy\n\t\t\t{\n\t\t\t\tpattern: \"/foo***bar\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/foo*abar\", params: []string{\"*a\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/foo*bar\", params: []string{\"*\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/foobar\", params: []string{\"\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/fooba\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t// chars in front of an parameter\n\t\t\t{\n\t\t\t\tpattern: \"/name::name\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/name:john\", params: []string{\"john\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/@:name\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/@john\", params: []string{\"john\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/-:name\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/-john\", params: []string{\"john\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/.:name\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/.john\", params: []string{\"john\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param/abc/*\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/well/abc/wildcard\", params: []string{\"well\", \"wildcard\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/well/abc/\", params: []string{\"well\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/well/abc\", params: []string{\"well\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/well/ttt\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/:day/:month?/:year?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/1\", params: []string{\"1\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1/\", params: []string{\"1\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1//\", params: []string{\"1\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1/-/\", params: []string{\"1\", \"-\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1-\", params: []string{\"1-\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1.\", params: []string{\"1.\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1/2\", params: []string{\"1\", \"2\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1/2/3\", params: []string{\"1\", \"2\", \"3\"}, match: true},\n\t\t\t\t\t{url: \"/api/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/:day.:month?.:year?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1/\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1.\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1..\", params: []string{\"1\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1.2\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1.2.\", params: []string{\"1\", \"2\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1.2.3\", params: []string{\"1\", \"2\", \"3\"}, match: true},\n\t\t\t\t\t{url: \"/api/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/:day-:month?-:year?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1/\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1-\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1--\", params: []string{\"1\", \"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1-/\", params: nil, match: false},\n\t\t\t\t\t// {url: \"/api/1-/-\", testCases: nil, match: false}, // TODO: fix this part\n\t\t\t\t\t{url: \"/api/1-2\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/1-2-\", params: []string{\"1\", \"2\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/1-2-3\", params: []string{\"1\", \"2\", \"3\"}, match: true},\n\t\t\t\t\t{url: \"/api/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/*\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker\", params: []string{\"joker\"}, match: true},\n\t\t\t\t\t{url: \"/api\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"v1/entity\"}, match: true},\n\t\t\t\t\t{url: \"/api2/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api_ignore/v1/entity\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/partialCheck/foo/bar/:param\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/partialCheck/foo/bar/test\", params: []string{\"test\"}, match: true, partialCheck: true},\n\t\t\t\t\t{url: \"/partialCheck/foo/bar/test/test2\", params: []string{\"test\"}, match: true, partialCheck: true},\n\t\t\t\t\t{url: \"/partialCheck/foo/bar\", params: nil, match: false, partialCheck: true},\n\t\t\t\t\t{url: \"/partiaFoo\", params: nil, match: false, partialCheck: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api\", params: nil, match: false},\n\t\t\t\t\t{url: \"\", params: []string{}, match: true},\n\t\t\t\t\t{url: \"/\", params: []string{}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/config/abc.json\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/config/abc.json\", params: []string{}, match: true},\n\t\t\t\t\t{url: \"config/abc.json\", params: nil, match: false},\n\t\t\t\t\t{url: \"/config/efg.json\", params: nil, match: false},\n\t\t\t\t\t{url: \"/config\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/config/*.json\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/config/abc.json\", params: []string{\"abc\"}, match: true},\n\t\t\t\t\t{url: \"/config/efg.json\", params: []string{\"efg\"}, match: true},\n\t\t\t\t\t{url: \"/config/.json\", params: []string{\"\"}, match: true},\n\t\t\t\t\t{url: \"/config/efg.csv\", params: nil, match: false},\n\t\t\t\t\t{url: \"config/abc.json\", params: nil, match: false},\n\t\t\t\t\t{url: \"/config\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/config/+.json\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/config/abc.json\", params: []string{\"abc\"}, match: true},\n\t\t\t\t\t{url: \"/config/.json\", params: nil, match: false},\n\t\t\t\t\t{url: \"/config/efg.json\", params: []string{\"efg\"}, match: true},\n\t\t\t\t\t{url: \"/config/efg.csv\", params: nil, match: false},\n\t\t\t\t\t{url: \"config/abc.json\", params: nil, match: false},\n\t\t\t\t\t{url: \"/config\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/xyz\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"xyz\", params: nil, match: false},\n\t\t\t\t\t{url: \"xyz/\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/*/:param?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/\", params: []string{\"\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker\", params: []string{\"joker\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman\", params: []string{\"joker\", \"batman\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker//batman\", params: []string{\"joker/\", \"batman\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin\", params: []string{\"joker/batman\", \"robin\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin/1\", params: []string{\"joker/batman/robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin/1/\", params: []string{\"joker/batman/robin/1\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker-batman/robin/1\", params: []string{\"joker-batman/robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker-batman-robin/1\", params: []string{\"joker-batman-robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker-batman-robin-1\", params: []string{\"joker-batman-robin-1\", \"\"}, match: true},\n\t\t\t\t\t{url: \"/api\", params: []string{\"\", \"\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/*/:param\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/test/abc\", params: []string{\"test\", \"abc\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman\", params: []string{\"joker\", \"batman\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin\", params: []string{\"joker/batman\", \"robin\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin/1\", params: []string{\"joker/batman/robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman-robin/1\", params: []string{\"joker/batman-robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker-batman-robin-1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/+/:param\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/test/abc\", params: []string{\"test\", \"abc\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin/1\", params: []string{\"joker/batman/robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/*/:param/:param2\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/test/abc/1\", params: []string{\"test\", \"abc\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/joker/batman-robin/1\", params: []string{\"joker\", \"batman-robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker-batman-robin-1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/test/abc\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/joker/batman/robin\", params: []string{\"joker\", \"batman\", \"robin\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin/1\", params: []string{\"joker/batman\", \"robin\", \"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/joker/batman/robin/1/2\", params: []string{\"joker/batman/robin\", \"1\", \"2\"}, match: true},\n\t\t\t\t\t{url: \"/api\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/:test\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<int>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: []string{\"8728382\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<bool>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/true\", params: []string{\"true\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<float>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: []string{\"8728382\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/8728382.5\", params: []string{\"8728382.5\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<alpha>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"entity\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/#!?\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<guid>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/f0fa66cc-d22e-445b-866d-1d76e776371d\", params: []string{\"f0fa66cc-d22e-445b-866d-1d76e776371d\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<minLen>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<minLen(5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"entity\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: []string{\"8728382\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/123\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/12345\", params: []string{\"12345\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<maxLen(5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/ent\", params: []string{\"ent\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/123\", params: []string{\"123\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/12345\", params: []string{\"12345\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<len(5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/123\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/12345\", params: []string{\"12345\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<betweenLen(1)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<betweenLen(2,5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/e\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/en\", params: []string{\"en\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/123\", params: []string{\"123\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/12345\", params: []string{\"12345\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<betweenLen(2,5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/e\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/en\", params: []string{\"en\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/123\", params: []string{\"123\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/12345\", params: []string{\"12345\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<min(5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/1\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/5\", params: []string{\"5\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<max(5)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/1\", params: []string{\"1\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/5\", params: []string{\"5\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/15\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<range(5,10)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/9\", params: []string{\"9\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/5\", params: []string{\"5\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/15\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/api/v1/:param<datetime(2006\\-01\\-02)>`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/2005-11-01\", params: []string{\"2005-11-01\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<regex(p([a-z]+)ch)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/15\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/peach\", params: []string{\"peach\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/p34ch\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<regex(^[a-z0-9]([a-z0-9-]{1,61}[a-z0-9])?$)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/12\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/xy\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/test\", params: []string{\"test\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/\" + strings.Repeat(\"a\", 64), params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/api/v1/:param<regex(\\d{4}-\\d{2}-\\d{2})}>`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/ent\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/15\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/2022-08-27\", params: []string{\"2022-08-27\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/2022/08-27\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<int;bool((>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: []string{\"8728382\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<int;max(3000)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/123\", params: []string{\"123\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<int;maxLen(10)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/87283827683\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/123\", params: []string{\"123\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<int;range(10,30)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/87283827683\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/25\", params: []string{\"25\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/api/v1/:param<int\\;range(10,30)>`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: []string{\"entity\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/87283827683\", params: []string{\"87283827683\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/25\", params: []string{\"25\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: []string{\"true\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/api/v1/:param<range(10\\,30,1500)>`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/87283827683\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/25\", params: []string{\"25\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/1200\", params: []string{\"1200\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:lang<len(2)>/videos/:page<range(100,1500)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/try/videos/200\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/tr/videos/1800\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/tr/videos/100\", params: []string{\"tr\", \"100\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/e/videos/10\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:lang<len(2)>/:page<range(100,1500)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/try/200\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/tr/1800\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/tr/100\", params: []string{\"tr\", \"100\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/e/10\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:lang/:page<range(100,1500)>\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/try/200\", params: []string{\"try\", \"200\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/tr/1800\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/tr/100\", params: []string{\"tr\", \"100\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/e/10\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:lang<len(2)>/:page\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/try/200\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/tr/1800\", params: []string{\"tr\", \"1800\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/tr/100\", params: []string{\"tr\", \"100\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/e/10\", params: nil, match: false},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: `/api/v1/:date<datetime(2006\\-01\\-02)>/:regex<regex(p([a-z]+)ch)>`,\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/2005-11-01/a\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/2005-1101/paach\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/2005-11-01/peach\", params: []string{\"2005-11-01\", \"peach\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: \"/api/v1/:param<int>?\",\n\t\t\t\ttestCases: []routeTestCase{\n\t\t\t\t\t{url: \"/api/v1/entity\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/8728382\", params: []string{\"8728382\"}, match: true},\n\t\t\t\t\t{url: \"/api/v1/true\", params: nil, match: false},\n\t\t\t\t\t{url: \"/api/v1/\", params: []string{\"\"}, match: true},\n\t\t\t\t},\n\t\t\t},\n\t\t}...,\n\t)\n}\n"
        },
        {
          "name": "prefork.go",
          "type": "blob",
          "size": 4.7,
          "content": "package fiber\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/valyala/fasthttp/reuseport\"\n\n\t\"github.com/gofiber/fiber/v3/log\"\n)\n\nconst (\n\tenvPreforkChildKey = \"FIBER_PREFORK_CHILD\"\n\tenvPreforkChildVal = \"1\"\n\tsleepDuration      = 100 * time.Millisecond\n)\n\nvar (\n\ttestPreforkMaster = false\n\ttestOnPrefork     = false\n)\n\n// IsChild determines if the current process is a child of Prefork\nfunc IsChild() bool {\n\treturn os.Getenv(envPreforkChildKey) == envPreforkChildVal\n}\n\n// prefork manages child processes to make use of the OS REUSEPORT or REUSEADDR feature\nfunc (app *App) prefork(addr string, tlsConfig *tls.Config, cfg ListenConfig) error {\n\tvar ln net.Listener\n\tvar err error\n\n\t// 👶 child process 👶\n\tif IsChild() {\n\t\t// use 1 cpu core per child process\n\t\truntime.GOMAXPROCS(1)\n\t\t// Linux will use SO_REUSEPORT and Windows falls back to SO_REUSEADDR\n\t\t// Only tcp4 or tcp6 is supported when preforking, both are not supported\n\t\tif ln, err = reuseport.Listen(cfg.ListenerNetwork, addr); err != nil {\n\t\t\tif !cfg.DisableStartupMessage {\n\t\t\t\ttime.Sleep(sleepDuration) // avoid colliding with startup message\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"prefork: %w\", err)\n\t\t}\n\t\t// wrap a tls config around the listener if provided\n\t\tif tlsConfig != nil {\n\t\t\tln = tls.NewListener(ln, tlsConfig)\n\t\t}\n\n\t\t// kill current child proc when master exits\n\t\tgo watchMaster()\n\n\t\t// prepare the server for the start\n\t\tapp.startupProcess()\n\n\t\tif cfg.ListenerAddrFunc != nil {\n\t\t\tcfg.ListenerAddrFunc(ln.Addr())\n\t\t}\n\n\t\t// listen for incoming connections\n\t\treturn app.server.Serve(ln)\n\t}\n\n\t// 👮 master process 👮\n\ttype child struct {\n\t\terr error\n\t\tpid int\n\t}\n\t// create variables\n\tmaxProcs := runtime.GOMAXPROCS(0)\n\tchilds := make(map[int]*exec.Cmd)\n\tchannel := make(chan child, maxProcs)\n\n\t// kill child procs when master exits\n\tdefer func() {\n\t\tfor _, proc := range childs {\n\t\t\tif err := proc.Process.Kill(); err != nil {\n\t\t\t\tif !errors.Is(err, os.ErrProcessDone) {\n\t\t\t\t\tlog.Errorf(\"prefork: failed to kill child: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// collect child pids\n\tvar pids []string\n\n\t// launch child procs\n\tfor i := 0; i < maxProcs; i++ {\n\t\tcmd := exec.Command(os.Args[0], os.Args[1:]...) //nolint:gosec // It's fine to launch the same process again\n\t\tif testPreforkMaster {\n\t\t\t// When test prefork master,\n\t\t\t// just start the child process with a dummy cmd,\n\t\t\t// which will exit soon\n\t\t\tcmd = dummyCmd()\n\t\t}\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\n\t\t// add fiber prefork child flag into child proc env\n\t\tcmd.Env = append(os.Environ(),\n\t\t\tfmt.Sprintf(\"%s=%s\", envPreforkChildKey, envPreforkChildVal),\n\t\t)\n\n\t\tif err = cmd.Start(); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to start a child prefork process, error: %w\", err)\n\t\t}\n\n\t\t// store child process\n\t\tpid := cmd.Process.Pid\n\t\tchilds[pid] = cmd\n\t\tpids = append(pids, strconv.Itoa(pid))\n\n\t\t// execute fork hook\n\t\tif app.hooks != nil {\n\t\t\tif testOnPrefork {\n\t\t\t\tapp.hooks.executeOnForkHooks(dummyPid)\n\t\t\t} else {\n\t\t\t\tapp.hooks.executeOnForkHooks(pid)\n\t\t\t}\n\t\t}\n\n\t\t// notify master if child crashes\n\t\tgo func() {\n\t\t\tchannel <- child{pid: pid, err: cmd.Wait()}\n\t\t}()\n\t}\n\n\t// Run onListen hooks\n\t// Hooks have to be run here as different as non-prefork mode due to they should run as child or master\n\tapp.runOnListenHooks(app.prepareListenData(addr, tlsConfig != nil, cfg))\n\n\t// Print startup message\n\tif !cfg.DisableStartupMessage {\n\t\tapp.startupMessage(addr, tlsConfig != nil, \",\"+strings.Join(pids, \",\"), cfg)\n\t}\n\n\t// Print routes\n\tif cfg.EnablePrintRoutes {\n\t\tapp.printRoutesMessage()\n\t}\n\n\t// return error if child crashes\n\treturn (<-channel).err\n}\n\n// watchMaster watches child procs\nfunc watchMaster() {\n\tif runtime.GOOS == \"windows\" {\n\t\t// finds parent process,\n\t\t// and waits for it to exit\n\t\tp, err := os.FindProcess(os.Getppid())\n\t\tif err == nil {\n\t\t\t_, _ = p.Wait() //nolint:errcheck // It is fine to ignore the error here\n\t\t}\n\t\tos.Exit(1) //nolint:revive // Calling os.Exit is fine here in the prefork\n\t}\n\t// if it is equal to 1 (init process ID),\n\t// it indicates that the master process has exited\n\tconst watchInterval = 500 * time.Millisecond\n\tfor range time.NewTicker(watchInterval).C {\n\t\tif os.Getppid() == 1 {\n\t\t\tos.Exit(1) //nolint:revive // Calling os.Exit is fine here in the prefork\n\t\t}\n\t}\n}\n\nvar (\n\tdummyPid      = 1\n\tdummyChildCmd atomic.Value\n)\n\n// dummyCmd is for internal prefork testing\nfunc dummyCmd() *exec.Cmd {\n\tcommand := \"go\"\n\tif storeCommand := dummyChildCmd.Load(); storeCommand != nil && storeCommand != \"\" {\n\t\tcommand = storeCommand.(string) //nolint:forcetypeassert,errcheck // We always store a string in here\n\t}\n\tif runtime.GOOS == \"windows\" {\n\t\treturn exec.Command(\"cmd\", \"/C\", command, \"version\")\n\t}\n\treturn exec.Command(command, \"version\")\n}\n"
        },
        {
          "name": "prefork_test.go",
          "type": "blob",
          "size": 2.4,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📄 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n// 💖 Maintained and modified for Fiber by @renewerner87\npackage fiber\n\nimport (\n\t\"crypto/tls\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc Test_App_Prefork_Child_Process(t *testing.T) {\n\t// Reset test var\n\ttestPreforkMaster = true\n\n\tsetupIsChild(t)\n\tdefer teardownIsChild(t)\n\n\tapp := New()\n\n\terr := app.prefork(\"invalid\", nil, listenConfigDefault())\n\trequire.Error(t, err)\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.prefork(\"[::1]:\", nil, ListenConfig{ListenerNetwork: NetworkTCP6}))\n\n\t// Create tls certificate\n\tcer, err := tls.LoadX509KeyPair(\"./.github/testdata/ssl.pem\", \"./.github/testdata/ssl.key\")\n\tif err != nil {\n\t\trequire.NoError(t, err)\n\t}\n\t//nolint:gosec // We're in a test so using old ciphers is fine\n\tconfig := &tls.Config{Certificates: []tls.Certificate{cer}}\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.prefork(\"127.0.0.1:\", config, listenConfigDefault()))\n}\n\nfunc Test_App_Prefork_Master_Process(t *testing.T) {\n\t// Reset test var\n\ttestPreforkMaster = true\n\n\tapp := New()\n\n\tgo func() {\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tassert.NoError(t, app.Shutdown())\n\t}()\n\n\trequire.NoError(t, app.prefork(\":3000\", nil, listenConfigDefault()))\n\n\tdummyChildCmd.Store(\"invalid\")\n\n\terr := app.prefork(\"127.0.0.1:\", nil, listenConfigDefault())\n\trequire.Error(t, err)\n\n\tdummyChildCmd.Store(\"go\")\n}\n\nfunc Test_App_Prefork_Child_Process_Never_Show_Startup_Message(t *testing.T) {\n\tsetupIsChild(t)\n\tdefer teardownIsChild(t)\n\n\trescueStdout := os.Stdout\n\tdefer func() { os.Stdout = rescueStdout }()\n\n\tr, w, err := os.Pipe()\n\trequire.NoError(t, err)\n\n\tos.Stdout = w\n\n\tNew().startupProcess().startupMessage(\":3000\", false, \"\", listenConfigDefault())\n\n\trequire.NoError(t, w.Close())\n\n\tout, err := io.ReadAll(r)\n\trequire.NoError(t, err)\n\trequire.Empty(t, out)\n}\n\nfunc setupIsChild(t *testing.T) {\n\tt.Helper()\n\n\trequire.NoError(t, os.Setenv(envPreforkChildKey, envPreforkChildVal)) //nolint:tenv // Ignore error\n}\n\nfunc teardownIsChild(t *testing.T) {\n\tt.Helper()\n\n\trequire.NoError(t, os.Setenv(envPreforkChildKey, \"\")) //nolint:tenv // Ignore error\n}\n"
        },
        {
          "name": "redirect.go",
          "type": "blob",
          "size": 7.52,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📝 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\n\t\"github.com/gofiber/fiber/v3/binder\"\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/valyala/bytebufferpool\"\n)\n\n// Pool for redirection\nvar redirectPool = sync.Pool{\n\tNew: func() any {\n\t\treturn &Redirect{\n\t\t\tstatus:   StatusFound,\n\t\t\tmessages: make(redirectionMsgs, 0),\n\t\t}\n\t},\n}\n\n// Cookie name to send flash messages when to use redirection.\nconst (\n\tFlashCookieName     = \"fiber_flash\"\n\tOldInputDataPrefix  = \"old_input_data_\"\n\tCookieDataSeparator = \",\"\n\tCookieDataAssigner  = \":\"\n)\n\n// redirectionMsgs is a struct that used to store flash messages and old input data in cookie using MSGP.\n// msgp -file=\"redirect.go\" -o=\"redirect_msgp.go\" -unexported\n//\n//msgp:ignore Redirect RedirectConfig OldInputData FlashMessage\ntype redirectionMsg struct {\n\tkey        string\n\tvalue      string\n\tlevel      uint8\n\tisOldInput bool\n}\n\ntype redirectionMsgs []redirectionMsg\n\n// OldInputData is a struct that holds the old input data.\ntype OldInputData struct {\n\tKey   string\n\tValue string\n}\n\n// FlashMessage is a struct that holds the flash message data.\ntype FlashMessage struct {\n\tKey   string\n\tValue string\n\tLevel uint8\n}\n\n// Redirect is a struct that holds the redirect data.\ntype Redirect struct {\n\tc        *DefaultCtx     // Embed ctx\n\tmessages redirectionMsgs // Flash messages and old input data\n\tstatus   int             // Status code of redirection. Default: StatusFound\n}\n\n// RedirectConfig A config to use with Redirect().Route()\n// You can specify queries or route parameters.\n// NOTE: We don't use net/url to parse parameters because of it has poor performance. You have to pass map.\ntype RedirectConfig struct {\n\tParams  Map               // Route parameters\n\tQueries map[string]string // Query map\n}\n\n// AcquireRedirect return default Redirect reference from the redirect pool\nfunc AcquireRedirect() *Redirect {\n\tredirect, ok := redirectPool.Get().(*Redirect)\n\tif !ok {\n\t\tpanic(errors.New(\"failed to type-assert to *Redirect\"))\n\t}\n\n\treturn redirect\n}\n\n// ReleaseRedirect returns c acquired via Redirect to redirect pool.\n//\n// It is forbidden accessing req and/or its' members after returning\n// it to redirect pool.\nfunc ReleaseRedirect(r *Redirect) {\n\tr.release()\n\tredirectPool.Put(r)\n}\n\nfunc (r *Redirect) release() {\n\tr.status = 302\n\tr.messages = r.messages[:0]\n\tr.c = nil\n}\n\n// Status sets the status code of redirection.\n// If status is not specified, status defaults to 302 Found.\nfunc (r *Redirect) Status(code int) *Redirect {\n\tr.status = code\n\n\treturn r\n}\n\n// With You can send flash messages by using With().\n// They will be sent as a cookie.\n// You can get them by using: Redirect().Messages(), Redirect().Message()\n// Note: You must use escape char before using ',' and ':' chars to avoid wrong parsing.\nfunc (r *Redirect) With(key, value string, level ...uint8) *Redirect {\n\t// Get level\n\tvar msgLevel uint8\n\tif len(level) > 0 {\n\t\tmsgLevel = level[0]\n\t}\n\n\t// Override old message if exists\n\tfor i, msg := range r.messages {\n\t\tif msg.key == key && !msg.isOldInput {\n\t\t\tr.messages[i].value = value\n\t\t\tr.messages[i].level = msgLevel\n\n\t\t\treturn r\n\t\t}\n\t}\n\n\tr.messages = append(r.messages, redirectionMsg{\n\t\tkey:   key,\n\t\tvalue: value,\n\t\tlevel: msgLevel,\n\t})\n\n\treturn r\n}\n\n// WithInput You can send input data by using WithInput().\n// They will be sent as a cookie.\n// This method can send form, multipart form, query data to redirected route.\n// You can get them by using: Redirect().OldInputs(), Redirect().OldInput()\nfunc (r *Redirect) WithInput() *Redirect {\n\t// Get content-type\n\tctype := utils.ToLower(utils.UnsafeString(r.c.RequestCtx().Request.Header.ContentType()))\n\tctype = binder.FilterFlags(utils.ParseVendorSpecificContentType(ctype))\n\n\toldInput := make(map[string]string)\n\tswitch ctype {\n\tcase MIMEApplicationForm, MIMEMultipartForm:\n\t\t_ = r.c.Bind().Form(oldInput) //nolint:errcheck // not needed\n\tdefault:\n\t\t_ = r.c.Bind().Query(oldInput) //nolint:errcheck // not needed\n\t}\n\n\t// Add old input data\n\tfor k, v := range oldInput {\n\t\tr.messages = append(r.messages, redirectionMsg{\n\t\t\tkey:        k,\n\t\t\tvalue:      v,\n\t\t\tisOldInput: true,\n\t\t})\n\t}\n\n\treturn r\n}\n\n// Messages Get flash messages.\nfunc (r *Redirect) Messages() []FlashMessage {\n\tflashMessages := make([]FlashMessage, 0)\n\n\tfor _, msg := range r.c.flashMessages {\n\t\tif !msg.isOldInput {\n\t\t\tflashMessages = append(flashMessages, FlashMessage{\n\t\t\t\tKey:   msg.key,\n\t\t\t\tValue: msg.value,\n\t\t\t\tLevel: msg.level,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn flashMessages\n}\n\n// Message Get flash message by key.\nfunc (r *Redirect) Message(key string) FlashMessage {\n\tmsgs := r.c.flashMessages\n\n\tfor _, msg := range msgs {\n\t\tif msg.key == key && !msg.isOldInput {\n\t\t\treturn FlashMessage{\n\t\t\t\tKey:   msg.key,\n\t\t\t\tValue: msg.value,\n\t\t\t\tLevel: msg.level,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FlashMessage{}\n}\n\n// OldInputs Get old input data.\nfunc (r *Redirect) OldInputs() []OldInputData {\n\tinputs := make([]OldInputData, 0)\n\n\tfor _, msg := range r.c.flashMessages {\n\t\tif msg.isOldInput {\n\t\t\tinputs = append(inputs, OldInputData{\n\t\t\t\tKey:   msg.key,\n\t\t\t\tValue: msg.value,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn inputs\n}\n\n// OldInput Get old input data by key.\nfunc (r *Redirect) OldInput(key string) OldInputData {\n\tmsgs := r.c.flashMessages\n\n\tfor _, msg := range msgs {\n\t\tif msg.key == key && msg.isOldInput {\n\t\t\treturn OldInputData{\n\t\t\t\tKey:   msg.key,\n\t\t\t\tValue: msg.value,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn OldInputData{}\n}\n\n// To redirect to the URL derived from the specified path, with specified status.\nfunc (r *Redirect) To(location string) error {\n\tr.c.setCanonical(HeaderLocation, location)\n\tr.c.Status(r.status)\n\n\tr.processFlashMessages()\n\n\treturn nil\n}\n\n// Route redirects to the Route registered in the app with appropriate parameters.\n// If you want to send queries or params to route, you should use config parameter.\nfunc (r *Redirect) Route(name string, config ...RedirectConfig) error {\n\t// Check config\n\tcfg := RedirectConfig{}\n\tif len(config) > 0 {\n\t\tcfg = config[0]\n\t}\n\n\t// Get location from route name\n\tlocation, err := r.c.getLocationFromRoute(r.c.App().GetRoute(name), cfg.Params)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check queries\n\tif len(cfg.Queries) > 0 {\n\t\tqueryText := bytebufferpool.Get()\n\t\tdefer bytebufferpool.Put(queryText)\n\n\t\ti := 1\n\t\tfor k, v := range cfg.Queries {\n\t\t\tqueryText.WriteString(k + \"=\" + v)\n\n\t\t\tif i != len(cfg.Queries) {\n\t\t\t\tqueryText.WriteString(\"&\")\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\treturn r.To(location + \"?\" + r.c.app.getString(queryText.Bytes()))\n\t}\n\n\treturn r.To(location)\n}\n\n// Back redirect to the URL to referer.\nfunc (r *Redirect) Back(fallback ...string) error {\n\tlocation := r.c.Get(HeaderReferer)\n\tif location == \"\" {\n\t\t// Check fallback URL\n\t\tif len(fallback) == 0 {\n\t\t\terr := ErrRedirectBackNoFallback\n\t\t\tr.c.Status(err.Code)\n\n\t\t\treturn err\n\t\t}\n\t\tlocation = fallback[0]\n\t}\n\n\treturn r.To(location)\n}\n\n// parseAndClearFlashMessages is a method to get flash messages before they are getting removed\nfunc (r *Redirect) parseAndClearFlashMessages() {\n\t// parse flash messages\n\tcookieValue := r.c.Cookies(FlashCookieName)\n\n\t_, err := r.c.flashMessages.UnmarshalMsg(r.c.app.getBytes(cookieValue))\n\tif err != nil {\n\t\treturn\n\t}\n}\n\n// processFlashMessages is a helper function to process flash messages and old input data\n// and set them as cookies\nfunc (r *Redirect) processFlashMessages() {\n\tif len(r.messages) == 0 {\n\t\treturn\n\t}\n\n\tval, err := r.messages.MarshalMsg(nil)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tr.c.Cookie(&Cookie{\n\t\tName:        FlashCookieName,\n\t\tValue:       r.c.app.getString(val),\n\t\tSessionOnly: true,\n\t})\n}\n"
        },
        {
          "name": "redirect_msgp.go",
          "type": "blob",
          "size": 5.9,
          "content": "package fiber\n\n// Code generated by github.com/tinylib/msgp DO NOT EDIT.\n\nimport (\n\t\"github.com/tinylib/msgp/msgp\"\n)\n\n// DecodeMsg implements msgp.Decodable\nfunc (z *redirectionMsg) DecodeMsg(dc *msgp.Reader) (err error) {\n\tvar field []byte\n\t_ = field\n\tvar zb0001 uint32\n\tzb0001, err = dc.ReadMapHeader()\n\tif err != nil {\n\t\terr = msgp.WrapError(err)\n\t\treturn\n\t}\n\tfor zb0001 > 0 {\n\t\tzb0001--\n\t\tfield, err = dc.ReadMapKeyPtr()\n\t\tif err != nil {\n\t\t\terr = msgp.WrapError(err)\n\t\t\treturn\n\t\t}\n\t\tswitch msgp.UnsafeString(field) {\n\t\tcase \"key\":\n\t\t\tz.key, err = dc.ReadString()\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"key\")\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \"value\":\n\t\t\tz.value, err = dc.ReadString()\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"value\")\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \"level\":\n\t\t\tz.level, err = dc.ReadUint8()\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"level\")\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \"isOldInput\":\n\t\t\tz.isOldInput, err = dc.ReadBool()\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"isOldInput\")\n\t\t\t\treturn\n\t\t\t}\n\t\tdefault:\n\t\t\terr = dc.Skip()\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n// EncodeMsg implements msgp.Encodable\nfunc (z *redirectionMsg) EncodeMsg(en *msgp.Writer) (err error) {\n\t// map header, size 4\n\t// write \"key\"\n\terr = en.Append(0x84, 0xa3, 0x6b, 0x65, 0x79)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = en.WriteString(z.key)\n\tif err != nil {\n\t\terr = msgp.WrapError(err, \"key\")\n\t\treturn\n\t}\n\t// write \"value\"\n\terr = en.Append(0xa5, 0x76, 0x61, 0x6c, 0x75, 0x65)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = en.WriteString(z.value)\n\tif err != nil {\n\t\terr = msgp.WrapError(err, \"value\")\n\t\treturn\n\t}\n\t// write \"level\"\n\terr = en.Append(0xa5, 0x6c, 0x65, 0x76, 0x65, 0x6c)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = en.WriteUint8(z.level)\n\tif err != nil {\n\t\terr = msgp.WrapError(err, \"level\")\n\t\treturn\n\t}\n\t// write \"isOldInput\"\n\terr = en.Append(0xaa, 0x69, 0x73, 0x4f, 0x6c, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = en.WriteBool(z.isOldInput)\n\tif err != nil {\n\t\terr = msgp.WrapError(err, \"isOldInput\")\n\t\treturn\n\t}\n\treturn\n}\n\n// MarshalMsg implements msgp.Marshaler\nfunc (z *redirectionMsg) MarshalMsg(b []byte) (o []byte, err error) {\n\to = msgp.Require(b, z.Msgsize())\n\t// map header, size 4\n\t// string \"key\"\n\to = append(o, 0x84, 0xa3, 0x6b, 0x65, 0x79)\n\to = msgp.AppendString(o, z.key)\n\t// string \"value\"\n\to = append(o, 0xa5, 0x76, 0x61, 0x6c, 0x75, 0x65)\n\to = msgp.AppendString(o, z.value)\n\t// string \"level\"\n\to = append(o, 0xa5, 0x6c, 0x65, 0x76, 0x65, 0x6c)\n\to = msgp.AppendUint8(o, z.level)\n\t// string \"isOldInput\"\n\to = append(o, 0xaa, 0x69, 0x73, 0x4f, 0x6c, 0x64, 0x49, 0x6e, 0x70, 0x75, 0x74)\n\to = msgp.AppendBool(o, z.isOldInput)\n\treturn\n}\n\n// UnmarshalMsg implements msgp.Unmarshaler\nfunc (z *redirectionMsg) UnmarshalMsg(bts []byte) (o []byte, err error) {\n\tvar field []byte\n\t_ = field\n\tvar zb0001 uint32\n\tzb0001, bts, err = msgp.ReadMapHeaderBytes(bts)\n\tif err != nil {\n\t\terr = msgp.WrapError(err)\n\t\treturn\n\t}\n\tfor zb0001 > 0 {\n\t\tzb0001--\n\t\tfield, bts, err = msgp.ReadMapKeyZC(bts)\n\t\tif err != nil {\n\t\t\terr = msgp.WrapError(err)\n\t\t\treturn\n\t\t}\n\t\tswitch msgp.UnsafeString(field) {\n\t\tcase \"key\":\n\t\t\tz.key, bts, err = msgp.ReadStringBytes(bts)\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"key\")\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \"value\":\n\t\t\tz.value, bts, err = msgp.ReadStringBytes(bts)\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"value\")\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \"level\":\n\t\t\tz.level, bts, err = msgp.ReadUint8Bytes(bts)\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"level\")\n\t\t\t\treturn\n\t\t\t}\n\t\tcase \"isOldInput\":\n\t\t\tz.isOldInput, bts, err = msgp.ReadBoolBytes(bts)\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err, \"isOldInput\")\n\t\t\t\treturn\n\t\t\t}\n\t\tdefault:\n\t\t\tbts, err = msgp.Skip(bts)\n\t\t\tif err != nil {\n\t\t\t\terr = msgp.WrapError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\to = bts\n\treturn\n}\n\n// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message\nfunc (z *redirectionMsg) Msgsize() (s int) {\n\ts = 1 + 4 + msgp.StringPrefixSize + len(z.key) + 6 + msgp.StringPrefixSize + len(z.value) + 6 + msgp.Uint8Size + 11 + msgp.BoolSize\n\treturn\n}\n\n// DecodeMsg implements msgp.Decodable\nfunc (z *redirectionMsgs) DecodeMsg(dc *msgp.Reader) (err error) {\n\tvar zb0002 uint32\n\tzb0002, err = dc.ReadArrayHeader()\n\tif err != nil {\n\t\terr = msgp.WrapError(err)\n\t\treturn\n\t}\n\tif cap((*z)) >= int(zb0002) {\n\t\t(*z) = (*z)[:zb0002]\n\t} else {\n\t\t(*z) = make(redirectionMsgs, zb0002)\n\t}\n\tfor zb0001 := range *z {\n\t\terr = (*z)[zb0001].DecodeMsg(dc)\n\t\tif err != nil {\n\t\t\terr = msgp.WrapError(err, zb0001)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// EncodeMsg implements msgp.Encodable\nfunc (z redirectionMsgs) EncodeMsg(en *msgp.Writer) (err error) {\n\terr = en.WriteArrayHeader(uint32(len(z)))\n\tif err != nil {\n\t\terr = msgp.WrapError(err)\n\t\treturn\n\t}\n\tfor zb0003 := range z {\n\t\terr = z[zb0003].EncodeMsg(en)\n\t\tif err != nil {\n\t\t\terr = msgp.WrapError(err, zb0003)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// MarshalMsg implements msgp.Marshaler\nfunc (z redirectionMsgs) MarshalMsg(b []byte) (o []byte, err error) {\n\to = msgp.Require(b, z.Msgsize())\n\to = msgp.AppendArrayHeader(o, uint32(len(z)))\n\tfor zb0003 := range z {\n\t\to, err = z[zb0003].MarshalMsg(o)\n\t\tif err != nil {\n\t\t\terr = msgp.WrapError(err, zb0003)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// UnmarshalMsg implements msgp.Unmarshaler\nfunc (z *redirectionMsgs) UnmarshalMsg(bts []byte) (o []byte, err error) {\n\tvar zb0002 uint32\n\tzb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)\n\tif err != nil {\n\t\terr = msgp.WrapError(err)\n\t\treturn\n\t}\n\tif cap((*z)) >= int(zb0002) {\n\t\t(*z) = (*z)[:zb0002]\n\t} else {\n\t\t(*z) = make(redirectionMsgs, zb0002)\n\t}\n\tfor zb0001 := range *z {\n\t\tbts, err = (*z)[zb0001].UnmarshalMsg(bts)\n\t\tif err != nil {\n\t\t\terr = msgp.WrapError(err, zb0001)\n\t\t\treturn\n\t\t}\n\t}\n\to = bts\n\treturn\n}\n\n// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message\nfunc (z redirectionMsgs) Msgsize() (s int) {\n\ts = msgp.ArrayHeaderSize\n\tfor zb0003 := range z {\n\t\ts += z[zb0003].Msgsize()\n\t}\n\treturn\n}\n"
        },
        {
          "name": "redirect_msgp_test.go",
          "type": "blob",
          "size": 4.56,
          "content": "package fiber\n\n// Code generated by github.com/tinylib/msgp DO NOT EDIT.\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/tinylib/msgp/msgp\"\n)\n\nfunc TestMarshalUnmarshalredirectionMsg(t *testing.T) {\n\tv := redirectionMsg{}\n\tbts, err := v.MarshalMsg(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tleft, err := v.UnmarshalMsg(bts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(left) > 0 {\n\t\tt.Errorf(\"%d bytes left over after UnmarshalMsg(): %q\", len(left), left)\n\t}\n\n\tleft, err = msgp.Skip(bts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(left) > 0 {\n\t\tt.Errorf(\"%d bytes left over after Skip(): %q\", len(left), left)\n\t}\n}\n\nfunc BenchmarkMarshalMsgredirectionMsg(b *testing.B) {\n\tv := redirectionMsg{}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tv.MarshalMsg(nil)\n\t}\n}\n\nfunc BenchmarkAppendMsgredirectionMsg(b *testing.B) {\n\tv := redirectionMsg{}\n\tbts := make([]byte, 0, v.Msgsize())\n\tbts, _ = v.MarshalMsg(bts[0:0])\n\tb.SetBytes(int64(len(bts)))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tbts, _ = v.MarshalMsg(bts[0:0])\n\t}\n}\n\nfunc BenchmarkUnmarshalredirectionMsg(b *testing.B) {\n\tv := redirectionMsg{}\n\tbts, _ := v.MarshalMsg(nil)\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(bts)))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := v.UnmarshalMsg(bts)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestEncodeDecoderedirectionMsg(t *testing.T) {\n\tv := redirectionMsg{}\n\tvar buf bytes.Buffer\n\tmsgp.Encode(&buf, &v)\n\n\tm := v.Msgsize()\n\tif buf.Len() > m {\n\t\tt.Log(\"WARNING: TestEncodeDecoderedirectionMsg Msgsize() is inaccurate\")\n\t}\n\n\tvn := redirectionMsg{}\n\terr := msgp.Decode(&buf, &vn)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tbuf.Reset()\n\tmsgp.Encode(&buf, &v)\n\terr = msgp.NewReader(&buf).Skip()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc BenchmarkEncoderedirectionMsg(b *testing.B) {\n\tv := redirectionMsg{}\n\tvar buf bytes.Buffer\n\tmsgp.Encode(&buf, &v)\n\tb.SetBytes(int64(buf.Len()))\n\ten := msgp.NewWriter(msgp.Nowhere)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tv.EncodeMsg(en)\n\t}\n\ten.Flush()\n}\n\nfunc BenchmarkDecoderedirectionMsg(b *testing.B) {\n\tv := redirectionMsg{}\n\tvar buf bytes.Buffer\n\tmsgp.Encode(&buf, &v)\n\tb.SetBytes(int64(buf.Len()))\n\trd := msgp.NewEndlessReader(buf.Bytes(), b)\n\tdc := msgp.NewReader(rd)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr := v.DecodeMsg(dc)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestMarshalUnmarshalredirectionMsgs(t *testing.T) {\n\tv := redirectionMsgs{}\n\tbts, err := v.MarshalMsg(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tleft, err := v.UnmarshalMsg(bts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(left) > 0 {\n\t\tt.Errorf(\"%d bytes left over after UnmarshalMsg(): %q\", len(left), left)\n\t}\n\n\tleft, err = msgp.Skip(bts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(left) > 0 {\n\t\tt.Errorf(\"%d bytes left over after Skip(): %q\", len(left), left)\n\t}\n}\n\nfunc BenchmarkMarshalMsgredirectionMsgs(b *testing.B) {\n\tv := redirectionMsgs{}\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tv.MarshalMsg(nil)\n\t}\n}\n\nfunc BenchmarkAppendMsgredirectionMsgs(b *testing.B) {\n\tv := redirectionMsgs{}\n\tbts := make([]byte, 0, v.Msgsize())\n\tbts, _ = v.MarshalMsg(bts[0:0])\n\tb.SetBytes(int64(len(bts)))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tbts, _ = v.MarshalMsg(bts[0:0])\n\t}\n}\n\nfunc BenchmarkUnmarshalredirectionMsgs(b *testing.B) {\n\tv := redirectionMsgs{}\n\tbts, _ := v.MarshalMsg(nil)\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(bts)))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := v.UnmarshalMsg(bts)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestEncodeDecoderedirectionMsgs(t *testing.T) {\n\tv := redirectionMsgs{}\n\tvar buf bytes.Buffer\n\tmsgp.Encode(&buf, &v)\n\n\tm := v.Msgsize()\n\tif buf.Len() > m {\n\t\tt.Log(\"WARNING: TestEncodeDecoderedirectionMsgs Msgsize() is inaccurate\")\n\t}\n\n\tvn := redirectionMsgs{}\n\terr := msgp.Decode(&buf, &vn)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tbuf.Reset()\n\tmsgp.Encode(&buf, &v)\n\terr = msgp.NewReader(&buf).Skip()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc BenchmarkEncoderedirectionMsgs(b *testing.B) {\n\tv := redirectionMsgs{}\n\tvar buf bytes.Buffer\n\tmsgp.Encode(&buf, &v)\n\tb.SetBytes(int64(buf.Len()))\n\ten := msgp.NewWriter(msgp.Nowhere)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tv.EncodeMsg(en)\n\t}\n\ten.Flush()\n}\n\nfunc BenchmarkDecoderedirectionMsgs(b *testing.B) {\n\tv := redirectionMsgs{}\n\tvar buf bytes.Buffer\n\tmsgp.Encode(&buf, &v)\n\tb.SetBytes(int64(buf.Len()))\n\trd := msgp.NewEndlessReader(buf.Bytes(), b)\n\tdc := msgp.NewReader(rd)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr := v.DecodeMsg(dc)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "redirect_test.go",
          "type": "blob",
          "size": 23.16,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📝 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"mime/multipart\"\n\t\"net/url\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// go test -run Test_Redirect_To\nfunc Test_Redirect_To(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().To(\"http://default.com\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"http://default.com\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\terr = c.Redirect().Status(301).To(\"http://example.com\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 301, c.Response().StatusCode())\n\trequire.Equal(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Redirect_To_WithFlashMessages\nfunc Test_Redirect_To_WithFlashMessages(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().With(\"success\", \"2\").With(\"success\", \"1\").With(\"message\", \"test\", 2).To(\"http://example.com\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"http://example.com\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\tvar msgs redirectionMsgs\n\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\trequire.NoError(t, err)\n\n\trequire.Len(t, msgs, 2)\n\trequire.Contains(t, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\trequire.Contains(t, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 2, isOldInput: false})\n}\n\n// go test -run Test_Redirect_Route_WithParams\nfunc Test_Redirect_Route_WithParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().Route(\"user\", RedirectConfig{\n\t\tParams: Map{\n\t\t\t\"name\": \"fiber\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Redirect_Route_WithParams_WithQueries\nfunc Test_Redirect_Route_WithParams_WithQueries(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().Route(\"user\", RedirectConfig{\n\t\tParams: Map{\n\t\t\t\"name\": \"fiber\",\n\t\t},\n\t\tQueries: map[string]string{\"data[0][name]\": \"john\", \"data[0][age]\": \"10\", \"test\": \"doe\"},\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\n\t// analysis of query parameters with url parsing, since a map pass is always randomly ordered\n\tlocation, err := url.Parse(string(c.Response().Header.Peek(HeaderLocation)))\n\trequire.NoError(t, err, \"url.Parse(location)\")\n\trequire.Equal(t, \"/user/fiber\", location.Path)\n\trequire.Equal(t, url.Values{\"data[0][name]\": []string{\"john\"}, \"data[0][age]\": []string{\"10\"}, \"test\": []string{\"doe\"}}, location.Query())\n}\n\n// go test -run Test_Redirect_Route_WithOptionalParams\nfunc Test_Redirect_Route_WithOptionalParams(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name?\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().Route(\"user\", RedirectConfig{\n\t\tParams: Map{\n\t\t\t\"name\": \"fiber\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Redirect_Route_WithOptionalParamsWithoutValue\nfunc Test_Redirect_Route_WithOptionalParamsWithoutValue(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/:name?\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().Route(\"user\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/user/\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Redirect_Route_WithGreedyParameters\nfunc Test_Redirect_Route_WithGreedyParameters(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/user/+\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"+\"))\n\t}).Name(\"user\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().Route(\"user\", RedirectConfig{\n\t\tParams: Map{\n\t\t\t\"+\": \"test/routes\",\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/user/test/routes\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Redirect_Back\nfunc Test_Redirect_Back(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.JSON(\"Home\")\n\t}).Name(\"home\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\terr := c.Redirect().Back(\"/\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\terr = c.Redirect().Back()\n\trequire.Equal(t, 500, c.Response().StatusCode())\n\trequire.ErrorAs(t, err, &ErrRedirectBackNoFallback)\n}\n\n// go test -run Test_Redirect_Back_WithFlashMessages\nfunc Test_Redirect_Back_WithFlashMessages(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\terr := c.Redirect().With(\"success\", \"1\").With(\"message\", \"test\").Back(\"/\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\tvar msgs redirectionMsgs\n\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\trequire.NoError(t, err)\n\n\trequire.Len(t, msgs, 2)\n\trequire.Contains(t, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\trequire.Contains(t, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n}\n\n// go test -run Test_Redirect_Back_WithReferer\nfunc Test_Redirect_Back_WithReferer(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.JSON(\"Home\")\n\t}).Name(\"home\")\n\tapp.Get(\"/back\", func(c Ctx) error {\n\t\treturn c.JSON(\"Back\")\n\t}).Name(\"back\")\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{})\n\n\tc.Request().Header.Set(HeaderReferer, \"/back\")\n\terr := c.Redirect().Back(\"/\")\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/back\", c.Get(HeaderReferer))\n\trequire.Equal(t, \"/back\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -run Test_Redirect_Route_WithFlashMessages\nfunc Test_Redirect_Route_WithFlashMessages(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\terr := c.Redirect().With(\"success\", \"1\").With(\"message\", \"test\").Route(\"user\")\n\n\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, 302, c.Response().StatusCode())\n\trequire.Equal(t, \"/user\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\tvar msgs redirectionMsgs\n\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\trequire.NoError(t, err)\n\n\trequire.Len(t, msgs, 2)\n\trequire.Contains(t, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\trequire.Contains(t, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n}\n\n// go test -run Test_Redirect_Route_WithOldInput\nfunc Test_Redirect_Route_WithOldInput(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"Query\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New()\n\t\tapp.Get(\"/user\", func(c Ctx) error {\n\t\t\treturn c.SendString(\"user\")\n\t\t}).Name(\"user\")\n\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\t\tc.Request().URI().SetQueryString(\"id=1&name=tom\")\n\t\terr := c.Redirect().With(\"success\", \"1\").With(\"message\", \"test\").WithInput().Route(\"user\")\n\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"id\", value: \"1\", isOldInput: true})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"name\", value: \"tom\", isOldInput: true})\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, 302, c.Response().StatusCode())\n\t\trequire.Equal(t, \"/user\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\t\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\t\tvar msgs redirectionMsgs\n\t\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\t\trequire.NoError(t, err)\n\n\t\trequire.Len(t, msgs, 4)\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"id\", value: \"1\", level: 0, isOldInput: true})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"name\", value: \"tom\", level: 0, isOldInput: true})\n\t})\n\n\tt.Run(\"Form\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New()\n\t\tapp.Post(\"/user\", func(c Ctx) error {\n\t\t\treturn c.SendString(\"user\")\n\t\t}).Name(\"user\")\n\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\t\tc.Request().Header.Set(HeaderContentType, MIMEApplicationForm)\n\t\tc.Request().SetBodyString(\"id=1&name=tom\")\n\t\terr := c.Redirect().With(\"success\", \"1\").With(\"message\", \"test\").WithInput().Route(\"user\")\n\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"id\", value: \"1\", isOldInput: true})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"name\", value: \"tom\", isOldInput: true})\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, 302, c.Response().StatusCode())\n\t\trequire.Equal(t, \"/user\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\t\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\t\tvar msgs redirectionMsgs\n\t\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\t\trequire.NoError(t, err)\n\n\t\trequire.Len(t, msgs, 4)\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"id\", value: \"1\", level: 0, isOldInput: true})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"name\", value: \"tom\", level: 0, isOldInput: true})\n\t})\n\n\tt.Run(\"MultipartForm\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tapp := New()\n\t\tapp.Get(\"/user\", func(c Ctx) error {\n\t\t\treturn c.SendString(\"user\")\n\t\t}).Name(\"user\")\n\n\t\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\t\tbody := &bytes.Buffer{}\n\t\twriter := multipart.NewWriter(body)\n\n\t\trequire.NoError(t, writer.WriteField(\"id\", \"1\"))\n\t\trequire.NoError(t, writer.WriteField(\"name\", \"tom\"))\n\t\trequire.NoError(t, writer.Close())\n\n\t\tc.Request().SetBody(body.Bytes())\n\t\tc.Request().Header.Set(HeaderContentType, writer.FormDataContentType())\n\n\t\terr := c.Redirect().With(\"success\", \"1\").With(\"message\", \"test\").WithInput().Route(\"user\")\n\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"id\", value: \"1\", isOldInput: true})\n\t\trequire.Contains(t, c.redirect.messages, redirectionMsg{key: \"name\", value: \"tom\", isOldInput: true})\n\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, 302, c.Response().StatusCode())\n\t\trequire.Equal(t, \"/user\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\t\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\t\tvar msgs redirectionMsgs\n\t\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\t\trequire.NoError(t, err)\n\n\t\trequire.Len(t, msgs, 4)\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"id\", value: \"1\", level: 0, isOldInput: true})\n\t\trequire.Contains(t, msgs, redirectionMsg{key: \"name\", value: \"tom\", level: 0, isOldInput: true})\n\t})\n}\n\n// go test -run Test_Redirect_parseAndClearFlashMessages\nfunc Test_Redirect_parseAndClearFlashMessages(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tmsgs := redirectionMsgs{\n\t\t{\n\t\t\tkey:   \"success\",\n\t\t\tvalue: \"1\",\n\t\t},\n\t\t{\n\t\t\tkey:   \"message\",\n\t\t\tvalue: \"test\",\n\t\t},\n\t\t{\n\t\t\tkey:        \"name\",\n\t\t\tvalue:      \"tom\",\n\t\t\tisOldInput: true,\n\t\t},\n\t\t{\n\t\t\tkey:        \"id\",\n\t\t\tvalue:      \"1\",\n\t\t\tisOldInput: true,\n\t\t},\n\t}\n\n\tval, err := msgs.MarshalMsg(nil)\n\trequire.NoError(t, err)\n\n\tc.Request().Header.Set(HeaderCookie, \"fiber_flash=\"+string(val))\n\n\tc.Redirect().parseAndClearFlashMessages()\n\n\trequire.Equal(t, FlashMessage{\n\t\tKey:   \"success\",\n\t\tValue: \"1\",\n\t\tLevel: 0,\n\t}, c.Redirect().Message(\"success\"))\n\n\trequire.Equal(t, FlashMessage{\n\t\tKey:   \"message\",\n\t\tValue: \"test\",\n\t\tLevel: 0,\n\t}, c.Redirect().Message(\"message\"))\n\n\trequire.Equal(t, FlashMessage{}, c.Redirect().Message(\"not_message\"))\n\n\trequire.Equal(t, []FlashMessage{\n\t\t{\n\t\t\tKey:   \"success\",\n\t\t\tValue: \"1\",\n\t\t\tLevel: 0,\n\t\t},\n\t\t{\n\t\t\tKey:   \"message\",\n\t\t\tValue: \"test\",\n\t\t\tLevel: 0,\n\t\t},\n\t}, c.Redirect().Messages())\n\n\trequire.Equal(t, OldInputData{\n\t\tKey:   \"id\",\n\t\tValue: \"1\",\n\t}, c.Redirect().OldInput(\"id\"))\n\n\trequire.Equal(t, OldInputData{\n\t\tKey:   \"name\",\n\t\tValue: \"tom\",\n\t}, c.Redirect().OldInput(\"name\"))\n\n\trequire.Equal(t, OldInputData{}, c.Redirect().OldInput(\"not_name\"))\n\n\trequire.Equal(t, []OldInputData{\n\t\t{\n\t\t\tKey:   \"name\",\n\t\t\tValue: \"tom\",\n\t\t},\n\t\t{\n\t\t\tKey:   \"id\",\n\t\t\tValue: \"1\",\n\t\t},\n\t}, c.Redirect().OldInputs())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_Route -benchmem -count=4\nfunc Benchmark_Redirect_Route(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Redirect().Route(\"user\", RedirectConfig{\n\t\t\tParams: Map{\n\t\t\t\t\"name\": \"fiber\",\n\t\t\t},\n\t\t})\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 302, c.Response().StatusCode())\n\trequire.Equal(b, \"/user/fiber\", string(c.Response().Header.Peek(HeaderLocation)))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_Route_WithQueries -benchmem -count=4\nfunc Benchmark_Redirect_Route_WithQueries(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user/:name\", func(c Ctx) error {\n\t\treturn c.JSON(c.Params(\"name\"))\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Redirect().Route(\"user\", RedirectConfig{\n\t\t\tParams: Map{\n\t\t\t\t\"name\": \"fiber\",\n\t\t\t},\n\t\t\tQueries: map[string]string{\"a\": \"a\", \"b\": \"b\"},\n\t\t})\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 302, c.Response().StatusCode())\n\t// analysis of query parameters with url parsing, since a map pass is always randomly ordered\n\tlocation, err := url.Parse(string(c.Response().Header.Peek(HeaderLocation)))\n\trequire.NoError(b, err, \"url.Parse(location)\")\n\trequire.Equal(b, \"/user/fiber\", location.Path)\n\trequire.Equal(b, url.Values{\"a\": []string{\"a\"}, \"b\": []string{\"b\"}}, location.Query())\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_Route_WithFlashMessages -benchmem -count=4\nfunc Benchmark_Redirect_Route_WithFlashMessages(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tvar err error\n\n\tfor n := 0; n < b.N; n++ {\n\t\terr = c.Redirect().With(\"success\", \"1\").With(\"message\", \"test\").Route(\"user\")\n\t}\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 302, c.Response().StatusCode())\n\trequire.Equal(b, \"/user\", string(c.Response().Header.Peek(HeaderLocation)))\n\n\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\tvar msgs redirectionMsgs\n\t_, err = msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\trequire.NoError(b, err)\n\n\trequire.Contains(b, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\trequire.Contains(b, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n}\n\nvar testredirectionMsgs = redirectionMsgs{\n\t{\n\t\tkey:   \"success\",\n\t\tvalue: \"1\",\n\t},\n\t{\n\t\tkey:   \"message\",\n\t\tvalue: \"test\",\n\t},\n\t{\n\t\tkey:        \"name\",\n\t\tvalue:      \"tom\",\n\t\tisOldInput: true,\n\t},\n\t{\n\t\tkey:        \"id\",\n\t\tvalue:      \"1\",\n\t\tisOldInput: true,\n\t},\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_parseAndClearFlashMessages -benchmem -count=4\nfunc Benchmark_Redirect_parseAndClearFlashMessages(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tval, err := testredirectionMsgs.MarshalMsg(nil)\n\trequire.NoError(b, err)\n\n\tc.Request().Header.Set(HeaderCookie, \"fiber_flash=\"+string(val))\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Redirect().parseAndClearFlashMessages()\n\t}\n\n\trequire.Equal(b, FlashMessage{\n\t\tKey:   \"success\",\n\t\tValue: \"1\",\n\t}, c.Redirect().Message(\"success\"))\n\n\trequire.Equal(b, FlashMessage{\n\t\tKey:   \"message\",\n\t\tValue: \"test\",\n\t}, c.Redirect().Message(\"message\"))\n\n\trequire.Equal(b, OldInputData{\n\t\tKey:   \"id\",\n\t\tValue: \"1\",\n\t}, c.Redirect().OldInput(\"id\"))\n\n\trequire.Equal(b, OldInputData{\n\t\tKey:   \"name\",\n\t\tValue: \"tom\",\n\t}, c.Redirect().OldInput(\"name\"))\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_processFlashMessages -benchmem -count=4\nfunc Benchmark_Redirect_processFlashMessages(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tc.Redirect().With(\"success\", \"1\").With(\"message\", \"test\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Redirect().processFlashMessages()\n\t}\n\n\tc.RequestCtx().Request.Header.Set(HeaderCookie, c.GetRespHeader(HeaderSetCookie)) // necessary for testing\n\n\tvar msgs redirectionMsgs\n\t_, err := msgs.UnmarshalMsg([]byte(c.Cookies(FlashCookieName)))\n\trequire.NoError(b, err)\n\n\trequire.Len(b, msgs, 2)\n\trequire.Contains(b, msgs, redirectionMsg{key: \"success\", value: \"1\", level: 0, isOldInput: false})\n\trequire.Contains(b, msgs, redirectionMsg{key: \"message\", value: \"test\", level: 0, isOldInput: false})\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_Messages -benchmem -count=4\nfunc Benchmark_Redirect_Messages(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tval, err := testredirectionMsgs.MarshalMsg(nil)\n\trequire.NoError(b, err)\n\n\tc.Request().Header.Set(HeaderCookie, \"fiber_flash=\"+string(val))\n\tc.Redirect().parseAndClearFlashMessages()\n\n\tvar msgs []FlashMessage\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tmsgs = c.Redirect().Messages()\n\t}\n\n\trequire.Contains(b, msgs, FlashMessage{\n\t\tKey:   \"success\",\n\t\tValue: \"1\",\n\t\tLevel: 0,\n\t})\n\n\trequire.Contains(b, msgs, FlashMessage{\n\t\tKey:   \"message\",\n\t\tValue: \"test\",\n\t\tLevel: 0,\n\t})\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_OldInputs -benchmem -count=4\nfunc Benchmark_Redirect_OldInputs(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tval, err := testredirectionMsgs.MarshalMsg(nil)\n\trequire.NoError(b, err)\n\n\tc.Request().Header.Set(HeaderCookie, \"fiber_flash=\"+string(val))\n\tc.Redirect().parseAndClearFlashMessages()\n\n\tvar oldInputs []OldInputData\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\toldInputs = c.Redirect().OldInputs()\n\t}\n\n\trequire.Contains(b, oldInputs, OldInputData{\n\t\tKey:   \"name\",\n\t\tValue: \"tom\",\n\t})\n\n\trequire.Contains(b, oldInputs, OldInputData{\n\t\tKey:   \"id\",\n\t\tValue: \"1\",\n\t})\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_Message -benchmem -count=4\nfunc Benchmark_Redirect_Message(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tval, err := testredirectionMsgs.MarshalMsg(nil)\n\trequire.NoError(b, err)\n\n\tc.Request().Header.Set(HeaderCookie, \"fiber_flash=\"+string(val))\n\tc.Redirect().parseAndClearFlashMessages()\n\n\tvar msg FlashMessage\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tmsg = c.Redirect().Message(\"message\")\n\t}\n\n\trequire.Equal(b, FlashMessage{\n\t\tKey:   \"message\",\n\t\tValue: \"test\",\n\t\tLevel: 0,\n\t}, msg)\n}\n\n// go test -v -run=^$ -bench=Benchmark_Redirect_OldInput -benchmem -count=4\nfunc Benchmark_Redirect_OldInput(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/user\", func(c Ctx) error {\n\t\treturn c.SendString(\"user\")\n\t}).Name(\"user\")\n\n\tc := app.AcquireCtx(&fasthttp.RequestCtx{}).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tval, err := testredirectionMsgs.MarshalMsg(nil)\n\trequire.NoError(b, err)\n\n\tc.Request().Header.Set(HeaderCookie, \"fiber_flash=\"+string(val))\n\tc.Redirect().parseAndClearFlashMessages()\n\n\tvar input OldInputData\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tinput = c.Redirect().OldInput(\"name\")\n\t}\n\n\trequire.Equal(b, OldInputData{\n\t\tKey:   \"name\",\n\t\tValue: \"tom\",\n\t}, input)\n}\n"
        },
        {
          "name": "register.go",
          "type": "blob",
          "size": 4.56,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\n// Register defines all router handle interface generate by Route().\ntype Register interface {\n\tAll(handler Handler, middleware ...Handler) Register\n\tGet(handler Handler, middleware ...Handler) Register\n\tHead(handler Handler, middleware ...Handler) Register\n\tPost(handler Handler, middleware ...Handler) Register\n\tPut(handler Handler, middleware ...Handler) Register\n\tDelete(handler Handler, middleware ...Handler) Register\n\tConnect(handler Handler, middleware ...Handler) Register\n\tOptions(handler Handler, middleware ...Handler) Register\n\tTrace(handler Handler, middleware ...Handler) Register\n\tPatch(handler Handler, middleware ...Handler) Register\n\n\tAdd(methods []string, handler Handler, middleware ...Handler) Register\n\n\tRoute(path string) Register\n}\n\nvar _ (Register) = (*Registering)(nil)\n\n// Registering struct\ntype Registering struct {\n\tapp *App\n\n\tpath string\n}\n\n// All registers a middleware route that will match requests\n// with the provided path which is stored in register struct.\n//\n//\tapp.Route(\"/\").All(func(c fiber.Ctx) error {\n//\t     return c.Next()\n//\t})\n//\tapp.Route(\"/api\").All(func(c fiber.Ctx) error {\n//\t     return c.Next()\n//\t})\n//\tapp.Route(\"/api\").All(handler, func(c fiber.Ctx) error {\n//\t     return c.Next()\n//\t})\n//\n// This method will match all HTTP verbs: GET, POST, PUT, HEAD etc...\nfunc (r *Registering) All(handler Handler, middleware ...Handler) Register {\n\tr.app.register([]string{methodUse}, r.path, nil, handler, middleware...)\n\treturn r\n}\n\n// Get registers a route for GET methods that requests a representation\n// of the specified resource. Requests using GET should only retrieve data.\nfunc (r *Registering) Get(handler Handler, middleware ...Handler) Register {\n\tr.app.Add([]string{MethodGet}, r.path, handler, middleware...)\n\treturn r\n}\n\n// Head registers a route for HEAD methods that asks for a response identical\n// to that of a GET request, but without the response body.\nfunc (r *Registering) Head(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodHead}, handler, middleware...)\n}\n\n// Post registers a route for POST methods that is used to submit an entity to the\n// specified resource, often causing a change in state or side effects on the server.\nfunc (r *Registering) Post(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodPost}, handler, middleware...)\n}\n\n// Put registers a route for PUT methods that replaces all current representations\n// of the target resource with the request payload.\nfunc (r *Registering) Put(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodPut}, handler, middleware...)\n}\n\n// Delete registers a route for DELETE methods that deletes the specified resource.\nfunc (r *Registering) Delete(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodDelete}, handler, middleware...)\n}\n\n// Connect registers a route for CONNECT methods that establishes a tunnel to the\n// server identified by the target resource.\nfunc (r *Registering) Connect(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodConnect}, handler, middleware...)\n}\n\n// Options registers a route for OPTIONS methods that is used to describe the\n// communication options for the target resource.\nfunc (r *Registering) Options(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodOptions}, handler, middleware...)\n}\n\n// Trace registers a route for TRACE methods that performs a message loop-back\n// test along the r.Path to the target resource.\nfunc (r *Registering) Trace(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodTrace}, handler, middleware...)\n}\n\n// Patch registers a route for PATCH methods that is used to apply partial\n// modifications to a resource.\nfunc (r *Registering) Patch(handler Handler, middleware ...Handler) Register {\n\treturn r.Add([]string{MethodPatch}, handler, middleware...)\n}\n\n// Add allows you to specify multiple HTTP methods to register a route.\nfunc (r *Registering) Add(methods []string, handler Handler, middleware ...Handler) Register {\n\tr.app.register(methods, r.path, nil, handler, middleware...)\n\treturn r\n}\n\n// Route returns a new Register instance whose route path takes\n// the path in the current instance as its prefix.\nfunc (r *Registering) Route(path string) Register {\n\t// Create new group\n\troute := &Registering{app: r.app, path: getGroupPath(r.path, path)}\n\n\treturn route\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 13.51,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 🤖 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html\"\n\t\"sort\"\n\t\"sync/atomic\"\n\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// Router defines all router handle interface, including app and group router.\ntype Router interface {\n\tUse(args ...any) Router\n\n\tGet(path string, handler Handler, middleware ...Handler) Router\n\tHead(path string, handler Handler, middleware ...Handler) Router\n\tPost(path string, handler Handler, middleware ...Handler) Router\n\tPut(path string, handler Handler, middleware ...Handler) Router\n\tDelete(path string, handler Handler, middleware ...Handler) Router\n\tConnect(path string, handler Handler, middleware ...Handler) Router\n\tOptions(path string, handler Handler, middleware ...Handler) Router\n\tTrace(path string, handler Handler, middleware ...Handler) Router\n\tPatch(path string, handler Handler, middleware ...Handler) Router\n\n\tAdd(methods []string, path string, handler Handler, middleware ...Handler) Router\n\tAll(path string, handler Handler, middleware ...Handler) Router\n\n\tGroup(prefix string, handlers ...Handler) Router\n\n\tRoute(path string) Register\n\n\tName(name string) Router\n}\n\n// Route is a struct that holds all metadata for each registered handler.\ntype Route struct {\n\t// ### important: always keep in sync with the copy method \"app.copyRoute\" ###\n\tgroup *Group // Group instance. used for routes in groups\n\n\tpath string // Prettified path\n\n\t// Public fields\n\tMethod string `json:\"method\"` // HTTP method\n\tName   string `json:\"name\"`   // Route's name\n\t//nolint:revive // Having both a Path (uppercase) and a path (lowercase) is fine\n\tPath        string      `json:\"path\"`   // Original registered route path\n\tParams      []string    `json:\"params\"` // Case-sensitive param keys\n\tHandlers    []Handler   `json:\"-\"`      // Ctx handlers\n\trouteParser routeParser // Parameter parser\n\t// Data for routing\n\tpos   uint32 // Position in stack -> important for the sort of the matched routes\n\tuse   bool   // USE matches path prefixes\n\tmount bool   // Indicated a mounted app on a specific route\n\tstar  bool   // Path equals '*'\n\troot  bool   // Path equals '/'\n}\n\nfunc (r *Route) match(detectionPath, path string, params *[maxParams]string) bool {\n\t// root detectionPath check\n\tif r.root && len(detectionPath) == 1 && detectionPath[0] == '/' {\n\t\treturn true\n\t}\n\n\t// '*' wildcard matches any detectionPath\n\tif r.star {\n\t\tif len(path) > 1 {\n\t\t\tparams[0] = path[1:]\n\t\t} else {\n\t\t\tparams[0] = \"\"\n\t\t}\n\t\treturn true\n\t}\n\n\t// Does this route have parameters?\n\tif len(r.Params) > 0 {\n\t\t// Match params using precomputed routeParser\n\t\tif r.routeParser.getMatch(detectionPath, path, params, r.use) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// Middleware route?\n\tif r.use {\n\t\t// Single slash or prefix match\n\t\tplen := len(r.path)\n\t\tif r.root {\n\t\t\t// If r.root is '/', it matches everything starting at '/'\n\t\t\tif len(detectionPath) > 0 && detectionPath[0] == '/' {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else if len(detectionPath) >= plen && detectionPath[:plen] == r.path {\n\t\t\treturn true\n\t\t}\n\t} else if len(r.path) == len(detectionPath) && detectionPath == r.path {\n\t\t// Check exact match\n\t\treturn true\n\t}\n\n\t// No match\n\treturn false\n}\n\nfunc (app *App) nextCustom(c CustomCtx) (bool, error) { //nolint: unparam // bool param might be useful for testing\n\t// Get stack length\n\ttree, ok := app.treeStack[c.getMethodINT()][c.getTreePath()]\n\tif !ok {\n\t\ttree = app.treeStack[c.getMethodINT()][\"\"]\n\t}\n\tlenr := len(tree) - 1\n\n\t// Loop over the route stack starting from previous index\n\tfor c.getIndexRoute() < lenr {\n\t\t// Increment route index\n\t\tc.setIndexRoute(c.getIndexRoute() + 1)\n\n\t\t// Get *Route\n\t\troute := tree[c.getIndexRoute()]\n\n\t\t// Check if it matches the request path\n\t\tmatch := route.match(c.getDetectionPath(), c.Path(), c.getValues())\n\n\t\t// No match, next route\n\t\tif !match {\n\t\t\tcontinue\n\t\t}\n\t\t// Pass route reference and param values\n\t\tc.setRoute(route)\n\n\t\t// Non use handler matched\n\t\tif !c.getMatched() && !route.use {\n\t\t\tc.setMatched(true)\n\t\t}\n\n\t\t// Execute first handler of route\n\t\tc.setIndexHandler(0)\n\t\terr := route.Handlers[0](c)\n\t\treturn match, err // Stop scanning the stack\n\t}\n\n\t// If c.Next() does not match, return 404\n\terr := NewError(StatusNotFound, \"Cannot \"+c.Method()+\" \"+c.getPathOriginal())\n\n\t// If no match, scan stack again if other methods match the request\n\t// Moved from app.handler because middleware may break the route chain\n\tif !c.getMatched() && app.methodExistCustom(c) {\n\t\terr = ErrMethodNotAllowed\n\t}\n\treturn false, err\n}\n\nfunc (app *App) next(c *DefaultCtx) (bool, error) {\n\t// Get stack length\n\ttree, ok := app.treeStack[c.methodINT][c.treePath]\n\tif !ok {\n\t\ttree = app.treeStack[c.methodINT][\"\"]\n\t}\n\tlenTree := len(tree) - 1\n\n\t// Loop over the route stack starting from previous index\n\tfor c.indexRoute < lenTree {\n\t\t// Increment route index\n\t\tc.indexRoute++\n\n\t\t// Get *Route\n\t\troute := tree[c.indexRoute]\n\n\t\tvar match bool\n\t\tvar err error\n\t\t// skip for mounted apps\n\t\tif route.mount {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if it matches the request path\n\t\tmatch = route.match(c.detectionPath, c.path, &c.values)\n\t\tif !match {\n\t\t\t// No match, next route\n\t\t\tcontinue\n\t\t}\n\t\t// Pass route reference and param values\n\t\tc.route = route\n\n\t\t// Non use handler matched\n\t\tif !c.matched && !route.use {\n\t\t\tc.matched = true\n\t\t}\n\n\t\t// Execute first handler of route\n\t\tc.indexHandler = 0\n\t\tif len(route.Handlers) > 0 {\n\t\t\terr = route.Handlers[0](c)\n\t\t}\n\t\treturn match, err // Stop scanning the stack\n\t}\n\n\t// If c.Next() does not match, return 404\n\terr := NewError(StatusNotFound, \"Cannot \"+c.method+\" \"+html.EscapeString(c.pathOriginal))\n\tif !c.matched && app.methodExist(c) {\n\t\t// If no match, scan stack again if other methods match the request\n\t\t// Moved from app.handler because middleware may break the route chain\n\t\terr = ErrMethodNotAllowed\n\t}\n\treturn false, err\n}\n\nfunc (app *App) defaultRequestHandler(rctx *fasthttp.RequestCtx) {\n\t// Acquire DefaultCtx from the pool\n\tctx, ok := app.AcquireCtx(rctx).(*DefaultCtx)\n\tif !ok {\n\t\tpanic(errors.New(\"requestHandler: failed to type-assert to *DefaultCtx\"))\n\t}\n\n\tdefer app.ReleaseCtx(ctx)\n\n\t// Check if the HTTP method is valid\n\tif ctx.methodINT == -1 {\n\t\t_ = ctx.SendStatus(StatusNotImplemented) //nolint:errcheck // Always return nil\n\t\treturn\n\t}\n\n\t// Optional: Check flash messages\n\trawHeaders := ctx.Request().Header.RawHeaders()\n\tif len(rawHeaders) > 0 && bytes.Contains(rawHeaders, []byte(FlashCookieName)) {\n\t\tctx.Redirect().parseAndClearFlashMessages()\n\t}\n\n\t// Attempt to match a route and execute the chain\n\t_, err := app.next(ctx)\n\tif err != nil {\n\t\tif catch := ctx.App().ErrorHandler(ctx, err); catch != nil {\n\t\t\t_ = ctx.SendStatus(StatusInternalServerError) //nolint:errcheck // Always return nil\n\t\t}\n\t\t// TODO: Do we need to return here?\n\t}\n}\n\nfunc (app *App) customRequestHandler(rctx *fasthttp.RequestCtx) {\n\t// Acquire CustomCtx from the pool\n\tctx, ok := app.AcquireCtx(rctx).(CustomCtx)\n\tif !ok {\n\t\tpanic(errors.New(\"requestHandler: failed to type-assert to CustomCtx\"))\n\t}\n\n\tdefer app.ReleaseCtx(ctx)\n\n\t// Check if the HTTP method is valid\n\tif app.methodInt(ctx.Method()) == -1 {\n\t\t_ = ctx.SendStatus(StatusNotImplemented) //nolint:errcheck // Always return nil\n\t\treturn\n\t}\n\n\t// Optional: Check flash messages\n\trawHeaders := ctx.Request().Header.RawHeaders()\n\tif len(rawHeaders) > 0 && bytes.Contains(rawHeaders, []byte(FlashCookieName)) {\n\t\tctx.Redirect().parseAndClearFlashMessages()\n\t}\n\n\t// Attempt to match a route and execute the chain\n\t_, err := app.nextCustom(ctx)\n\tif err != nil {\n\t\tif catch := ctx.App().ErrorHandler(ctx, err); catch != nil {\n\t\t\t_ = ctx.SendStatus(StatusInternalServerError) //nolint:errcheck // Always return nil\n\t\t}\n\t\t// TODO: Do we need to return here?\n\t}\n}\n\nfunc (app *App) addPrefixToRoute(prefix string, route *Route) *Route {\n\tprefixedPath := getGroupPath(prefix, route.Path)\n\tprettyPath := prefixedPath\n\t// Case-sensitive routing, all to lowercase\n\tif !app.config.CaseSensitive {\n\t\tprettyPath = utils.ToLower(prettyPath)\n\t}\n\t// Strict routing, remove trailing slashes\n\tif !app.config.StrictRouting && len(prettyPath) > 1 {\n\t\tprettyPath = utils.TrimRight(prettyPath, '/')\n\t}\n\n\troute.Path = prefixedPath\n\troute.path = RemoveEscapeChar(prettyPath)\n\troute.routeParser = parseRoute(prettyPath, app.customConstraints...)\n\troute.root = false\n\troute.star = false\n\n\treturn route\n}\n\nfunc (*App) copyRoute(route *Route) *Route {\n\treturn &Route{\n\t\t// Router booleans\n\t\tuse:   route.use,\n\t\tmount: route.mount,\n\t\tstar:  route.star,\n\t\troot:  route.root,\n\n\t\t// Path data\n\t\tpath:        route.path,\n\t\trouteParser: route.routeParser,\n\n\t\t// misc\n\t\tpos: route.pos,\n\n\t\t// Public data\n\t\tPath:     route.Path,\n\t\tParams:   route.Params,\n\t\tName:     route.Name,\n\t\tMethod:   route.Method,\n\t\tHandlers: route.Handlers,\n\t}\n}\n\nfunc (app *App) register(methods []string, pathRaw string, group *Group, handler Handler, middleware ...Handler) {\n\thandlers := middleware\n\tif handler != nil {\n\t\thandlers = append(handlers, handler)\n\t}\n\n\t// Precompute path normalization ONCE\n\tif pathRaw == \"\" {\n\t\tpathRaw = \"/\"\n\t}\n\tif pathRaw[0] != '/' {\n\t\tpathRaw = \"/\" + pathRaw\n\t}\n\tpathPretty := pathRaw\n\tif !app.config.CaseSensitive {\n\t\tpathPretty = utils.ToLower(pathPretty)\n\t}\n\tif !app.config.StrictRouting && len(pathPretty) > 1 {\n\t\tpathPretty = utils.TrimRight(pathPretty, '/')\n\t}\n\tpathClean := RemoveEscapeChar(pathPretty)\n\n\tparsedRaw := parseRoute(pathRaw, app.customConstraints...)\n\tparsedPretty := parseRoute(pathPretty, app.customConstraints...)\n\n\tfor _, method := range methods {\n\t\tmethod = utils.ToUpper(method)\n\t\tif method != methodUse && app.methodInt(method) == -1 {\n\t\t\tpanic(fmt.Sprintf(\"add: invalid http method %s\\n\", method))\n\t\t}\n\n\t\tisMount := group != nil && group.app != app\n\t\tif len(handlers) == 0 && !isMount {\n\t\t\tpanic(fmt.Sprintf(\"missing handler/middleware in route: %s\\n\", pathRaw))\n\t\t}\n\n\t\tisUse := method == methodUse\n\t\tisStar := pathClean == \"/*\"\n\t\tisRoot := pathClean == \"/\"\n\n\t\troute := Route{\n\t\t\tuse:   isUse,\n\t\t\tmount: isMount,\n\t\t\tstar:  isStar,\n\t\t\troot:  isRoot,\n\n\t\t\tpath:        pathClean,\n\t\t\trouteParser: parsedPretty,\n\t\t\tParams:      parsedRaw.params,\n\t\t\tgroup:       group,\n\n\t\t\tPath:     pathRaw,\n\t\t\tMethod:   method,\n\t\t\tHandlers: handlers,\n\t\t}\n\n\t\t// Increment global handler count\n\t\tatomic.AddUint32(&app.handlersCount, uint32(len(handlers))) //nolint:gosec // Not a concern\n\n\t\t// Middleware route matches all HTTP methods\n\t\tif isUse {\n\t\t\t// Add route to all HTTP methods stack\n\t\t\tfor _, m := range app.config.RequestMethods {\n\t\t\t\t// Create a route copy to avoid duplicates during compression\n\t\t\t\tr := route\n\t\t\t\tapp.addRoute(m, &r, isMount)\n\t\t\t}\n\t\t} else {\n\t\t\t// Add route to stack\n\t\t\tapp.addRoute(method, &route, isMount)\n\t\t}\n\t}\n}\n\nfunc (app *App) addRoute(method string, route *Route, isMounted ...bool) {\n\tapp.mutex.Lock()\n\tdefer app.mutex.Unlock()\n\n\t// Check mounted routes\n\tvar mounted bool\n\tif len(isMounted) > 0 {\n\t\tmounted = isMounted[0]\n\t}\n\n\t// Get unique HTTP method identifier\n\tm := app.methodInt(method)\n\n\t// prevent identically route registration\n\tl := len(app.stack[m])\n\tif l > 0 && app.stack[m][l-1].Path == route.Path && route.use == app.stack[m][l-1].use && !route.mount && !app.stack[m][l-1].mount {\n\t\tpreRoute := app.stack[m][l-1]\n\t\tpreRoute.Handlers = append(preRoute.Handlers, route.Handlers...)\n\t} else {\n\t\t// Increment global route position\n\t\troute.pos = atomic.AddUint32(&app.routesCount, 1)\n\t\troute.Method = method\n\t\t// Add route to the stack\n\t\tapp.stack[m] = append(app.stack[m], route)\n\t\tapp.routesRefreshed = true\n\t}\n\n\t// Execute onRoute hooks & change latestRoute if not adding mounted route\n\tif !mounted {\n\t\tapp.latestRoute = route\n\t\tif err := app.hooks.executeOnRouteHooks(*route); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\n// BuildTree rebuilds the prefix tree from the previously registered routes.\n// This method is useful when you want to register routes dynamically after the app has started.\n// It is not recommended to use this method on production environments because rebuilding\n// the tree is performance-intensive and not thread-safe in runtime. Since building the tree\n// is only done in the startupProcess of the app, this method does not makes sure that the\n// routeTree is being safely changed, as it would add a great deal of overhead in the request.\n// Latest benchmark results showed a degradation from 82.79 ns/op to 94.48 ns/op and can be found in:\n// https://github.com/gofiber/fiber/issues/2769#issuecomment-2227385283\nfunc (app *App) RebuildTree() *App {\n\tapp.mutex.Lock()\n\tdefer app.mutex.Unlock()\n\n\treturn app.buildTree()\n}\n\n// buildTree build the prefix tree from the previously registered routes\nfunc (app *App) buildTree() *App {\n\tif !app.routesRefreshed {\n\t\treturn app\n\t}\n\n\t// loop all the methods and stacks and create the prefix tree\n\tfor m := range app.config.RequestMethods {\n\t\ttsMap := make(map[string][]*Route)\n\t\tfor _, route := range app.stack[m] {\n\t\t\ttreePath := \"\"\n\t\t\tif len(route.routeParser.segs) > 0 && len(route.routeParser.segs[0].Const) >= 3 {\n\t\t\t\ttreePath = route.routeParser.segs[0].Const[:3]\n\t\t\t}\n\t\t\t// create tree stack\n\t\t\ttsMap[treePath] = append(tsMap[treePath], route)\n\t\t}\n\t\tapp.treeStack[m] = tsMap\n\t}\n\n\t// loop the methods and tree stacks and add global stack and sort everything\n\tfor m := range app.config.RequestMethods {\n\t\ttsMap := app.treeStack[m]\n\t\tfor treePart := range tsMap {\n\t\t\tif treePart != \"\" {\n\t\t\t\t// merge global tree routes in current tree stack\n\t\t\t\ttsMap[treePart] = uniqueRouteStack(append(tsMap[treePart], tsMap[\"\"]...))\n\t\t\t}\n\t\t\t// sort tree slices with the positions\n\t\t\tslc := tsMap[treePart]\n\t\t\tsort.Slice(slc, func(i, j int) bool { return slc[i].pos < slc[j].pos })\n\t\t}\n\t}\n\tapp.routesRefreshed = false\n\n\treturn app\n}\n"
        },
        {
          "name": "router_test.go",
          "type": "blob",
          "size": 19.69,
          "content": "// ⚡️ Fiber is an Express inspired web framework written in Go with ☕️\n// 📃 Github Repository: https://github.com/gofiber/fiber\n// 📌 API Documentation: https://docs.gofiber.io\n\npackage fiber\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/gofiber/utils/v2\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nvar routesFixture routeJSON\n\nfunc init() {\n\tdat, err := os.ReadFile(\"./.github/testdata/testRoutes.json\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif err := json.Unmarshal(dat, &routesFixture); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Test_Route_Match_SameLength(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Get(\"/:param\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"param\"))\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/:param\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \":param\", app.getString(body))\n\n\t// with param\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"test\", app.getString(body))\n}\n\nfunc Test_Route_Match_Star(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Get(\"/*\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"*\"))\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/*\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"*\", app.getString(body))\n\n\t// with param\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"test\", app.getString(body))\n\n\t// without parameter\n\troute := Route{\n\t\tstar:        true,\n\t\tpath:        \"/*\",\n\t\trouteParser: routeParser{},\n\t}\n\tparams := [maxParams]string{}\n\tmatch := route.match(\"\", \"\", &params)\n\trequire.True(t, match)\n\trequire.Equal(t, [maxParams]string{}, params)\n\n\t// with parameter\n\tmatch = route.match(\"/favicon.ico\", \"/favicon.ico\", &params)\n\trequire.True(t, match)\n\trequire.Equal(t, [maxParams]string{\"favicon.ico\"}, params)\n\n\t// without parameter again\n\tmatch = route.match(\"\", \"\", &params)\n\trequire.True(t, match)\n\trequire.Equal(t, [maxParams]string{}, params)\n}\n\nfunc Test_Route_Match_Root(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Get(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(\"root\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"root\", app.getString(body))\n}\n\nfunc Test_Route_Match_Parser(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Get(\"/foo/:ParamName\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"ParamName\"))\n\t})\n\tapp.Get(\"/Foobar/*\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"*\"))\n\t})\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/foo/bar\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"bar\", app.getString(body))\n\n\t// with star\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/Foobar/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"test\", app.getString(body))\n}\n\nfunc Test_Route_Match_Middleware(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Use(\"/foo/*\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"*\"))\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/foo/*\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"*\", app.getString(body))\n\n\t// with param\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/foo/bar/fasel\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"bar/fasel\", app.getString(body))\n}\n\nfunc Test_Route_Match_UnescapedPath(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New(Config{UnescapePath: true})\n\n\tapp.Use(\"/créer\", func(c Ctx) error {\n\t\treturn c.SendString(\"test\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/cr%C3%A9er\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"test\", app.getString(body))\n\t// without special chars\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/créer\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\t// check deactivated behavior\n\tapp.config.UnescapePath = false\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/cr%C3%A9er\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusNotFound, resp.StatusCode, \"Status code\")\n}\n\nfunc Test_Route_Match_WithEscapeChar(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\t// static route and escaped part\n\tapp.Get(\"/v1/some/resource/name\\\\:customVerb\", func(c Ctx) error {\n\t\treturn c.SendString(\"static\")\n\t})\n\t// group route\n\tgroup := app.Group(\"/v2/\\\\:firstVerb\")\n\tgroup.Get(\"/\\\\:customVerb\", func(c Ctx) error {\n\t\treturn c.SendString(\"group\")\n\t})\n\t// route with resource param and escaped part\n\tapp.Get(\"/v3/:resource/name\\\\:customVerb\", func(c Ctx) error {\n\t\treturn c.SendString(c.Params(\"resource\"))\n\t})\n\n\t// check static route\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/v1/some/resource/name:customVerb\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"static\", app.getString(body))\n\n\t// check group route\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/v2/:firstVerb/:customVerb\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"group\", app.getString(body))\n\n\t// check param route\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/v3/awesome/name:customVerb\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, StatusOK, resp.StatusCode, \"Status code\")\n\n\tbody, err = io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"awesome\", app.getString(body))\n}\n\nfunc Test_Route_Match_Middleware_HasPrefix(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Use(\"/foo\", func(c Ctx) error {\n\t\treturn c.SendString(\"middleware\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/foo/bar\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"middleware\", app.getString(body))\n}\n\nfunc Test_Route_Match_Middleware_Root(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\n\tapp.Use(\"/\", func(c Ctx) error {\n\t\treturn c.SendString(\"middleware\")\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/everything\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, 200, resp.StatusCode, \"Status code\")\n\n\tbody, err := io.ReadAll(resp.Body)\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, \"middleware\", app.getString(body))\n}\n\nfunc Test_Router_Register_Missing_Handler(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trequire.Equal(t, \"missing handler/middleware in route: /doe\\n\", fmt.Sprintf(\"%v\", err))\n\t\t}\n\t}()\n\tapp.register([]string{\"USE\"}, \"/doe\", nil, nil)\n}\n\nfunc Test_Ensure_Router_Interface_Implementation(t *testing.T) {\n\tt.Parallel()\n\n\tvar app any = (*App)(nil)\n\t_, ok := app.(Router)\n\trequire.True(t, ok)\n\n\tvar group any = (*Group)(nil)\n\t_, ok = group.(Router)\n\trequire.True(t, ok)\n}\n\nfunc Test_Router_Handler_Catch_Error(t *testing.T) {\n\tt.Parallel()\n\n\tapp := New()\n\tapp.config.ErrorHandler = func(_ Ctx, _ error) error {\n\t\treturn errors.New(\"fake error\")\n\t}\n\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn ErrForbidden\n\t})\n\n\tc := &fasthttp.RequestCtx{}\n\n\tapp.Handler()(c)\n\n\trequire.Equal(t, StatusInternalServerError, c.Response.Header.StatusCode())\n}\n\nfunc Test_Router_NotFound(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\tappHandler := app.Handler()\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/this/route/does/not/exist\")\n\n\tappHandler(c)\n\n\trequire.Equal(t, 404, c.Response.StatusCode())\n\trequire.Equal(t, \"Cannot DELETE /this/route/does/not/exist\", string(c.Response.Body()))\n}\n\nfunc Test_Router_NotFound_HTML_Inject(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\tappHandler := app.Handler()\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/does/not/exist<script>alert('foo');</script>\")\n\n\tappHandler(c)\n\n\trequire.Equal(t, 404, c.Response.StatusCode())\n\trequire.Equal(t, \"Cannot DELETE /does/not/exist&lt;script&gt;alert(&#39;foo&#39;);&lt;/script&gt;\", string(c.Response.Body()))\n}\n\nfunc Test_App_Rebuild_Tree(t *testing.T) {\n\tt.Parallel()\n\tapp := New()\n\n\tapp.Get(\"/test\", func(c Ctx) error {\n\t\tapp.Get(\"/dynamically-defined\", func(c Ctx) error {\n\t\t\treturn c.SendStatus(http.StatusOK)\n\t\t})\n\n\t\tapp.RebuildTree()\n\n\t\treturn c.SendStatus(http.StatusOK)\n\t})\n\n\tresp, err := app.Test(httptest.NewRequest(MethodGet, \"/dynamically-defined\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/test\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, http.StatusOK, resp.StatusCode, \"Status code\")\n\n\tresp, err = app.Test(httptest.NewRequest(MethodGet, \"/dynamically-defined\", nil))\n\trequire.NoError(t, err, \"app.Test(req)\")\n\trequire.Equal(t, http.StatusOK, resp.StatusCode, \"Status code\")\n}\n\n//////////////////////////////////////////////\n///////////////// BENCHMARKS /////////////////\n//////////////////////////////////////////////\n\nfunc registerDummyRoutes(app *App) {\n\th := func(_ Ctx) error {\n\t\treturn nil\n\t}\n\tfor _, r := range routesFixture.GithubAPI {\n\t\tapp.Add([]string{r.Method}, r.Path, h)\n\t}\n}\n\n// go test -v -run=^$ -bench=Benchmark_App_MethodNotAllowed -benchmem -count=4\nfunc Benchmark_App_MethodNotAllowed(b *testing.B) {\n\tapp := New()\n\th := func(c Ctx) error {\n\t\treturn c.SendString(\"Hello World!\")\n\t}\n\tapp.All(\"/this/is/a/\", h)\n\tapp.Get(\"/this/is/a/dummy/route/oke\", h)\n\tappHandler := app.Handler()\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/this/is/a/dummy/route/oke\")\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n\tb.StopTimer()\n\trequire.Equal(b, 405, c.Response.StatusCode())\n\trequire.Equal(b, MethodGet, string(c.Response.Header.Peek(\"Allow\")))\n\trequire.Equal(b, utils.StatusMessage(StatusMethodNotAllowed), string(c.Response.Body()))\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_NotFound -benchmem -count=4\nfunc Benchmark_Router_NotFound(b *testing.B) {\n\tapp := New()\n\tapp.Use(func(c Ctx) error {\n\t\treturn c.Next()\n\t})\n\tregisterDummyRoutes(app)\n\tappHandler := app.Handler()\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/this/route/does/not/exist\")\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n\trequire.Equal(b, 404, c.Response.StatusCode())\n\trequire.Equal(b, \"Cannot DELETE /this/route/does/not/exist\", string(c.Response.Body()))\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_Handler -benchmem -count=4\nfunc Benchmark_Router_Handler(b *testing.B) {\n\tapp := New()\n\tregisterDummyRoutes(app)\n\tappHandler := app.Handler()\n\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/user/keys/1337\")\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n}\n\nfunc Benchmark_Router_Handler_Strict_Case(b *testing.B) {\n\tapp := New(Config{\n\t\tStrictRouting: true,\n\t\tCaseSensitive: true,\n\t})\n\tregisterDummyRoutes(app)\n\tappHandler := app.Handler()\n\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/user/keys/1337\")\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_Chain -benchmem -count=4\nfunc Benchmark_Router_Chain(b *testing.B) {\n\tapp := New()\n\thandler := func(c Ctx) error {\n\t\treturn c.Next()\n\t}\n\tapp.Get(\"/\", handler, handler, handler, handler, handler, handler)\n\n\tappHandler := app.Handler()\n\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(MethodGet)\n\tc.URI().SetPath(\"/\")\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_WithCompression -benchmem -count=4\nfunc Benchmark_Router_WithCompression(b *testing.B) {\n\tapp := New()\n\thandler := func(c Ctx) error {\n\t\treturn c.Next()\n\t}\n\tapp.Get(\"/\", handler)\n\tapp.Get(\"/\", handler)\n\tapp.Get(\"/\", handler)\n\tapp.Get(\"/\", handler)\n\tapp.Get(\"/\", handler)\n\tapp.Get(\"/\", handler)\n\n\tappHandler := app.Handler()\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(MethodGet)\n\tc.URI().SetPath(\"/\")\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n}\n\n// go test -run=^$ -bench=Benchmark_Startup_Process -benchmem -count=9\nfunc Benchmark_Startup_Process(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tapp := New()\n\t\tregisterDummyRoutes(app)\n\t\tapp.startupProcess()\n\t}\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_Next -benchmem -count=4\nfunc Benchmark_Router_Next(b *testing.B) {\n\tapp := New()\n\tregisterDummyRoutes(app)\n\tapp.startupProcess()\n\n\trequest := &fasthttp.RequestCtx{}\n\n\trequest.Request.Header.SetMethod(\"DELETE\")\n\trequest.URI().SetPath(\"/user/keys/1337\")\n\tvar res bool\n\tvar err error\n\n\tc := app.AcquireCtx(request).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tc.indexRoute = -1\n\t\tres, err = app.next(c)\n\t}\n\trequire.NoError(b, err)\n\trequire.True(b, res)\n\trequire.Equal(b, 4, c.indexRoute)\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_Next_Default -benchmem -count=4\nfunc Benchmark_Router_Next_Default(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn nil\n\t})\n\n\th := app.Handler()\n\n\tfctx := &fasthttp.RequestCtx{}\n\tfctx.Request.Header.SetMethod(MethodGet)\n\tfctx.Request.SetRequestURI(\"/\")\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\th(fctx)\n\t}\n}\n\n// go test -benchmem -run=^$ -bench ^Benchmark_Router_Next_Default_Parallel$ github.com/gofiber/fiber/v3 -count=1\nfunc Benchmark_Router_Next_Default_Parallel(b *testing.B) {\n\tapp := New()\n\tapp.Get(\"/\", func(_ Ctx) error {\n\t\treturn nil\n\t})\n\n\th := app.Handler()\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfctx := &fasthttp.RequestCtx{}\n\t\tfctx.Request.Header.SetMethod(MethodGet)\n\t\tfctx.Request.SetRequestURI(\"/\")\n\n\t\tfor pb.Next() {\n\t\t\th(fctx)\n\t\t}\n\t})\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Route_Match -benchmem -count=4\nfunc Benchmark_Route_Match(b *testing.B) {\n\tvar match bool\n\tvar params [maxParams]string\n\n\tparsed := parseRoute(\"/user/keys/:id\")\n\troute := &Route{\n\t\tuse:         false,\n\t\troot:        false,\n\t\tstar:        false,\n\t\trouteParser: parsed,\n\t\tParams:      parsed.params,\n\t\tpath:        \"/user/keys/:id\",\n\n\t\tPath:   \"/user/keys/:id\",\n\t\tMethod: \"DELETE\",\n\t}\n\troute.Handlers = append(route.Handlers, func(_ Ctx) error {\n\t\treturn nil\n\t})\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tmatch = route.match(\"/user/keys/1337\", \"/user/keys/1337\", &params)\n\t}\n\n\trequire.True(b, match)\n\trequire.Equal(b, []string{\"1337\"}, params[0:len(parsed.params)])\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Route_Match_Star -benchmem -count=4\nfunc Benchmark_Route_Match_Star(b *testing.B) {\n\tvar match bool\n\tvar params [maxParams]string\n\n\tparsed := parseRoute(\"/*\")\n\troute := &Route{\n\t\tuse:         false,\n\t\troot:        false,\n\t\tstar:        true,\n\t\trouteParser: parsed,\n\t\tParams:      parsed.params,\n\t\tpath:        \"/user/keys/bla\",\n\n\t\tPath:   \"/user/keys/bla\",\n\t\tMethod: \"DELETE\",\n\t}\n\troute.Handlers = append(route.Handlers, func(_ Ctx) error {\n\t\treturn nil\n\t})\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tmatch = route.match(\"/user/keys/bla\", \"/user/keys/bla\", &params)\n\t}\n\n\trequire.True(b, match)\n\trequire.Equal(b, []string{\"user/keys/bla\"}, params[0:len(parsed.params)])\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Route_Match_Root -benchmem -count=4\nfunc Benchmark_Route_Match_Root(b *testing.B) {\n\tvar match bool\n\tvar params [maxParams]string\n\n\tparsed := parseRoute(\"/\")\n\troute := &Route{\n\t\tuse:         false,\n\t\troot:        true,\n\t\tstar:        false,\n\t\tpath:        \"/\",\n\t\trouteParser: parsed,\n\t\tParams:      parsed.params,\n\n\t\tPath:   \"/\",\n\t\tMethod: \"DELETE\",\n\t}\n\troute.Handlers = append(route.Handlers, func(_ Ctx) error {\n\t\treturn nil\n\t})\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tmatch = route.match(\"/\", \"/\", &params)\n\t}\n\n\trequire.True(b, match)\n\trequire.Equal(b, []string{}, params[0:len(parsed.params)])\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_Handler_CaseSensitive -benchmem -count=4\nfunc Benchmark_Router_Handler_CaseSensitive(b *testing.B) {\n\tapp := New()\n\tapp.config.CaseSensitive = true\n\tregisterDummyRoutes(app)\n\tappHandler := app.Handler()\n\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/user/keys/1337\")\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n}\n\n// go test -v ./... -run=^$ -bench=Benchmark_Router_Handler_Unescape -benchmem -count=4\nfunc Benchmark_Router_Handler_Unescape(b *testing.B) {\n\tapp := New()\n\tapp.config.UnescapePath = true\n\tregisterDummyRoutes(app)\n\tapp.Delete(\"/créer\", func(_ Ctx) error {\n\t\treturn nil\n\t})\n\n\tappHandler := app.Handler()\n\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(MethodDelete)\n\tc.URI().SetPath(\"/cr%C3%A9er\")\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.URI().SetPath(\"/cr%C3%A9er\")\n\t\tappHandler(c)\n\t}\n}\n\n// go test -run=^$ -bench=Benchmark_Router_Handler_StrictRouting -benchmem -count=4\nfunc Benchmark_Router_Handler_StrictRouting(b *testing.B) {\n\tapp := New()\n\tapp.config.CaseSensitive = true\n\tregisterDummyRoutes(app)\n\tappHandler := app.Handler()\n\n\tc := &fasthttp.RequestCtx{}\n\n\tc.Request.Header.SetMethod(\"DELETE\")\n\tc.URI().SetPath(\"/user/keys/1337\")\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\tappHandler(c)\n\t}\n}\n\n// go test -run=^$ -bench=Benchmark_Router_Github_API -benchmem -count=16\nfunc Benchmark_Router_Github_API(b *testing.B) {\n\tapp := New()\n\tregisterDummyRoutes(app)\n\tapp.startupProcess()\n\n\tc := &fasthttp.RequestCtx{}\n\tvar match bool\n\tvar err error\n\n\tb.ResetTimer()\n\n\tfor i := range routesFixture.TestRoutes {\n\t\tc.Request.Header.SetMethod(routesFixture.TestRoutes[i].Method)\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tc.URI().SetPath(routesFixture.TestRoutes[i].Path)\n\n\t\t\tctx := app.AcquireCtx(c).(*DefaultCtx) //nolint:errcheck, forcetypeassert // not needed\n\n\t\t\tmatch, err = app.next(ctx)\n\t\t\tapp.ReleaseCtx(ctx)\n\t\t}\n\n\t\trequire.NoError(b, err)\n\t\trequire.True(b, match)\n\t}\n}\n\ntype testRoute struct {\n\tMethod string `json:\"method\"`\n\tPath   string `json:\"path\"`\n}\n\ntype routeJSON struct {\n\tTestRoutes []testRoute `json:\"test_routes\"`\n\tGithubAPI  []testRoute `json:\"github_api\"`\n}\n"
        }
      ]
    }
  ]
}