{
  "metadata": {
    "timestamp": 1736557731011,
    "page": 873,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dragonflydb/dragonfly",
      "stars": 26729,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.47,
          "content": "# ---\n# We'll use defaults from the Google style, but with 2 columns indentation.\nBasedOnStyle: Google\nIndentWidth: 2\nColumnLimit: 100\n---\nLanguage: Cpp\nAllowShortLoopsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: false\nAllowShortIfStatementsOnASingleLine: false\nAlwaysBreakTemplateDeclarations: false\nPackConstructorInitializers: NextLine\nDerivePointerAlignment: false\nPointerAlignment: Left\nBasedOnStyle: Google\nColumnLimit: 100\n---\nLanguage: Proto\nBasedOnStyle: Google\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 2.53,
          "content": "---\n\nChecks: >\n  -abseil-no-namespace,\n  bugprone*,\n  # Sadly narrowing conversions is too noisy\n  -bugprone-narrowing-conversions,\n  -bugprone-easily-swappable-parameters,\n  -bugprone-branch-clone,\n  -bugprone-implicit-widening-of-multiplication-result,\n  boost-use-to-string,\n  performance*,\n  cert*,\n  -cert-err58-cpp,\n  # Doesn't work with abseil flags\n  clang-analyzer*,\n  google-*,\n  -google-runtime-int,\n  -google-readability-*,\n  -google-build-using-namespace,\n  misc-definitions-in-headers,\n  misc-misleading*,\n  misc-misplaced-const,\n  misc-new-delete-overloads,\n  misc-non-copyable-objects,\n  misc-redundant-expression,\n  misc-static-assert,\n  misc-throw-by-value-catch-by-reference,\n  misc-unconventional-assign-operator,\n  misc-uniqueptr-reset-release,\n  misc-unused-alias-decls,\n  misc-unused-using-decls,\n  modernize-deprecated-headers,\n  modernize-macro-to-enum,\n  modernize-make-shared,\n  modernize-make-unique,\n  modernize-pass-by-value,\n  modernize-raw-string-literal,\n  modernize-redundant-void-arg,\n  modernize-replace-disallow-copy-and-assign-macro,\n  modernize-return-braced-init-list,\n  modernize-shrink-to-fit,\n  modernize-unary-static-assert,\n  modernize-use-emplace,\n  modernize-use-equals-delete,\n  modernize-use-noexcept,\n  modernize-use-transparent-functors,\n  modernize-use-uncaught-exceptions,\n  modernize-use-using,\n  readability-avoid-const-params-in-decls,\n  readability-const-return-type,\n  readability-container-contains,\n  readability-container-size-empty,\n  readability-delete-null-pointer,\n  readability-duplicate-include,\n  readability-function-size,\n  readability-identifier-naming,\n  readability-inconsistent-declaration-parameter-name,\n  readability-make-member-function-const,\n  readability-misplaced-array-index,\n  readability-named-parameter,\n  readability-non-const-parameter,\n  readability-redundant-access-specifiers,\n  readability-redundant-control-flow,\n  readability-redundant-declaration,\n  readability-redundant-function-ptr-dereference,\n  readability-redundant-member-init,\n  readability-redundant-preprocessor,\n  readability-redundant-smartptr-get,\n  readability-redundant-string-cstr,\n  readability-redundant-string-init,\n  readability-simplify-subscript-expr,\n  readability-static-definition-in-anonymous-namespace,\n  readability-string-compare,\n  readability-suspicious-call-argument,\n  readability-uniqueptr-delete-release,\n  readability-use-anyofallof\n\n\n# Disabled because they're currently too disruptive, but one day might be nice to have:\n# modernize-use-nullptr,\n# modernize-use-equals-default,\n# readability-qualified-auto,\n"
        },
        {
          "name": ".ct.yaml",
          "type": "blob",
          "size": 0.22,
          "content": "# See https://github.com/helm/chart-testing#configuration\nremote: origin\ntarget-branch: main\nchart-dirs:\n  - contrib/charts\nhelm-extra-args: --debug --timeout 60s\ncheck-version-increment: false\nvalidate-maintainers: false\n"
        },
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.03,
          "content": "_deps/*\nbuild-*\ntools/packaging/*\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.23,
          "content": "build/*\nbuild-*\nclang/*\nclang-*\n.vscode/*.db\n.vscode/settings.json\n.vscode/launch.json\nthird_party\ngenfiles/*\n*.sublime-*\n*.orig\n.tags\n!third_party/include/*\n*.pyc\n/CMakeLists.txt.user\n_deps\nreleases\n.DS_Store\n.idea/*\n.hypothesis\n.secrets\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.08,
          "content": "[submodule \"helio\"]\n\tpath = helio\n\turl = https://github.com/romange/helio.git\n"
        },
        {
          "name": ".gitorderfile",
          "type": "blob",
          "size": 0.05,
          "content": "*.py\n*.md\n*.in\n*.txt\n*.sh\n*.yml\n*.h\n*.cc\n*.lua\n*.go\n*\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.8,
          "content": "default_stages: [commit]\nexclude: |\n    (?x)(\n      src/redis/.* |\n      contrib/charts/dragonfly/ci/.* |\n      patches/.*\n    )\nrepos:\n  - repo: local\n    hooks:\n      - id: conventional-commits\n        name: Conventional Commit Minder\n        entry: contrib/scripts/conventional-commits\n        language: script\n        stages: [commit-msg]\n\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n\n  - repo: https://github.com/pre-commit/mirrors-clang-format\n    rev: v14.0.6\n    hooks:\n      - id: clang-format\n        name: Clang formatting\n\n  - repo: https://github.com/psf/black\n    rev: 23.7.0\n    hooks:\n      - id: black\n\n  - repo: https://github.com/gitleaks/gitleaks\n    rev: v8.16.3\n    hooks:\n      - id: gitleaks\n"
        },
        {
          "name": ".pre-commit-hooks.yaml",
          "type": "blob",
          "size": 0.25,
          "content": "- id: conventional-commits\n  name: Conventional Commits Minder\n  entry: contrib/scripts/conventional-commits\n  language: script\n  description: Conventional Commits Enforcement at the `git commit` client-side level\n  always_run: true\n  stages: [commit-msg]"
        },
        {
          "name": ".snyk",
          "type": "blob",
          "size": 0.1,
          "content": "# Snyk (https://snyk.io) policy file\nexclude:\n global:\n   - tests/integration/**\n   - contrib/charts/**\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CLA.txt",
          "type": "blob",
          "size": 1.06,
          "content": "Thanks for your interest in contributing to Dragonfly™. By contributing to this project\nin any way form or media you grant DragonflyDB Ltd. and its affiliates a perpetual, worldwide, non-exclusive, free of charge, royalty-free, irrevocable license to use,\nmodify, make available, reproduce, make derivatives, publicly display and perform, sublicense, sell, and distribute your contributions and any derivatives thereof as part of Dragonfly™.\nYou represent that You are legally entitled to grant the above license. You acknowledge that DragonflyDB currently distributes Dragonfly™ under the Business Source License 1.1 (BSL-1.1) license, and agree that your contribution may be distributed under BSL-1.1 as part of Dragonfly™. You also represent that your contributions are your original work and that neither the content contributed, nor making the contribution to Dragonfly™ violates any third party’ rights. If you are making this contribution while being engaged by any other company or entity, please make sure you have the necessary permissions required to do so.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.94,
          "content": "cmake_minimum_required(VERSION 3.15 FATAL_ERROR)\nset(PROJECT_CONTACT romange@gmail.com)\n\ninclude(CheckCXXCompilerFlag)\n\nenable_testing()\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS 1)\n\n# Set targets in folders\nset_property(GLOBAL PROPERTY USE_FOLDERS ON)\nproject(DRAGONFLY C CXX)\nset(CMAKE_CXX_STANDARD 17)\n\n# Disabled because it has false positives with ref-counted intrusive pointers.\nCHECK_CXX_COMPILER_FLAG(\"-Wuse-after-free\" HAS_USE_AFTER_FREE_WARN)\nif (HAS_USE_AFTER_FREE_WARN)\n    set(CMAKE_CXX_FLAGS \"-Wno-use-after-free ${CMAKE_CXX_FLAGS}\")\nendif()\n\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n    set(CMAKE_CXX_FLAGS \"-Wthread-safety ${CMAKE_CXX_FLAGS}\")\n    add_compile_options(-Werror=thread-safety)\nendif()\n\n# We can not use here CHECK_CXX_COMPILER_FLAG because systems that do not support sanitizers\n# fail during linking time.\nset(CMAKE_REQUIRED_FLAGS \"-fsanitize=address\")\ncheck_cxx_source_compiles(\"int main() { return 0; }\" SUPPORT_ASAN)\n\nset(CMAKE_REQUIRED_FLAGS \"-fsanitize=undefined\")\ncheck_cxx_source_compiles(\"int main() { return 0; }\" SUPPORT_USAN)\nset(CMAKE_REQUIRED_FLAGS \"\")\n\n# We must define all the required variables from the root cmakefile, otherwise\n# they just disappear.\nset(CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/helio/cmake\" ${CMAKE_MODULE_PATH})\noption(BUILD_SHARED_LIBS \"Build shared libraries\" OFF)\noption(DF_USE_SSL \"Provide support for SSL connections\" ON)\n\nfind_package(OpenSSL)\n\noption(WITH_ASAN \"Enable -fsanitize=address\" OFF)\nif (SUPPORT_ASAN AND WITH_ASAN)\n  message(STATUS \"address sanitizer enabled\")\n  set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address\")\nendif()\n\noption(WITH_USAN \"Enable -fsanitize=undefined\" OFF)\nif (SUPPORT_USAN AND WITH_USAN)\n  message(STATUS \"ub sanitizer enabled\")\n  set(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=undefined\")\nendif()\n\ninclude(third_party)\ninclude(internal)\n\ninclude_directories(src)\ninclude_directories(helio)\n\nadd_subdirectory(helio)\nadd_subdirectory(src)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.13,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nhttps://github.com/dragonflydb/dragonfly/discussions.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.52,
          "content": "# Contributing to Dragonfly DB\n\nThank you for your interest in Dragonfly DB.\n\nFeel free to browse our [Discussions](https://github.com/dragonflydb/dragonfly/discussions) and [Issues](https://github.com/dragonflydb/dragonfly/issues)\n\n## Build from source\n\nSee [building from source](./docs/build-from-source.md)\n\nPlease note that to build a development/debug version,\nit's better to alter the configure and build steps above with:\n\n```sh\n./helio/blaze.sh   # without '-release' flag. Creates build-dbg subfolder\ncd build-dbg && ninja dragonfly\n```\n\n## Before you make your changes\n\n```sh\ncd dragonfly   # project root\n\n# Make sure you have 'pre-commit' and 'clang-format' installed\npip install pre-commit clang-format\n\n# IMPORTANT! Enable our pre-commit message hooks\n# This will ensure your commits match our formatting requirements\npre-commit install\n```\n\nThis step must be done on each machine you wish to develop and contribute from to activate the `commit-msg` and `commit` hooks client-side.\n\nOnce you have done these things, we look forward to adding your contributions and improvements to the Dragonfly DB project.\n\n## Unit testing\n\n```\n# Build a specific test\ncd build-dbg && ninja [test_name]\n# e.g cd build-dbg && ninja generic_family_test\n\n# Run\n./[test_name]\n# e.g ./generic_family_test\n```\n\n## Rendering Helm golden files\n\nA Golang golden test is included in the dragonfly helm chart. This test will render the chart and compare the output to a golden file. If the output has changed, the test will fail and the golden file will need to be updated. This can be done by running:\n\n```bash\ncd contrib/charts/dragonfly\ngo test -v ./... -update\n```\n\nThis makes it easy to see the changes in the rendered output without having to manually run the `helm template` and diff the output.\n\n## Signoff Commits\n\nAll community submissions must include a signoff.\n\n```bash\ngit commit -s -m '...'\n```\n\n## Squash Commits\n\nPlease squash all commits for a change into a single commit (this can be done using \"git rebase -i\"). Do your best to have a well-formed commit message for the change.\n\n## Use Conventional Commits\n\nThis repo uses [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)\n\nThe Conventional Commits specification is a lightweight convention on top of commit messages.\nIt provides an easy set of rules for creating an explicit commit history;\nwhich makes it easier to write automated tools on top of.\nThis convention dovetails with [SemVer](http://semver.org),\nby describing the features, fixes, and breaking changes made in commit messages.\n\nThe commit message should be structured as follows:\n\n---\n\n```\n<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\n```\n\n---\n\nThis repo uses automated tools to standardize the formatting of code, text files, and commits.\n\n- [Pre-commit hooks](#pre-commit-hooks) validate and automatically apply code\n   formatting rules.\n\n## `pre-commit` hooks\n\nThe Dragonfly DB team has agreed to systematically use several pre-commit hooks to\nnormalize the formatting of code. You need to install and enable pre-commit to have these used\nwhen you do your commits.\n\n## Codebase guidelines\n\nThis repo conforms to the Google's C++ Style Guide. Keep in mind we use an older version of the\nstyle guide which can be found [here](https://github.com/google/styleguide/blob/505ba68c74eb97e6966f60907ce893001bedc706/cppguide.html).\n\nAny exceptions to the rules specified in the style guide will be documented here.\n\n## License terms for contributions\n\nPlease see our [CLA agreement](./CLA.txt)\n\n## THANK YOU FOR YOUR CONTRIBUTIONS\n"
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 0.81,
          "content": "# Contributors (alphabetical by surname)\n\n* **[Amir Alperin](https://github.com/iko1)**\n* **[Philipp Born](https://github.com/tamcore)**\n  * Helm Chart\n* **[Meng Chen](https://github.com/matchyc)**\n* **[Yuxuan Chen](https://github.com/YuxuanChen98)**\n* **[Pawel Kaplinski](https://github.com/pawelKapl)**\n* **[Redha Lhimeur](https://github.com/redhal)**\n* **[Braydn Moore](https://github.com/braydnm)**\n* **[Logan Raarup](https://github.com/logandk)**\n* **[Ryan Russell](https://github.com/ryanrussell)**\n  * Docs & Code Readability\n* **[Ali-Akber Saifee](https://github.com/alisaifee)**\n* **[Elle Y](https://github.com/inohime)**\n* **[ATM SALEH](https://github.com/ATM-SALEH)**\n* **[Shohei Shiraki](https://github.com/highpon)**\n* **[Leonardo Mello](https://github.com/lsvmello)**\n* **[Nico Coetzee](https://github.com/nicc777)**\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 3.22,
          "content": "# Dragonfly Business Source License 1.1\n\n<u>License</u>: Business Source License 1.1 [BSL 1.1](https://spdx.org/licenses/BUSL-1.1.html)\n\n<u>Licensor</u>: DragonflyDB, Ltd.\n\n<u>Licensed Work</u>: Dragonfly including the software components, or any portion of them, and any modification.\n\n<u>Change Date</u>: March 1, 2029\n\n<u>Change License</u>: [Apache License, Version\n2.0](https://www.apache.org/licenses/LICENSE-2.0), as published by the\nApache Foundation.\n\n<u>Additional Use Grant</u>: You may make use of the Licensed Work (i) only as part of your own product or service, provided it is not an in-memory data store product or service; and (ii) provided that you do not use, provide, distribute, or make available the Licensed Work as a Service.\nA “Service” is a commercial offering, product, hosted, or managed service, that allows third parties (other than your own employees and contractors acting on your behalf) to access and/or use the Licensed Work or a substantial set of the features or functionality of the Licensed Work to third parties as a software-as-a-service, platform-as-a-service, infrastructure-as-a-service or other similar services that compete with Licensor products or services.\n\nText of BSL 1.1\n\nThe Licensor hereby grants you the right to copy, modify, create\nderivative works, redistribute, and make non-production use of the\nLicensed Work. The Licensor may make an Additional Use Grant, above,\npermitting limited production use.\n\nEffective on the Change Date, or the fourth anniversary of the first\npublicly available distribution of a specific version of the Licensed\nWork under this License, whichever comes first, the Licensor hereby\ngrants you rights under the terms of the Change License, and the rights\ngranted in the paragraph above terminate.\n\nIf your use of the Licensed Work does not comply with the requirements\ncurrently in effect as described in this License, you must purchase a\ncommercial license from the Licensor, its affiliated entities, or\nauthorized resellers, or you must refrain from using the Licensed Work.\n\nAll copies of the original and modified Licensed Work, and derivative\nworks of the Licensed Work, are subject to this License. This License\napplies separately for each version of the Licensed Work and the Change\nDate may vary for each version of the Licensed Work released by\nLicensor.\n\nYou must conspicuously display this License on each original or modified\ncopy of the Licensed Work. If you receive the Licensed Work in original\nor modified form from a third party, the terms and conditions set forth\nin this License apply to your use of that work.\n\nAny use of the Licensed Work in violation of this License will\nautomatically terminate your rights under this License for the current\nand all other versions of the Licensed Work.\n\nThis License does not grant you any right in any trademark or logo of\nLicensor or its affiliates (provided that you may use a trademark or\nlogo of Licensor as expressly required by this License).\n\nTO THE EXTENT PERMITTED BY APPLICABLE LAW, THE LICENSED WORK IS PROVIDED\nON AN “AS IS” BASIS. LICENSOR HEREBY DISCLAIMS ALL WARRANTIES AND\nCONDITIONS, EXPRESS OR IMPLIED, INCLUDING (WITHOUT LIMITATION)\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\nNON-INFRINGEMENT, AND TITLE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.6,
          "content": "BUILD_ARCH := $(shell uname -m)\nRELEASE_NAME := \"dragonfly-${BUILD_ARCH}\"\nHELIO_RELEASE_FLAGS = -DHELIO_RELEASE_FLAGS=\"-g\"\nHELIO_USE_STATIC_LIBS = ON\nHELIO_OPENSSL_USE_STATIC_LIBS = ON\nHELIO_ENABLE_GIT_VERSION = ON\nHELIO_WITH_UNWIND = OFF\nRELEASE_DIR=build-release\n\n# Some distributions (old fedora) have incorrect dependencies for crypto\n# so we add -lz for them.\nLINKER_FLAGS=-lz\n\n# equivalent to: if $(uname_m) == x86_64 || $(uname_m) == amd64\nifneq (, $(filter $(BUILD_ARCH),x86_64 amd64))\nHELIO_MARCH_OPT := -march=core2 -msse4.1 -mpopcnt -mtune=skylake\nendif\n\n# For release builds we link statically libstdc++ and libgcc. Currently,\n# all the release builds are performed by gcc.\nLINKER_FLAGS += -static-libstdc++ -static-libgcc\n\nHELIO_FLAGS = -DHELIO_RELEASE_FLAGS=\"-g\" \\\n\t\t\t  -DCMAKE_EXE_LINKER_FLAGS=\"$(LINKER_FLAGS)\" \\\n              -DBoost_USE_STATIC_LIBS=$(HELIO_USE_STATIC_LIBS) \\\n              -DOPENSSL_USE_STATIC_LIBS=$(HELIO_OPENSSL_USE_STATIC_LIBS) \\\n              -DENABLE_GIT_VERSION=$(HELIO_ENABLE_GIT_VERSION) \\\n              -DWITH_UNWIND=$(HELIO_WITH_UNWIND) -DMARCH_OPT=\"$(HELIO_MARCH_OPT)\"\n\n.PHONY: default\n\nconfigure:\n\tcmake -L -B $(RELEASE_DIR) -DCMAKE_BUILD_TYPE=Release -GNinja $(HELIO_FLAGS)\n\nbuild:\n\tcd $(RELEASE_DIR); \\\n\tninja dragonfly && ldd dragonfly\n\npackage:\n\tcd $(RELEASE_DIR); \\\n\ttar cvfz $(RELEASE_NAME)-dbgsym.tar.gz dragonfly ../LICENSE.md; \\\n\tobjcopy \\\n\t\t--remove-section=\".debug_*\" \\\n\t\t--remove-section=\"!.debug_line\" \\\n\t\t--compress-debug-sections \\\n\t\tdragonfly \\\n\t\t$(RELEASE_NAME); \\\n\ttar cvfz $(RELEASE_NAME).tar.gz $(RELEASE_NAME) ../LICENSE.md\n\nrelease: configure build\n\ndefault: release\n"
        },
        {
          "name": "README.ja-JP.md",
          "type": "blob",
          "size": 16.63,
          "content": "<p align=\"center\">\n  <a href=\"https://dragonflydb.io\">\n    <img  src=\"/.github/images/logo-full.svg\"\n      width=\"284\" border=\"0\" alt=\"Dragonfly\">\n  </a>\n</p>\n\n[![ci-tests](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml/badge.svg)](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml) [![Twitter URL](https://img.shields.io/twitter/follow/dragonflydbio?style=social)](https://twitter.com/dragonflydbio)\n\nその他の言語:  [English](README.md) [简体中文](README.zh-CN.md) [한국어](README.ko-KR.md)\n\n[Web サイト](https://www.dragonflydb.io/) • [ドキュメント](https://dragonflydb.io/docs) • [クイックスタート](https://www.dragonflydb.io/docs/getting-started) • [コミュニティ Discord](https://discord.gg/HsPjXGVH85) • [Dragonfly Forum](https://dragonfly.discourse.group/) • [Join the Dragonfly Community](https://www.dragonflydb.io/community)\n\n[GitHub Discussions](https://github.com/dragonflydb/dragonfly/discussions) • [GitHub Issues](https://github.com/dragonflydb/dragonfly/issues) • [コントリビュート](https://github.com/dragonflydb/dragonfly/blob/main/CONTRIBUTING.md)\n\n## 世界最速のインメモリデータストア\n\nDragonfly は最新のアプリケーションワークロードのために構築されたインメモリデータストアです。\n\nRedis や Memcached の API と完全に互換性があるため、Dragonfly を採用するためにコードを変更する必要はありません。従来のインメモリデータストアと比較して、Dragonfly は 25 倍のスループット、より低いテールレイテンシでより高いキャッシュヒット率、そして容易な垂直スケーラビリティを提供します。\n\n## コンテンツ\n\n- [ベンチマーク](#ベンチマーク)\n- [クイックスタート](https://github.com/dragonflydb/dragonfly/tree/main/docs/quick-start)\n- [コンフィグ](#コンフィグ)\n- [ロードマップとステータス](#ロードマップとステータス)\n- [デザイン決定](#デザイン決定)\n- [バックグラウンド](#バックグラウンド)\n\n## <a name=\"ベンチマーク\"><a/>ベンチマーク\n\n<img src=\"http://static.dragonflydb.io/repo-assets/aws-throughput.svg\" width=\"80%\" border=\"0\"/>\n\nベンチマークでは、Dragonfly は Redis と比較して 25 倍のスループットを示し、c6gn.16xlarge で 3.8M QPS を超えました。\n\nDragonfly のピークスループットにおける 99 パーセンタイルのレイテンシ指標:\n\n| op    | r6g   | c6gn  | c7g   |\n|-------|-------|-------|-------|\n| set   | 0.8ms | 1ms   | 1ms   |\n| get   | 0.9ms | 0.9ms | 0.8ms |\n| setex | 0.9ms | 1.1ms | 1.3ms |\n\n*すべてのベンチマークは `memtier_benchmark` (下記参照) を使い、スレッド数はサーバーとインスタンスタイプごとに調整しました。`memtier` は別の c6gn.16xlarge マシンで実行した。SETEX ベンチマークの有効期限は 500 に設定し、テストが終了しても有効であることを確認しました。*\n\n```bash\n  memtier_benchmark --ratio ... -t <threads> -c 30 -n 200000 --distinct-client-seed -d 256 \\\n     --expiry-range=...\n```\n\nパイプラインモード `--pipeline=30` では、Dragonfly は SET 操作で **10M QPS**、GET 操作で **15M QPS** に達する。\n\n### Dragonfly vs. Memcached\n\nAWS 上の c6gn.16xlarge インスタンスで Dragonfly と Memcached を比較した。\n\n同程度のレイテンシで、Dragonfly のスループットは Memcached のスループットを書き込みと読み込みの両方のワークロードで上回った。Dragonfly は、[Memcached の書き込みパス](docs/memcached_benchmark.md)での競合により、書き込みワークロードでより優れたレイテンシを示しました。\n\n#### SET ベンチマーク\n\n| Server    | QPS(thousands qps) | latency 99% | 99.9%   |\n|:---------:|:------------------:|:-----------:|:-------:|\n| Dragonfly |  🟩 3844           |🟩 0.9ms     | 🟩 2.4ms |\n| Memcached |   806              |   1.6ms     | 3.2ms    |\n\n#### GET ベンチマーク\n\n| Server    | QPS(thousands qps) | latency 99% | 99.9%   |\n|-----------|:------------------:|:-----------:|:-------:|\n| Dragonfly | 🟩 3717            |   1ms       | 2.4ms   |\n| Memcached |   2100             |  🟩 0.34ms  | 🟩 0.6ms |\n\n\nMemcached は読み取りベンチマークでより低いレイテンシを示したが、スループットも低かった。\n\n### メモリ効率\n\nメモリ効率をテストするために、`debug populate 5000000 key 1024` コマンドを使用して Dragonfly と Redis に ~5GB のデータを入れ、`memtier` コマンドで更新トラフィックを送信し、`bgsave` コマンドでスナップショットを開始しました。\n\nこの図は、各サーバがメモリ効率の面でどのような挙動を示したかを示している。\n\n<img src=\"http://static.dragonflydb.io/repo-assets/bgsave-memusage.svg\" width=\"70%\" border=\"0\"/>\n\nDragonfly はアイドル状態では Redis よりも 30% メモリ効率が高く、スナップショットフェーズではメモリ使用量の目に見える増加は見られなかった。ピーク時には Redis のメモリ使用量は Dragonfly の 3 倍近くまで増加しました。\n\nDragonfly はスナップショットをより早く、数秒以内に終了させました。\n\nDragonfly のメモリ効率の詳細については、[Dashtable ドキュメント](/docs/dashtable.md)を参照してください。\n\n\n\n## <a name=\"コンフィグ\"><a/>コンフィグ\n\nDragonfly は一般的な Redis の引数をサポートしています。例えば `dragonfly --requirepass=foo --bind localhost`。\n\nDragonfly は現在、以下の Redis 固有の引数をサポートしています:\n * `port`： Redis 接続ポート (`default: 6379`).\n * `bind`： ローカルホストからの接続のみを許可する場合は `localhost` を、**その IP** アドレスへの接続 (つまり外部からの接続) を許可する場合はパブリック IP アドレスを指定する。\n * `requirepass`： AUTH 認証用のパスワード (`default: \"\"`)。\n * `maxmemory`： データベースが使用するメモリの上限 (人間が読めるバイト数) (`default: 0`)。 `maxmemory` に `0` を指定すると、プログラムが自動的に最大メモリ使用量を決定する。\n * `dir`： Dragonfly Docker はデフォルトで `/data` フォルダをスナップショットに使用し、CLI は `\"\"` を使用する。`v` の Docker オプションでホストフォルダにマッピングできる。\n * `dbfilename`： データベースを保存・ロードするファイル名 (`default: dump`).\n\nDragonfly 特有の議論もある:\n * `memcached_port`: Memcached 互換 API を有効にするポート (`default: disabled`)。\n * `keys_output_limit`: `keys` コマンドで返されるキーの最大数（`default: 8192`）。`keys` は危険なコマンドであることに注意してください。あまりに多くのキーを取得するとメモリ使用量が増大するため、結果を切り捨てています。\n * `dbnum`: `select` でサポートされるデータベースの最大数。\n * `cache_mode`: 以下の[斬新なキャッシュデザイン](#斬新なキャッシュデザイン)のセクションを参照してください。\n * `hz`: キーの有効期限評価頻度 (`default: 100`)。この頻度が低いと、アイドル時の CPU 使用量が少なくなるが、その分古くなったキーをクリアする速度が遅くなる。\n * `primary_port_http_enabled`: もし `true` (`default: true`) なら、メイン TCP ポートで HTTP コンソールにアクセスできるようにする。\n * `admin_port`: 割り当てられたポートのコンソールへの管理者アクセスを有効にする(`default: disabled`)。HTTP と RESP プロトコルの両方をサポートする。\n * `admin_bind`: 管理コンソールの TCP 接続を指定されたアドレスにバインドする(`default: any`)。HTTP と RESP の両方のプロトコルをサポートする。\n * `admin_nopass`: 割り当てられたポートで、認証トークンなしでコンソールへのオープン管理アクセスを有効にする (`default: false`)。HTTP と RESP の両方のプロトコルをサポートする。\n * `cluster_mode`: サポートするクラスターモード (`default: \"\"`)。現在は `emulated` のみをサポートしている。\n * `cluster_announce_ip`: クラスタコマンドがクライアントにアナウンスする IP。\n\n### 一般的なオプションを使用した開始スクリプトの例:\n\n```bash\n./dragonfly-x86_64 --logtostderr --requirepass=youshallnotpass --cache_mode=true -dbnum 1 --bind localhost --port 6379  --maxmemory=12gb --keys_output_limit=12288 --dbfilename dump.rdb\n```\n\nまた、`dragonfly --flagfile <filename>` を実行することで、設定ファイルから引数を指定することもできる。ファイルには 1 行に 1 つのフラグを記述し、キーと値のフラグには空白の代わりに等号を記述します。\n\nログの管理や TLS のサポートなど、その他のオプションについては `dragonfly --help` を実行してください。\n\n## <a name=\"ロードマップとステータス\"><a/>ロードマップとステータス\n\nDragonfly は現在、~185 個の Redis コマンドと、`cas` 以外のすべての Memcached コマンドをサポートしている。ほぼ Redis 5 API と同等ですが、Dragonfly の次のマイルストーンは基本的な機能を安定させ、レプリケーション API を実装することです。まだ実装されていないコマンドで必要なものがあれば、issue を開いてください。\n\nDragonfly ネイティブのレプリケーションについては、桁違いに高速な分散ログフォーマットを設計中です。\n\nレプリケーション機能に続いて、Redis バージョン 3-6 の API に不足しているコマンドを追加していく予定です。\n\n現在 Dragonfly がサポートしているコマンドについては、[コマンドリファレンス](https://dragonflydb.io/docs/category/command-reference)をご覧ください。\n\n## <a name=\"デザイン決定\"><a/> デザイン決定\n\n### 斬新なキャッシュデザイン\n\nDragonfly には、シンプルでメモリ効率の良い、単一の統一された適応型キャッシュアルゴリズムがあります。\n\n`cache_mode=true` フラグを渡すことでキャッシュモードを有効にすることができます。このモードをオンにすると、Dragonfly は将来つまずく可能性が最も低いアイテムを退避させますが、`maxmemory` の限界に近づいたときのみ退避させます。\n\n### 比較的正確な有効期限\n\n有効期限は 8 年以内。\n\nミリ秒精度の有効期限（PEXPIRE、PSETEX など）は、**2^28ms** を超える期限については、最も近い秒に丸められます。この誤差は 0.001% 以下であり、大きな範囲であれば許容範囲となります。\n\nDragonfly の期限と Redis の実装の詳細な違いについては、[こちら](docs/differences.md)を参照してください。\n\n### ネイティブ HTTP コンソールと Prometheus 互換メトリクス\n\nデフォルトでは、Dragonfly はメイン TCP ポート(6379)経由での HTTP アクセスを許可しています。その通り、Redis プロトコル経由でも HTTP プロトコル経由でも Dragonfly に接続することができます。ブラウザで試してみてください。HTTP アクセスには現在あまり情報がありませんが、将来的にはデバッグや管理に役立つ情報が含まれるようになる予定です。\n\nPrometheus 互換のメトリクスを見るには、URL `:6379/metrics` にアクセスしてください。\n\nPrometheus からエクスポートされたメトリクスは Grafana ダッシュボードと互換性があります[こちらを参照](tools/local/monitoring/grafana/provisioning/dashboards/dashboard.json)。\n\n\n重要です！HTTP コンソールは安全なネットワーク内でアクセスすることを想定しています。Dragonfly の TCP ポートを外部に公開する場合は、`--http_admin_console=false` または `--nohttp_admin_console` でコンソールを無効にすることをお勧めします。\n\n\n## <a name=\"バックグラウンド\"><a/>バックグラウンド\n\nDragonfly は、インメモリデータストアを 2022 年に設計したらどのようになるかという実験から始まりました。メモリストアのユーザーとして、またクラウド企業で働いたエンジニアとしての経験から学んだ教訓をもとに、Dragonfly では 2 つの重要な特性を維持する必要があると考えました: それは、すべてのオペレーションにおける原子性の保証と、非常に高いスループットにおけるミリ秒以下の低レイテンシーです。\n\n私たちの最初の課題は、パブリッククラウドで現在利用可能なサーバーを使用して、CPU、メモリー、I/O リソースをフルに活用する方法でした。これを解決するために、私たちは[シェアードナッシングアーキテクチャ](https://en.wikipedia.org/wiki/Shared-nothing_architecture)を使用しています。このアーキテクチャでは、各スレッドが辞書データのスライスを独自に管理できるように、スレッド間でメモリストアの鍵空間を分割することができます。これらのスライスを \"shards\" と呼ぶ。シェアードナッシングアーキテクチャのスレッドと I/O 管理のためのライブラリは、[こちら](https://github.com/romange/helio)でオープンソースで提供されています。\n\n複数キー操作に対する原子性保証を提供するために、我々は最近の学術研究の進歩を利用している。Dragonfly のトランザクションフレームワークの開発には、論文 [\"VLL: a lock manager redesign for main memory database systems\"](https://www.cs.umd.edu/~abadi/papers/vldbj-vll.pdf) を選びました。シェアードナッシングアーキテクチャと VLL の選択により、ミューテックスやスピンロックを使用せずにアトミックなマルチキー操作を構成することができました。これは我々の PoC にとって大きなマイルストーンであり、その性能は他の商用やオープンソースのソリューションよりも際立っていました。\n\n私たちの第二の課題は、新しいストアのために、より効率的なデータ構造を設計することだった。この目標を達成するために、我々は論文 [\"Dash: Scalable Hashing on Persistent Memory\"](https://arxiv.org/pdf/2003.07302.pdf) に基づいたハッシュテーブル構造を核とした。この論文自体は、永続メモリ領域を中心にしており、メインメモリストアとは直接関係ありませんが、それでも私たちの問題に最も当てはまります。この論文で提案されているハッシュテーブル設計により、Redis の辞書に存在する 2 つの特別な特性を維持することができました: それは、データストアの成長中にハッシュをインクリメンタルする機能と、ステートレススキャン操作を使って変更中の辞書をトラバースする機能です。これら2つの特性に加え、Dash は CPU とメモリの使用効率が高い。Dash の設計を活用することで、私たちは以下のような機能をさらに革新することができました:\n * TTL レコードの効率的なレコード期限切れ。\n * LRU や LFU のような他のキャッシュ戦略よりも高いヒット率を、**ゼロメモリオーバーヘッド** で達成する新しいキャッシュエビクションアルゴリズム。\n * 新しい **フォークレス** スナップショットアルゴリズム。\n\nDragonfly の基盤を構築し、[そのパフォーマンスに満足したら](#ベンチマーク)、Redis と Memcached の機能を実装していきました。現在までに 185 個の Redis コマンド（Redis 5.0 API とほぼ同等）と 13 個の Memcached コマンドを実装しました。\n\nそして最後に、<br>\n<em>私たちの使命は、最新のハードウェアの進歩を活用した、クラウドワークロード向けの、優れた設計、超高速、コスト効率の良いインメモリデータストアを構築することです。現在のソリューションの API と提案を維持しながら、その問題点を解決するつもりです。\n</em>\n"
        },
        {
          "name": "README.ko-KR.md",
          "type": "blob",
          "size": 15.7,
          "content": "<p align=\"center\">\n  <a href=\"https://dragonflydb.io\">\n    <img  src=\"/.github/images/logo-full.svg\"\n      width=\"284\" border=\"0\" alt=\"Dragonfly\">\n  </a>\n</p>\n\n[![ci-tests](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml/badge.svg)](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml) [![Twitter URL](https://img.shields.io/twitter/follow/dragonflydbio?style=social)](https://twitter.com/dragonflydbio)\n\n다른 언어 번역본:  [English](README.zh-CN.md) [简体中文](README.zh-CN.md) [日本語](README.ja-JP.md)\n\n[Website](https://www.dragonflydb.io/) • [Docs](https://dragonflydb.io/docs) • [Quick Start](https://www.dragonflydb.io/docs/getting-started) • [Community Discord](https://discord.gg/HsPjXGVH85) • [Dragonfly Forum](https://dragonfly.discourse.group/) • [Join the Dragonfly Community](https://www.dragonflydb.io/community)\n\n[GitHub Discussions](https://github.com/dragonflydb/dragonfly/discussions) • [GitHub Issues](https://github.com/dragonflydb/dragonfly/issues) • [Contributing](https://github.com/dragonflydb/dragonfly/blob/main/CONTRIBUTING.md) • [Dragonfly Cloud](https://www.dragonflydb.io/cloud)\n\n## 세상에서 가장 빠른 인-메모리 스토어\n\nDragonfly는 현대 애플리케이션 작업을 위한 인-메모리 데이터스토어입니다.\n\nDragonfly는 Redis와 Memcached API와 완벽하게 호환되며, 이를 적용하기 위한 코드 변경을 필요로 하지 않습니다. Dragonfly는 기존 레거시 인-메모리 데이터스토어와 비교하여 25배 이상의 높은 처리량과 캐시 히트율, 낮은 꼬리 지연시간을 갖고있으며 간편한 수직 확장성을 지니고 있습니다.\n\n## 콘텐츠\n\n- [벤치마크](#benchmarks)\n- [빠른 시작](https://github.com/dragonflydb/dragonfly/tree/main/docs/quick-start)\n- [설정](#configuration)\n- [로드맵과 상태](#roadmap-status)\n- [설계 의사결정](#design-decisions)\n- [개발 배경](#background)\n\n## <a name=\"benchmarks\"><a/>벤치마크\n\n<img src=\"http://static.dragonflydb.io/repo-assets/aws-throughput.svg\" width=\"80%\" border=\"0\"/>\n\n벤치마크에 따르면, Dragonfly는 레디스와 비교하여 처리량이 25배이상 증가하였고, c6gn.16xlarge 인스턴스에서 3.8M QPS를 돌파하였음을 보여줍니다.\n\nDragonfly의 피크 처리량에서의 99퍼센트 지연 시간 지표:\n\n| op    | r6g   | c6gn  | c7g   |\n|-------|-------|-------|-------|\n| set   | 0.8ms | 1ms   | 1ms   |\n| get   | 0.9ms | 0.9ms | 0.8ms |\n| setex | 0.9ms | 1.1ms | 1.3ms |\n\n*모든 벤치마크는 서버 및 인스턴스 유형별로 조정된 스레드 수를 사용하여 `memtier_benchmark`(아래를 참고) 수행되었습니다. `memtier`는 별도의 c6gn.16xlarge 머신에서 실행되었습니다. 저희는 테스트 종료 이후에도 유효하게 유지되도록 보장하기 위해 SETEX 벤치마크의 만료 시간을 500으로 설정하였습니다.*\n\n```bash\n  memtier_benchmark --ratio ... -t <threads> -c 30 -n 200000 --distinct-client-seed -d 256 \\\n     --expiry-range=...\n```\n\n파이프라인 모드에서 `--pipeline=30`은 Dragonfly가 SET 연산으로 **10M QPS**, GET 연산으로 **15M QPS**에 도달할 수 있음을 나타냅니다.\n\n### Dragonfly vs. Memcached\n\n저희는 AWS의 c6gn.16xlarge 인스턴스에서 Dragonfly와 Memcached를 비교하는 작업을 수행했습니다.\n\n비슷한 지연시간을 가진 상황에서, Dragonfly의 처리량은 쓰기 및 읽기 작업 모두에서 Memcached보다 성능이 뛰어났습니다. 쓰기 작업에서는 [Memcached의 쓰기 경로](docs/memcached_benchmark.md)에서의 경합으로 인하여 Dragonfly가 보다 적은 지연시간을 보였다는 점이 입증되었습니다.\n\n#### SET 벤치마크\n\n| Server    | QPS(thousands qps) | latency 99% | 99.9%   |\n|:---------:|:------------------:|:-----------:|:-------:|\n| Dragonfly |  🟩 3844           |🟩 0.9ms     | 🟩 2.4ms |\n| Memcached |   806              |   1.6ms     | 3.2ms    |\n\n#### GET 벤치마크\n\n| Server    | QPS(thousands qps) | latency 99% | 99.9%   |\n|-----------|:------------------:|:-----------:|:-------:|\n| Dragonfly | 🟩 3717            |   1ms       | 2.4ms   |\n| Memcached |   2100             |  🟩 0.34ms  | 🟩 0.6ms |\n\nMemcached는 읽기 벤치마크의 지연 시간은 적었지만, 처리량도 낮았습니다.\n\n### 메모리 효율\n\n메모리 효율을 테스트하기 위해서, 저희는 `debug populate 5000000 key 1024` 명령어를 활용하여 Dragonfly와 Redis에 ~5GB 정도의 데이터를 채운 후, `memtier` 를 통하여 업데이트 트래픽을 전송한 후, `bgsave` 명령을 통하여 스냅샷을 시작했습니다.\n\n이 그림은 메모리 효율 측면에서 각 서버가 어떻게 동작했는지 보여줍니다.\n\n<img src=\"http://static.dragonflydb.io/repo-assets/bgsave-memusage.svg\" width=\"70%\" border=\"0\"/>\n\nDragonfly는 유휴 상태에서 Redis보다 메모리 효율이 30% 더 좋았으며, 스냅샷 단계에서 메모리 사용량이 눈에 띄게 증가하지 않았습니다. Redis는 고점에서 Dragonfly에 비해 메모리 사용량이 약 3배 증가하였습니다.\n\nDragonfly는 스냅샷 단계를 몇 초안에 더 빨리 마쳤습니다.\n\nDragonfly의 메모리 효율에 대한 정보가 더 필요하시다면, 저희의 [Dastable 문서](/docs/dashtable.md)를 참고하시기 바랍니다.\n\n\n## <a name=\"configuration\"><a/>설정\n\nDragonfly는 적용 가능한 Redis 인수를 지원합니다. 예를 들면, `dragonfly --requirepass=foo --bind localhost`와 같은 명령어를 사용할 수 있습니다.\n\nDragonfly는 현재 아래와 같은 Redis 인수들을 지원합니다 :\n  * `port`: Redis 연결 포트 (`기본값: 6379`).\n  * `bind`: `localhost`를 사용하여 로컬호스트 연결만 허용하거나 공용 IP 주소를 사용하여 해당 IP 주소에 연결을 허용합니다.(즉, 외부에서도 가능)\n  * `requirepass`: AUTH 인증을 위한 패스워드 (`기본값: \"\"`).\n  * `maxmemory`: 데이터베이스에서 사용하는 최대 메모리 제한(사람이 읽을 수 있는 바이트 단위) (`기본값: 0`). `maxmemory` 의 값이 `0` 이면 프로그램이 최대 메모리 사용량을 자동으로 결정합니다.\n  * `dir`: Dragonfly Docker는 스냅샷을 위해 기본적으로 `/data` 폴더를 사용하고, CLI은 `\"\"`을 사용합니다. Docker 옵션인 `-v` 을 통해서 호스트 폴더에 매핑할 수 있습니다.\n  * `dbfilename`: 저장하고 불러올 데이터베이스 파일 이름 (`기본값: dump`).\n\n아래는 Dragonfly 전용 인수 입니다 :\n  * `memcached_port`: Memcached 호환 API를 위한 포트 (`기본값: disabled`).\n  * `keys_output_limit`: `keys` 명령을 통해 반환 되는 최대 키의 수 (`기본값: 8192`). `keys` 명령은 위험하기 때문에, 너무 많은 키를 가져올 때 메모리 사용량이 급증하지 않도록 결과를 해당 인수만큼 잘라냅니다.\n  * `dbnum`: `select` 명령에 대해 지원되는 최대 데이터베이스 수.\n  * `cache_mode`: 아래의 섹션 [새로운 캐시 설계](#novel-cache-design)을 참고해주시기 바랍니다.\n  * `hz`: 키가 만료되었는지를 판단하는 빈도(`기본값: 100`). 낮은 빈도는 키 방출이 느려지는 대신, 유휴 상태일 때 CPU 사용량을 줄입니다.\n  * `primary_port_http_enabled`: `true` 인 경우 HTTP 콘솔로 메인 TCP 포트 접근을 허용합니다. (`기본값: true`).\n  * `admin_port`: 할당된 포트에서 관리자 콘솔 접근을 활성화합니다. (`기본값: disabled`). HTTP와 RESP 프로토콜 모두를 지원합니다.\n  * `admin_bind`: 주어진 주소에 관리자 콘솔 TCP 연결을 바인딩합니다. (`기본값: any`). HTTP와 RESP 프로토콜 모두를 지원합니다.\n  * `admin_nopass`: 할당된 포트에 대해서 인증 토큰 없이 관리자 콘솔 접근을 활성화합니다. (`default: false`). HTTP와 RESP 프로토콜 모두를 지원합니다.\n  * `cluster_mode`: 클러스터 모드가 지원됩니다. (`기본값: \"\"`). 현재는`emulated` 만 지원합니다.\n  * `cluster_announce_ip`: 클러스터 명령을 클라이언트에게 알리는 IP 주소.\n\n\n### 주요 옵션을 활용한 실행 스크립트 예시:\n\n```bash\n./dragonfly-x86_64 --logtostderr --requirepass=youshallnotpass --cache_mode=true -dbnum 1 --bind localhost --port 6379  --maxmemory=12gb --keys_output_limit=12288 --dbfilename dump.rdb\n```\n\n인수들은 `dragonfly --flagfile <filename>`을 실행하여 설정 파일을 통해서도 전달할 수 있습니다. 전달될 파일은 각 줄에 키-값 형태의 플래그 나열 하기위해 등호를 사용합니다.\n\n로그 관리나 TLS 지원과 같은 추가 옵션을 확인하고 싶다면, `dragonfly --help` 를 실행해보시길 바랍니다.\n\n## <a name=\"roadmap-status\"><a/>로드맵과 상태\n\nDragonfly는 현재 ~185개의 Redis 명령어들과 `cas` 뿐만 아니라 모든 Memcached 명령어를 지원합니다. 이는 거의 Redis 5 API와 동등하며, Dragonfly의 다음 마일스톤은 기본 기능 을 안정화하고 복제 API를 구현하는 것입니다. 아직 구현되지 않은 필요한 명령가 있다면, 이슈를 오픈해주세요.\n\nDraginfly 고유 복제기능을 위해, 저희는 몇 배 높은 속도를 지원할 수 있는 분산 로그 형식을 설계하고 있습니다.\n\n복제 기능을 추가한 뒤에 저희는 Redis 3-6 API에 해당되는 누락 명령어들을 계속 추가할 예정입니다.\n\nDragonfly에 의해 현재 지원되는 명령어를 확인하기 위해서 [명령어 레퍼런스](https://dragonflydb.io/docs/category/command-reference)를 참고해주시기 바랍니다.\n\n## <a name=\"design-decisions\"><a/>설계 의사결정\n\n### 새로운 캐시 설계\n\nDragonfly는 단순하고 메모리 효율적인 단일, 통합, 적응형 캐싱 알고리즘을 제공합니다.\n\n`--cache_mode=true` 플래그를 전달하여 캐싱 모드를 활성화할 수 있습니다. 이 모드가 활성화되면, Dragonfly는 `maxmemory` 한도에 가까워질 때만, 미래에 재사용 될 가능성이 가장 낮은 항목을 방출합니다.\n\n### 상대적인 정확성을 가진 만료 기한\n\n만료 범위는 약 ~8년으로 제한됩니다.\n\n밀리초 단위의 정밀한 만료 기한(PEXPIRE, PSETEX, 등)은 **2^28ms보다 큰 기한에 대해** 가장 가까운 초로 반올림됩니다. 이는 0.001% 미만의 오차를 가지며, 큰 범위에 대해 적용될 때는 수용 가능한 수준입니다. 만약 이런 방식이 사용사례에 적합하지 않다면, 문의를 주시거나 해당 사용사례를 설명하는 이슈를 오픈해주세요.\n\nDragonfly와 Redis의 만료 기한에 대한 구현의 차이는 [여기서 확인하실 수 있습니다](docs/differences.md).\n\n### 네이티브 HTTP 콘솔과 Prometheus 호환 매트릭\n\n기본적으로, Dragonfly는 메인 TCP 포트(6379)에 HTTP 접근을 허용합니다. 즉, Redis 프로토콜과 HTTP 프로토콜 모두를 통해 Dragonfly에 연결할 수 있습니다. - 서버는 연결 초기화 과정에서 프로토콜을 자동으로 인식합니다. 웹 브라우저를 통하여 시도해보시기 바랍니다. 현재 HTTP 접근은 많은 정보를 제공하지 않지만, 유용한 디버깅 및 관리 정보를 향후 추가할 예정입니다.\n\n`:6379/metrics` 에 접근하게 되면, Prometheus 호환 매트릭을 확인할 수 있습니다.\n\nPrometheus에서 내보내는 매트릭들은 Grafana 대시보드와 호환됩니다. 자세한 내용은 [여기](tools/local/monitoring/grafana/provisioning/dashboards/dashboard.json)를 참조해주세요.\n\n중요! HTTP 노솔은 안전한 네트워크 내에서 접근하도록 설계되었습니다. Dragonfly의 TCP 포트를 외부로 노출한다면, `--http_admin_console=false` 혹은 `--nohttp_admin_console`과 같은 인수를 활용하여 콘솔을 비활성화하는 것을 조언해드립니다.\n\n\n## <a name=\"background\"><a/>개발배경\n\nDragonfly는 2022년에 인-메모리 데이터스토어를 설계한다면 어땠을까에 대한 실험으로 시작되었습니다. 클라우드 회사에서 근무한 엔지니어 및 메모리 스토어 사용자의 경험을 바탕으로, 저희는 Dragonfly에 핵심적인 두 가지 핵심 특성을 보존해야함을 알았습니다: 모든 작업에 대한 원자성 보장과 매우 높은 처리량에 대한 밀리초 이하의 낮은 지연 시간을 보장하는 것이었습니다.\n\n첫 번째 문제는 오늘날 퍼블릭 클라우드 환경에서 사용 가능한 서버를 사용하여 CPU, 메모리 및 I/O 자원을 어떻게 최대한 활용할 수 있을지였습니다. 이 문제를 해결하기 위해 저희는 [비공유 아키텍처(Shared Nothing Architecture)](https://en.wikipedia.org/wiki/Shared-nothing_architecture)를 사용했습니다. 이는 저희가 메모리 스토어의 각 스레드 사이의 키 공간을 분할할 수 있게하였습니다. 이를 통해 각 스레드들은 그들의 딕셔너리 데이터들의 조각을 관리할 수 있게 되었습니다. 저희는 이 조각들을 \"샤드(shards)\"라 불렀습니다. 비공유 아키텍처에 대한 스레드 및 I/O 관리를 위한 라이브러리는 [여기](https://github.com/romange/helio)에서 오픈소스로 제공됩니다.\n\n멀티-키 작업에 대한 원자성 보장을 위해, Dragonfly의 트랜잭션 프레임워크를 개발하기 위해 저희는 최근 학계의 연구 발전을 활용했고 [\"VLL: a lock manager redesign for main memory database systems”](https://www.cs.umd.edu/~abadi/papers/vldbj-vll.pdf) 논문을 채택했습니다. 비공유 아키텍처와 VLL의 선택은 우리가 뮤텍스나 스핀락을 사용하지 않고도 원자적 멀티-키 작업을 구성할 수 있게 했습니다.\n이것은 저희의 PoC에 있어서 주요한 마일스톤이었고, 그 성능은 다른 상용 및 오픈소스 솔루션보다 성능이 뛰어났습니다.\n\n두 번째 문제는 새로운 저장소를 위하여 더 효율적인 데이터 구조를 설계하는 것이었습니다. 이 목표를 달성하기 위해서 저희는 핵심 해시테이블 구조를 [\"Dash: Scalable Hashing on Persistent Memory\"](https://arxiv.org/pdf/2003.07302.pdf) 논문을 기반으로 작업했습니다. 이 논문은 영속적인 메모리 도메인을 중심으로 다루며, 이는 메인-메모리 저장소와 직접적인 연관관계는 없었습니다. 하지만 여전히 저희 문제를 해결하기 위해서 가장 적합했습니다. 해당 논문의 제안된 해시테이블 설계는 저희가 레디스 딕셔너리에 표현된 두 가지 특별한 특성을 유지 가능하게 해줬습니다: 데이터스토어 확장 중 증분 해싱 기능과 상태 없는 스캔 작업을 사용하여 변화하는 딕셔너리를 순회하는 능력이었습니다. 이 두 가지 속성 외에도 Dash는 CPU와 메모리 사용에서 더 효율적입니다. 저희는 다음과 같은 기능들로 더욱 혁신할 수 있었습니다:\n * TTL 레코드에 대한 효율적인 만료 처리\n * LRU와 LFU 같은 다른 캐시 전략보다 더 높은 히트율을 달성하는 새로운 캐시 방출 알고리즘과 **제로 메모리 오버헤드**.\n * 새로운 **fork-less** 스냅샷 알고리즘.\n\n저희는 Dragonfly의 기반을 구축하고 성능에 만족하게 되었을 때, Redis와 Memcached의 기능을 구현하기 시작했습니다. 저희는 약 185개의 Redis 명령(대략적으로 Redis 5.0 API와 동등)과 13개의 Memecached 명령을 구현했습니다.\n\n마지막으로, <br>\n<em>저희의 임무는 최신 하드웨어 발전을 활용하는 클라우드 작업을 위한 멋진 설계와 초고속 처리량 그리고 비용효율적인 인-메모리 데이터스토어를 만드는 것입니다. 저희는 현재 솔루션의 제품 API들이나 제안을 유지하면서 당면 과제를 해결하고자 합니다.\n</em>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.37,
          "content": "<p align=\"center\">\n  <a href=\"https://dragonflydb.io\">\n    <img  src=\"/.github/images/logo-full.svg\"\n      width=\"284\" border=\"0\" alt=\"Dragonfly\">\n  </a>\n</p>\n\n[![ci-tests](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml/badge.svg)](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml) [![Twitter URL](https://img.shields.io/twitter/follow/dragonflydbio?style=social)](https://twitter.com/dragonflydbio)\n\n> Before moving on, please consider giving us a GitHub star ⭐️. Thank you!\n\nOther languages:  [简体中文](README.zh-CN.md) [日本語](README.ja-JP.md) [한국어](README.ko-KR.md)\n\n[Website](https://www.dragonflydb.io/) • [Docs](https://dragonflydb.io/docs) • [Quick Start](https://www.dragonflydb.io/docs/getting-started) • [Community Discord](https://discord.gg/HsPjXGVH85) • [Dragonfly Forum](https://dragonfly.discourse.group/) • [Join the Dragonfly Community](https://www.dragonflydb.io/community)\n\n[GitHub Discussions](https://github.com/dragonflydb/dragonfly/discussions) • [GitHub Issues](https://github.com/dragonflydb/dragonfly/issues) • [Contributing](https://github.com/dragonflydb/dragonfly/blob/main/CONTRIBUTING.md) • [Dragonfly Cloud](https://www.dragonflydb.io/cloud)\n\n## The world's most efficient in-memory data store\n\nDragonfly is an in-memory data store built for modern application workloads.\n\nFully compatible with Redis and Memcached APIs, Dragonfly requires no code changes to adopt. Compared to legacy in-memory datastores, Dragonfly delivers 25X more throughput, higher cache hit rates with lower tail latency, and can run on up to 80% less resources for the same sized workload.\n\n## Contents\n\n- [Benchmarks](#benchmarks)\n- [Quick start](https://github.com/dragonflydb/dragonfly/tree/main/docs/quick-start)\n- [Configuration](#configuration)\n- [Roadmap and status](#roadmap-status)\n- [Design decisions](#design-decisions)\n- [Background](#background)\n- [Build from source](./docs/build-from-source.md)\n\n## <a name=\"benchmarks\"><a/>Benchmarks\n\nWe first compare Dragonfly with Redis on `m5.large` instance which is commonly used to run Redis\ndue to its single-threaded architecture. The benchmark program runs from another\nload-test instance (c5n) in the same AZ using `memtier_benchmark  -c 20 --test-time 100 -t 4 -d 256 --distinct-client-seed`\n\nDragonfly shows a comparable performance:\n\n1. SETs (`--ratio 1:0`):\n\n|  Redis                                   |      DF                                |\n| -----------------------------------------|----------------------------------------|\n| QPS: 159K, P99.9: 1.16ms, P99: 0.82ms    | QPS:173K, P99.9: 1.26ms, P99: 0.9ms    |\n|                                          |                                        |\n\n2. GETs (`--ratio 0:1`):\n\n|  Redis                                  |      DF                                |\n| ----------------------------------------|----------------------------------------|\n| QPS: 194K, P99.9: 0.8ms, P99: 0.65ms    | QPS: 191K, P99.9: 0.95ms, P99: 0.8ms   |\n\nThe benchmark above shows that the algorithmic layer inside DF that allows it to scale vertically\ndoes not take a large toll when running single-threaded.\n\nHowever, if we take a bit stronger instance (m5.xlarge), the gap between DF and Redis starts growing.\n(`memtier_benchmark  -c 20 --test-time 100 -t 6 -d 256 --distinct-client-seed`):\n1. SETs (`--ratio 1:0`):\n\n|  Redis                                  |      DF                                |\n| ----------------------------------------|----------------------------------------|\n| QPS: 190K, P99.9: 2.45ms, P99: 0.97ms   |  QPS: 279K , P99.9: 1.95ms, P99: 1.48ms|\n\n2. GETs (`--ratio 0:1`):\n\n|  Redis                                  |      DF                                |\n| ----------------------------------------|----------------------------------------|\n| QPS: 220K, P99.9: 0.98ms , P99: 0.8ms   |  QPS: 305K, P99.9: 1.03ms, P99: 0.87ms |\n\n\nDragonfly throughput capacity continues to grow with instance size,\nwhile single-threaded Redis is bottlenecked on CPU and reaches local maxima in terms of performance.\n\n<img src=\"http://static.dragonflydb.io/repo-assets/aws-throughput.svg\" width=\"80%\" border=\"0\"/>\n\nIf we compare Dragonfly and Redis on the most network-capable instance c6gn.16xlarge,\nDragonfly showed a 25X increase in throughput compared to Redis single process, crossing 3.8M QPS.\n\nDragonfly's 99th percentile latency metrics at its peak throughput:\n\n| op    | r6g   | c6gn  | c7g   |\n|-------|-------|-------|-------|\n| set   | 0.8ms | 1ms   | 1ms   |\n| get   | 0.9ms | 0.9ms | 0.8ms |\n| setex | 0.9ms | 1.1ms | 1.3ms |\n\n*All benchmarks were performed using `memtier_benchmark` (see below) with number of threads tuned per server and instance type. `memtier` was run on a separate c6gn.16xlarge machine. We set the expiry time to 500 for the SETEX benchmark to ensure it would survive the end of the test.*\n\n```bash\n  memtier_benchmark --ratio ... -t <threads> -c 30 -n 200000 --distinct-client-seed -d 256 \\\n     --expiry-range=...\n```\n\nIn pipeline mode `--pipeline=30`, Dragonfly reaches **10M QPS** for SET and **15M QPS** for GET operations.\n\n### Dragonfly vs. Memcached\n\nWe compared Dragonfly with Memcached on a c6gn.16xlarge instance on AWS.\n\nWith a comparable latency, Dragonfly throughput outperformed Memcached throughput in both write and read workloads. Dragonfly demonstrated better latency in write workloads due to contention on the [write path in Memcached](docs/memcached_benchmark.md).\n\n#### SET benchmark\n\n| Server    | QPS(thousands qps) | latency 99% | 99.9%   |\n|:---------:|:------------------:|:-----------:|:-------:|\n| Dragonfly |  🟩 3844           |🟩 0.9ms     | 🟩 2.4ms |\n| Memcached |   806              |   1.6ms     | 3.2ms    |\n\n#### GET benchmark\n\n| Server    | QPS(thousands qps) | latency 99% | 99.9%   |\n|-----------|:------------------:|:-----------:|:-------:|\n| Dragonfly | 🟩 3717            |   1ms       | 2.4ms   |\n| Memcached |   2100             |  🟩 0.34ms  | 🟩 0.6ms |\n\n\nMemcached exhibited lower latency for the read benchmark, but also lower throughput.\n\n### Memory efficiency\n\nTo test memory efficiency, we filled Dragonfly and Redis with ~5GB of data using the `debug populate 5000000 key 1024` command, sent update traffic with `memtier`, and kicked off the snapshotting with the `bgsave` command.\n\nThis figure demonstrates how each server behaved in terms of memory efficiency.\n\n<img src=\"http://static.dragonflydb.io/repo-assets/bgsave-memusage.svg\" width=\"70%\" border=\"0\"/>\n\nDragonfly was 30% more memory efficient than Redis in the idle state and did not show any visible increase in memory use during the snapshot phase. At peak, Redis memory use increased to almost 3X that of Dragonfly.\n\nDragonfly finished the snapshot faster, within a few seconds.\n\nFor more info about memory efficiency in Dragonfly, see our [Dashtable doc](/docs/dashtable.md).\n\n\n\n## <a name=\"configuration\"><a/>Configuration\n\nDragonfly supports common Redis arguments where applicable. For example, you can run: `dragonfly --requirepass=foo --bind localhost`.\n\nDragonfly currently supports the following Redis-specific arguments:\n * `port`: Redis connection port (`default: 6379`).\n * `bind`: Use `localhost` to only allow localhost connections or a public IP address to allow connections **to that IP** address (i.e. from outside too). Use `0.0.0.0` to allow all IPv4.\n * `requirepass`: The password for AUTH authentication (`default: \"\"`).\n * `maxmemory`: Limit on maximum memory (in human-readable bytes) used by the database (`default: 0`). A `maxmemory` value of `0` means the program will automatically determine its maximum memory usage.\n * `dir`: Dragonfly Docker uses the `/data` folder for snapshotting by default, the CLI uses `\"\"`. You can use the `-v` Docker option to map it to your host folder.\n * `dbfilename`: The filename to save and load the database (`default: dump`).\n\nThere are also some Dragonfly-specific arguments:\n * `memcached_port`: The port to enable Memcached-compatible API on (`default: disabled`).\n * `keys_output_limit`: Maximum number of returned keys in `keys` command (`default: 8192`). Note that `keys` is a dangerous command. We truncate its result to avoid a blowup in memory use when fetching too many keys.\n * `dbnum`: Maximum number of supported databases for `select`.\n * `cache_mode`: See the [novel cache design](#novel-cache-design) section below.\n * `hz`: Key expiry evaluation frequency (`default: 100`). Lower frequency uses less CPU when idle at the expense of a slower eviction rate.\n * `snapshot_cron`: Cron schedule expression for automatic backup snapshots using standard cron syntax with the granularity of minutes (`default: \"\"`).\n   Here are some cron schedule expression examples below, and feel free to read more about this argument in our [documentation](https://www.dragonflydb.io/docs/managing-dragonfly/backups#the-snapshot_cron-flag).\n\n   | Cron Schedule Expression | Description                                |\n   |--------------------------|--------------------------------------------|\n   | `* * * * *`              | At every minute                            |\n   | `*/5 * * * *`            | At every 5th minute                        |\n   | `5 */2 * * *`            | At minute 5 past every 2nd hour            |\n   | `0 0 * * *`              | At 00:00 (midnight) every day              |\n   | `0 6 * * 1-5`            | At 06:00 (dawn) from Monday through Friday |\n\n * `primary_port_http_enabled`: Allows accessing HTTP console on main TCP port if `true` (`default: true`).\n * `admin_port`: To enable admin access to the console on the assigned port (`default: disabled`). Supports both HTTP and RESP protocols.\n * `admin_bind`: To bind the admin console TCP connection to a given address (`default: any`). Supports both HTTP and RESP protocols.\n * `admin_nopass`: To enable open admin access to console on the assigned port, without auth token needed (`default: false`). Supports both HTTP and RESP protocols.\n * `cluster_mode`: Cluster mode supported (`default: \"\"`). Currently supports only `emulated`.\n * `cluster_announce_ip`: The IP that cluster commands announce to the client.\n * `announce_port`: The port that cluster commands announce to the client, and to replication master.\n\n### Example start script with popular options:\n\n```bash\n./dragonfly-x86_64 --logtostderr --requirepass=youshallnotpass --cache_mode=true -dbnum 1 --bind localhost --port 6379 --maxmemory=12gb --keys_output_limit=12288 --dbfilename dump.rdb\n```\n\nArguments can be also provided via:\n * `--flagfile <filename>`: The file should list one flag per line, with equal signs instead of spaces for key-value flags. No quotes are needed for flag values.\n * Setting environment variables. Set `DFLY_x`, where `x` is the exact name of the flag, case sensitive.\n\nFor more options like logs management or TLS support, run `dragonfly --help`.\n\n## <a name=\"roadmap-status\"><a/>Roadmap and status\n\nDragonfly currently supports ~185 Redis commands and all Memcached commands besides `cas`. Almost on par with the Redis 5 API, Dragonfly's next milestone will be to stabilize basic functionality and implement the replication API. If there is a command you need that is not implemented yet, please open an issue.\n\nFor Dragonfly-native replication, we are designing a distributed log format that will support order-of-magnitude higher speeds.\n\nFollowing the replication feature, we will continue adding missing commands for Redis versions 3-6 APIs.\n\nPlease see our [Command Reference](https://dragonflydb.io/docs/category/command-reference) for the current commands supported by Dragonfly.\n\n## <a name=\"design-decisions\"><a/> Design decisions\n\n### Novel cache design\n\nDragonfly has a single, unified, adaptive caching algorithm that is simple and memory efficient.\n\nYou can enable caching mode by passing the `--cache_mode=true` flag. Once this mode is on, Dragonfly will evict items least likely to be stumbled upon in the future but only when it is near the `maxmemory` limit.\n\n### Expiration deadlines with relative accuracy\n\nExpiration ranges are limited to ~8 years.\n\nExpiration deadlines with millisecond precision (PEXPIRE, PSETEX, etc.) are rounded to the closest second **for deadlines greater than 2^28ms**, which has less than 0.001% error and should be acceptable for large ranges. If this is not suitable for your use case, get in touch or open an issue explaining your case.\n\nFor more detailed differences between Dragonfly expiration deadlines and Redis implementations, [see here](docs/differences.md).\n\n### Native HTTP console and Prometheus-compatible metrics\n\nBy default, Dragonfly allows HTTP access via its main TCP port (6379). That's right, you can connect to Dragonfly via Redis protocol and via HTTP protocol — the server recognizes the protocol automatically during the connection initiation. Go ahead and try it with your browser. HTTP access currently does not have much info but will include useful debugging and management info in the future.\n\nGo to the URL `:6379/metrics` to view Prometheus-compatible metrics.\n\nThe Prometheus exported metrics are compatible with the Grafana dashboard, [see here](tools/local/monitoring/grafana/provisioning/dashboards/dashboard.json).\n\n\nImportant! The HTTP console is meant to be accessed within a safe network. If you expose Dragonfly's TCP port externally, we advise you to disable the console with `--http_admin_console=false` or `--nohttp_admin_console`.\n\n\n## <a name=\"background\"><a/>Background\n\nDragonfly started as an experiment to see how an in-memory datastore could look if it was designed in 2022. Based on lessons learned from our experience as users of memory stores and engineers who worked for cloud companies, we knew that we need to preserve two key properties for Dragonfly: Atomicity guarantees for all operations and low, sub-millisecond latency over very high throughput.\n\nOur first challenge was how to fully utilize CPU, memory, and I/O resources using servers that are available today in public clouds. To solve this, we use [shared-nothing architecture](https://en.wikipedia.org/wiki/Shared-nothing_architecture), which allows us to partition the keyspace of the memory store between threads so that each thread can manage its own slice of dictionary data. We call these slices \"shards\". The library that powers thread and I/O management for shared-nothing architecture is open-sourced [here](https://github.com/romange/helio).\n\nTo provide atomicity guarantees for multi-key operations, we use the advancements from recent academic research. We chose the paper [\"VLL: a lock manager redesign for main memory database systems”](https://www.cs.umd.edu/~abadi/papers/vldbj-vll.pdf) to develop the transactional framework for Dragonfly. The choice of shared-nothing architecture and VLL allowed us to compose atomic multi-key operations without using mutexes or spinlocks. This was a major milestone for our PoC and its performance stood out from other commercial and open-source solutions.\n\nOur second challenge was to engineer more efficient data structures for the new store. To achieve this goal, we based our core hashtable structure on the paper [\"Dash: Scalable Hashing on Persistent Memory\"](https://arxiv.org/pdf/2003.07302.pdf). The paper itself is centered around the persistent memory domain and is not directly related to main-memory stores, but it's still most applicable to our problem. The hashtable design suggested in the paper allowed us to maintain two special properties that are present in the Redis dictionary: The incremental hashing ability during datastore growth the ability to traverse the dictionary under changes using a stateless scan operation. In addition to these two properties, Dash is more efficient in CPU and memory use. By leveraging Dash's design, we were able to innovate further with the following features:\n * Efficient record expiry for TTL records.\n * A novel cache eviction algorithm that achieves higher hit rates than other caching strategies like LRU and LFU with **zero memory overhead**.\n * A novel **fork-less** snapshotting algorithm.\n\nOnce we had built the foundation for Dragonfly and [we were happy with its performance](#benchmarks), we went on to implement the Redis and Memcached functionality. We have to date implemented ~185 Redis commands (roughly equivalent to Redis 5.0 API) and 13 Memcached commands.\n\nAnd finally, <br>\n<em>Our mission is to build a well-designed, ultra-fast, cost-efficient in-memory datastore for cloud workloads that takes advantage of the latest hardware advancements. We intend to address the pain points of current solutions while preserving their product APIs and propositions.\n</em>\n"
        },
        {
          "name": "README.zh-CN.md",
          "type": "blob",
          "size": 13.29,
          "content": "<p align=\"center\">\n  <a href=\"https://dragonflydb.io\">\n    <img  src=\"/.github/images/logo-full.svg\"\n      width=\"284\" border=\"0\" alt=\"Dragonfly\">\n  </a>\n</p>\n\n\n\n[![ci-tests](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml/badge.svg)](https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml) [![Twitter URL](https://img.shields.io/twitter/follow/dragonflydbio?style=social)](https://twitter.com/dragonflydbio)\n\n> 在您继续之前，请考虑给我们一个 GitHub 星标 ⭐️。谢谢！\n\n其他语言:  [English](README.md) [日本語](README.ja-JP.md) [한국어](README.ko-KR.md)\n\n[主页](https://dragonflydb.io/) • [快速入门](https://github.com/dragonflydb/dragonfly/tree/main/docs/quick-start) • [社区 Discord](https://discord.gg/HsPjXGVH85) • [Dragonfly 论坛](https://dragonfly.discourse.group/) • [加入 Dragonfly 社区](https://www.dragonflydb.io/community)\n\n[GitHub Discussions](https://github.com/dragonflydb/dragonfly/discussions) • [GitHub Issues](https://github.com/dragonflydb/dragonfly/issues) • [贡献指南](https://github.com/dragonflydb/dragonfly/blob/main/CONTRIBUTING.md)\n\n## 全世界最快的内存数据库\n\nDragonfly是一种针对现代应用程序负荷需求而构建的内存数据库，完全兼容Redis和Memcached的 API，迁移时无需修改任何代码。相比于这些传统的内存数据库，Dragonfly提供了其25倍的吞吐量，高缓存命中率和低尾延迟，并且对于相同大小的工作负载运行资源最多可减少80%。\n\n## 目录\n\n- [基准测试](#基准测试)\n- [快速入门](https://github.com/dragonflydb/dragonfly/tree/main/docs/quick-start)\n- [配置方法](#配置方法)\n- [开发路线和开发现状](#开发路线和开发现状)\n- [设计决策](#设计决策)\n- [开发背景](#开发背景)\n\n## <a name=\"基准测试\"><a/> 基准测试\n\n<img src=\"http://static.dragonflydb.io/repo-assets/aws-throughput.svg\" width=\"80%\" border=\"0\"/>\n\nDragonfly在c6gn.16xlarge上达到了每秒380万个查询（QPS），相比于Redis，吞吐量提高了25倍。\n\n在Dragonfly的峰值吞吐量下，P99延迟如下：\n\n| op    | r6g   | c6gn  | c7g   |\n| ----- | ----- | ----- | ----- |\n| set   | 0.8ms | 1ms   | 1ms   |\n| get   | 0.9ms | 0.9ms | 0.8ms |\n| setex | 0.9ms | 1.1ms | 1.3ms |\n\n*所有基准测试均使用`memtier_benchmark`（见下文），根据服务器类型和实例类型调整线程数。`memtier`运行在独立的c6gn.16xlarge机器上。对于setex基准测试，我们使用了500的到期范围，以便其能够存活直到测试结束。*\n\n```bash\n  memtier_benchmark --ratio ... -t <threads> -c 30 -n 200000 --distinct-client-seed -d 256 \\\n     --expiry-range=...\n```\n\n当以管道模式运行，并设置参数`--pipeline=30`时，Dragonfly可以实现**10M qps**的SET操作和 **15M qps**的GET操作。\n\n### Memcached / Dragonfly\n\n我们在 AWS 的 `c6gn.16xlarge` 实例上比较了 memcached 和 Dragonfly。如下图所示，与 memcached 相比，Dragonfly 的吞吐量在读写两方面上都占据了优势，并且在延迟方面也还不错。对于写入工作，Dragonfly 的延迟更低，这是由于在 memcached 的写入路径上存在竞争（请参见[此处](docs/memcached_benchmark.md)）。\n\n#### SET benchmark\n\n|  Server   | QPS(thousands qps) | latency 99% |  99.9%  |\n| :-------: | :----------------: | :---------: | :-----: |\n| Dragonfly |       🟩 3844       |   🟩 0.9ms   | 🟩 2.4ms |\n| Memcached |        806         |    1.6ms    |  3.2ms  |\n\n#### GET benchmark\n\n| Server    | QPS(thousands qps) | latency 99% |  99.9%  |\n| --------- | :----------------: | :---------: | :-----: |\n| Dragonfly |       🟩 3717       |     1ms     |  2.4ms  |\n| Memcached |        2100        |  🟩 0.34ms   | 🟩 0.6ms |\n\n\n对于读取基准测试，Memcached 表现出了更低的延迟，但在吞吐量方面比不上Dragonfly。\n\n### 内存效率\n\n在接下来的测试中，我们使用 `debug populate 5000000 key 1024` 命令向 Dragonfly 和 Redis 分别写入了约 5GB 的数据。然后我们使用 `memtier` 发送更新流量并使用 `bgsave` 命令启动快照。下图清楚地展示了这两个服务器在内存效率方面的表现。\n\n<img src=\"http://static.dragonflydb.io/repo-assets/bgsave-memusage.svg\" width=\"70%\" border=\"0\"/>\n\n在空闲状态下，Dragonfly 比 Redis 节省约 30% 的内存。\n在快照阶段，Dragonfly 也没有显示出任何明显的内存增加。\n但同时，Redis 在峰值时的内存几乎达到了 Dragonfly 的 3 倍。\nDragonfly 完成快照也很快，仅在启动后几秒钟内就完成了。\n有关 Dragonfly 内存效率的更多信息，请参见 [dashtable 文档](/docs/dashtable.md)。\n\n\n\n## <a name=\"开发路线和开发现状\"><a/>配置方法\n\nDragonfly 支持 Redis 的常见参数。\n例如，您可以运行：`dragonfly --requirepass=foo --bind localhost`。\n\n目前，Dragonfly 支持以下 Redis 特定参数：\n\n* `port`：Redis 连接端口，默认为 `6379`。\n* `bind`：使用本地主机名仅允许本地连接，使用公共 IP 地址允许外部连接到**该 IP 地址**。\n* `requirepass`：AUTH 认证密码，默认为空 `\"\"`。\n* `maxmemory`：限制数据库使用的最大内存（以字节为单位）。`0` 表示程序将自动确定其最大内存使用量。默认为 `0`。\n* `dir`：默认情况下，dragonfly docker 使用 `/data` 文件夹进行快照。CLI 使用的是 `\"\"`。你可以使用 `-v` docker 选项将其映射到主机文件夹。\n* `dbfilename`：保存/加载数据库的文件名。默认为 `dump`；\n\n此外，还有 Dragonfly 特定的参数选项：\n\n* `memcached_port`：在此端口上启用 memcached 兼容的 API。默认禁用。\n\n* `keys_output_limit`：在`keys` 命令中返回的最大键数。默认为 `8192`。\n\n  `keys` 命令是危险命令。我们会截断结果以避免在获取太多键时内存溢出。\n\n* `dbnum`：`select` 支持的最大数据库数。\n\n* `cache_mode`：请参见下面的 [缓存](#全新的缓存设计) 部分。\n\n* `hz`：键到期评估频率。默认为 `100`。空闲时，使用较低的频率可以占用较少的 CPU资源，但这会导致清理过期键的速度下降。\n\n* `snapshot_cron`：定时自动备份快照的 cron 表达式，使用标准的、精确到分钟的 cron 语法。默认为空 `\"\"`。\n\n  下面是一些 cron 表达式的示例，更多关于此参数的细节请参见[文档](https://www.dragonflydb.io/docs/managing-dragonfly/backups#the-snapshot_cron-flag)。\n\n  | Cron 表达式      | 描述                               |\n  |---------------|----------------------------------|\n  | `* * * * *`   | 每分钟                              |\n  | `*/5 * * * *` | 每隔 5 分钟 (00:00, 00:05, 00:10...) |\n  | `5 */2 * * *` | 每隔 2 小时的第 5 分钟                   |\n  | `0 0 * * *`   | 每天的 00:00 午夜                     |\n  | `0 6 * * 1-5` | 从星期一到星期五的每天 06:00 黎明             |\n* `primary_port_http_enabled`：如果为 true，则允许在主 TCP 端口上访问 HTTP 控制台。默认为 `true`。\n\n* `admin_port`：如果设置，将在指定的端口上启用对控制台的管理访问。支持 HTTP 和 RESP 协议。默认禁用。\n\n* `admin_bind`：如果设置，将管理控制台 TCP 连接绑定到给定地址。支持 HTTP 和 RESP 协议。默认为 `any`。\n\n* `admin_nopass`: 如果设置，允许在不提供任何认证令牌的情况下，通过指定的端口访问管理控制台。同时支持 HTTP 和 RESP 协议。 默认为 `false`。\n\n* `cluster_mode`：支持集群模式。目前仅支持 `emulated`。默认为空 `\"\"`。\n\n* `cluster_announce_ip`：集群模式下向客户端公开的 IP。\n\n### 启动脚本示例，包含常用选项：\n\n```bash\n./dragonfly-x86_64 --logtostderr --requirepass=youshallnotpass --cache_mode=true -dbnum 1 --bind localhost --port 6379 --maxmemory=12gb --keys_output_limit=12288 --dbfilename dump.rdb\n```\n还可以通过运行 `dragonfly --flagfile <filename>` 从配置文件中获取参数，配置文件的每行应该列出一个参数，并用等号代替键值参数的空格。\n\n要获取更多选项，如日志管理或TLS支持，请运行 `dragonfly --help`。\n\n## <a name=\"开发路线和开发现状\"><a/>开发路线和开发现状\n\n目前，Dragonfly支持约185个Redis命令以及除 `cas` 之外的所有 Memcached 命令。\n我们几乎达到了Redis 5 API的水平。我们的下一个里程碑更新将会稳定基本功能并实现复刻API。\n如果您发现您需要的命令尚未实现，请提出一个Issue。\n\n对于dragonfly-native复制技术，我们正在设计一种分布式日志格式，该格式将支持更高的速度。\n\n在实现复制功能之后，我们将继续实现API 3-6中其他缺失的Redis命令。\n\n请参见[命令参考](https://dragonflydb.io/docs/category/command-reference)以了解Dragonfly当前支持的命令。\n\n## <a name=\"设计决策\"><a/> 设计决策\n\n### 全新的缓存设计\n\nDragonfly采用单一的自适应缓存算法，该算法非常简单且具备高内存效率。\n你可以通过使用 `--cache_mode=true` 参数来启用缓存模式。一旦启用了此模式，Dragonfly将会删除最低概率可能被使用的内容，但这只会在接近最大内存限制时发生。\n\n### 相对准确的过期期限\n\n过期范围限制最高为约8年。此外，**对于大于2^28ms的到期期限**，毫秒精度级别（PEXPIRE/PSETEX等）会被简化到秒级。\n这种舍入的误差小于0.001％，我希望这在长时间范围情况下是可以接受的。\n如果这不符合你的使用需求，请与我联系或提出一个Issue，并解释您的情况。\n\n关于与Redis实现之间的更多差异，请参见[此处](docs/differences.md)。\n\n### 原生HTTP控制台和兼容Prometheus的标准\n\n默认情况下，Dragonfly允许通过其主TCP端口（6379）进行HTTP访问。没错，您可以通过Redis协议或HTTP协议连接到Dragonfly - 服务器会在连接初始化期间自动识别协议。 不妨在你自己的浏览器中尝试一下。现在HTTP访问没有太多信息可供参考，但在将来，我们计划添加有用的调试和管理信息。如果您转到`: 6379/metrics` URL，您将看到一些兼容Prometheus的标准。\n\nPrometheus导出的标准与Grafana仪表盘兼容，[请参见此处](tools/local/monitoring/grafana/provisioning/dashboards/dashboard.json)。\n\n重要！HTTP控制台仅应在安全网络内访问。如果您将Dragonfly的TCP端口暴露在外部，则建议使用`--http_admin_console=false`或`--nohttp_admin_console`禁用控制台。\n\n\n## <a name=\"开发背景\"><a/>开发背景\n\nDragonfly始于一项实验，旨在探索如果在2022年重新设计内存数据库，它会是什么样子。基于我们作为内存存储的用户以及作为云服务公司的工程师的经验教训，我们得知需要保留Dragonfly的两个关键属性：a) 为其所有操作提供原子性保证，b) 保证在非常高的吞吐量下实现低于毫秒的延迟。\n\n我们面临的首要挑战是如何充分利用当今云服务器的CPU、内存和I/O资源。为了解决这个问题，我们使用了 [无共享式架构（shared-nothing architecture）](https://en.wikipedia.org/wiki/Shared-nothing_architecture)，它允许我们在不同的线程之间分割内存存储的空间，使得每个线程可以管理自己的字典数据切片。我们称这些切片为“分片（shards）”。为无共享式架构提供线程和I/O管理功能的库在[这里](https://github.com/romange/helio)开源。\n\n为了提供对多键并发操作的原子性保证，我们使用了最近学术研究的进展。我们选择了论文 [\"VLL: a lock manager redesign for main memory database systems”](https://www.cs.umd.edu/~abadi/papers/vldbj-vll.pdf) 来开发Dragonfly的事务框架。无共享式架构和VLL的选择使我们能够在不使用互斥锁或自旋锁的情况下组合原子的多键操作。这是我们 PoC 的一个重要里程碑，它的性能在商业和开源解决方案中脱颖而出。\n\n我们面临的第二个挑战是为新存储设计更高效的数据结构。为了实现这个目标，我们基于论文[\"Dash: Scalable Hashing on Persistent Memory\"](https://arxiv.org/pdf/2003.07302.pdf)构建了核心哈希表结构。这篇论文本身是以持久性内存为中心的，与主存没有直接相关性。\n\n然而，它非常适用于我们的问题。它提出了一种哈希表设计，允许我们维护Redis字典中存在的两个特殊属性：a) 数据存储增长时的渐进式哈希能力；b）使用无状态扫描操作时，遍历变化的字典的能力。除了这两个属性之外，Dash在CPU和内存方面都更加高效。通过利用Dash的设计，我们能够进一步创新，实现以下功能：\n\n- 针对TTL的高效记录过期功能。\n- 一种新颖的缓存驱逐算法，具有比其他缓存策略（如LRU和LFU）更高的命中率，同时**零内存开销**。\n- 一种新颖的无fork快照算法。\n\n在我们为Dragonfly打下基础并满意其[性能](#基准测试)后，我们开始实现Redis和Memcached功能。\n目前，我们已经实现了约185个Redis命令（大致相当于Redis 5.0 API）和13个Memcached命令。\n\n最后，<br>\n<em>我们的使命是构建一个设计良好、超高速、成本效益高的云工作负载内存数据存储系统，利用最新的硬件技术。我们旨在解决当前解决方案的痛点，同时保留其产品API和优势。</em>\n"
        },
        {
          "name": "TODO.md",
          "type": "blob",
          "size": 1.55,
          "content": "1. To move lua_project to dragonfly from helio (DONE)\n2. To limit lua stack to something reasonable like 4096.\n3. To inject our own allocator to lua to track its memory.\n\n\n## Object lifecycle and thread-safety.\n\nCurrently our transactional and locking model is based on an assumption that any READ or WRITE\naccess to objects must be performed in a shard where they belong.\n\nHowever, this assumption can be relaxed to get significant gains for read-only queries.\n\n### Explanation\nOur transactional framework prevents from READ-locked objects to be mutated. It does not prevent from their PrimaryTable to grow or change, of course. These objects can move to different entries inside the table. However, our CompactObject maintains the following property - its reference CompactObject.AsRef() is valid no matter where the master object moves and it's valid and safe for reading even from other threads. The exception regarding thread safety is SmallString which uses translation table for its pointers.\n\nIf we change the SmallString translation table to be global and thread-safe (it should not have lots of write contention anyway) we may access primetable keys and values from another thread and write them directly to sockets.\n\nUse-case: large strings that need to be copied. Sets that need to be serialized for SMEMBERS/HGETALL commands etc. Additional complexity - we will need to lock those variables even for single hop transactions and unlock them afterwards. The unlocking hop does not need to increase user-visible latency since it can be done after we send reply to the socket."
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.work",
          "type": "blob",
          "size": 0.06,
          "content": "go 1.20\n\nuse (\n\t./contrib/charts/dragonfly\n\t./tools/replay\n)\n"
        },
        {
          "name": "go.work.sum",
          "type": "blob",
          "size": 0.37,
          "content": "github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\n"
        },
        {
          "name": "helio",
          "type": "commit",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.15,
          "content": "[tool.black]\nline-length = 100\ninclude = '\\.py$'\nextend-exclude = '''\n/(\n    | .git\n    | .__pycache__\n    | build-dbg\n    | build-opt\n    | helio\n)/\n'''\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}